"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler@0.27.0_react@18.2.0";
exports.ids = ["vendor-chunks/react-reconciler@0.27.0_react@18.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var SyncLane = /*                        */ 1;\n        var InputContinuousLane = /*            */ 4;\n        var DefaultLane = /*                    */ 16;\n        var IdleLane = /*                       */ 536870912;\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        exports.ConcurrentRoot = ConcurrentRoot;\n        exports.ContinuousEventPriority = ContinuousEventPriority;\n        exports.DefaultEventPriority = DefaultEventPriority;\n        exports.DiscreteEventPriority = DiscreteEventPriority;\n        exports.IdleEventPriority = IdleEventPriority;\n        exports.LegacyRoot = LegacyRoot;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjI3LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsV0FDSiwwQkFBMEIsR0FDMUI7UUFDQSxJQUFJQyxzQkFDSixjQUFjLEdBQ2Q7UUFDQSxJQUFJQyxjQUNKLHNCQUFzQixHQUN0QjtRQUNBLElBQUlDLFdBQ0oseUJBQXlCLEdBQ3pCO1FBRUEsSUFBSUMsd0JBQXdCSjtRQUM1QixJQUFJSywwQkFBMEJKO1FBQzlCLElBQUlLLHVCQUF1Qko7UUFDM0IsSUFBSUssb0JBQW9CSjtRQUV4QixJQUFJSyxhQUFhO1FBQ2pCLElBQUlDLGlCQUFpQjtRQUVyQkMsc0JBQXNCLEdBQUdEO1FBQ3pCQywrQkFBK0IsR0FBR0w7UUFDbENLLDRCQUE0QixHQUFHSjtRQUMvQkksNkJBQTZCLEdBQUdOO1FBQ2hDTSx5QkFBeUIsR0FBR0g7UUFDNUJHLGtCQUFrQixHQUFHRjtJQUNuQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlY29uY2lsZXJAMC4yNy4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanM/NGZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIElucHV0Q29udGludW91c0xhbmUgPVxuLyogICAgICAgICAgICAqL1xuNDtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xuXG52YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG52YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xudmFyIERlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdExhbmU7XG52YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIENvbmN1cnJlbnRSb290ID0gMTtcblxuZXhwb3J0cy5Db25jdXJyZW50Um9vdCA9IENvbmN1cnJlbnRSb290O1xuZXhwb3J0cy5Db250aW51b3VzRXZlbnRQcmlvcml0eSA9IENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5EaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLklkbGVFdmVudFByaW9yaXR5ID0gSWRsZUV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLkxlZ2FjeVJvb3QgPSBMZWdhY3lSb290O1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJTeW5jTGFuZSIsIklucHV0Q29udGludW91c0xhbmUiLCJEZWZhdWx0TGFuZSIsIklkbGVMYW5lIiwiRGlzY3JldGVFdmVudFByaW9yaXR5IiwiQ29udGludW91c0V2ZW50UHJpb3JpdHkiLCJEZWZhdWx0RXZlbnRQcmlvcml0eSIsIklkbGVFdmVudFByaW9yaXR5IiwiTGVnYWN5Um9vdCIsIkNvbmN1cnJlbnRSb290IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    module.exports = function $$$reconciler($$$hostConfig) {\n        var exports = {};\n        \"use strict\";\n        var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.0.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n        var Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/.pnpm/scheduler@0.21.0/node_modules/scheduler/index.js\");\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n            {\n                suppressWarning = newSuppressWarning;\n            }\n        } // In DEV, calls to console.warn and console.error get replaced\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning(\"warn\", format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        var assign = Object.assign;\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        // -----------------------------------------------------------------------------\n        var enablePersistentOffscreenHostContainer = false; // -----------------------------------------------------------------------------\n        // the react-reconciler package.\n        var enableNewReconciler = false; // Support legacy Primer support on internal FB www\n        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        var enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\n        var warnAboutStringRefs = false; // -----------------------------------------------------------------------------\n        // Debugging and DevTools\n        // -----------------------------------------------------------------------------\n        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n        // for an experimental timeline tool.\n        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var IndeterminateComponent = 2; // Before we know whether it is function or class\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_TRACING_MARKER_TYPE = Symbol.for(\"react.tracing_marker\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            {\n                if (typeof type.tag === \"number\") {\n                    error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                }\n            }\n            if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return outerType.displayName || (functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        } // Keep in sync with shared/getComponentNameFromType\n        function getContextName$1(type) {\n            return type.displayName || \"Context\";\n        }\n        function getComponentNameFromFiber(fiber) {\n            var tag = fiber.tag, type = fiber.type;\n            switch(tag){\n                case CacheComponent:\n                    return \"Cache\";\n                case ContextConsumer:\n                    var context = type;\n                    return getContextName$1(context) + \".Consumer\";\n                case ContextProvider:\n                    var provider = type;\n                    return getContextName$1(provider._context) + \".Provider\";\n                case DehydratedFragment:\n                    return \"DehydratedFragment\";\n                case ForwardRef:\n                    return getWrappedName$1(type, type.render, \"ForwardRef\");\n                case Fragment:\n                    return \"Fragment\";\n                case HostComponent:\n                    // Host component type is the display name (e.g. \"div\", \"View\")\n                    return type;\n                case HostPortal:\n                    return \"Portal\";\n                case HostRoot:\n                    return \"Root\";\n                case HostText:\n                    return \"Text\";\n                case LazyComponent:\n                    // Name comes from the type in this case; we don't have a tag.\n                    return getComponentNameFromType(type);\n                case Mode:\n                    if (type === REACT_STRICT_MODE_TYPE) {\n                        // Don't be less specific than shared/getComponentNameFromType\n                        return \"StrictMode\";\n                    }\n                    return \"Mode\";\n                case OffscreenComponent:\n                    return \"Offscreen\";\n                case Profiler:\n                    return \"Profiler\";\n                case ScopeComponent:\n                    return \"Scope\";\n                case SuspenseComponent:\n                    return \"Suspense\";\n                case SuspenseListComponent:\n                    return \"SuspenseList\";\n                case TracingMarkerComponent:\n                    return \"TracingMarker\";\n                // The display name for this tags come from the user-provided type:\n                case ClassComponent:\n                case FunctionComponent:\n                case IncompleteClassComponent:\n                case IndeterminateComponent:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    if (typeof type === \"function\") {\n                        return type.displayName || type.name || null;\n                    }\n                    if (typeof type === \"string\") {\n                        return type;\n                    }\n                    break;\n            }\n            return null;\n        }\n        // Don't change these two values. They're used by React Dev Tools.\n        var NoFlags = /*                      */ 0;\n        var PerformedWork = /*                */ 1; // You can change the rest (and add more).\n        var Placement = /*                    */ 2;\n        var Update = /*                       */ 4;\n        var PlacementAndUpdate = /*           */ Placement | Update;\n        var ChildDeletion = /*                */ 16;\n        var ContentReset = /*                 */ 32;\n        var Callback = /*                     */ 64;\n        var DidCapture = /*                   */ 128;\n        var ForceClientRender = /*            */ 256;\n        var Ref = /*                          */ 512;\n        var Snapshot = /*                     */ 1024;\n        var Passive = /*                      */ 2048;\n        var Hydrating = /*                    */ 4096;\n        var HydratingAndUpdate = /*           */ Hydrating | Update;\n        var Visibility = /*                   */ 8192;\n        var StoreConsistency = /*             */ 16384;\n        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)\n        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.\n        var Incomplete = /*                   */ 32768;\n        var ShouldCapture = /*                */ 65536;\n        var ForceUpdateForLegacySuspense = /* */ 131072;\n        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n        // This enables us to defer more work in the unmount case,\n        // since we can defer traversing the tree during layout to look for Passive effects,\n        // and instead rely on the static flag as a signal that there may be cleanup work.\n        var RefStatic = /*                    */ 2097152;\n        var LayoutStatic = /*                 */ 4194304;\n        var PassiveStatic = /*                */ 8388608; // These flags allow us to traverse to fibers that have effects on mount\n        // without traversing the entire tree after every commit for\n        // double invoking\n        var MountLayoutDev = /*               */ 16777216;\n        var MountPassiveDev = /*              */ 33554432; // Groups of flags that are used in the commit phase to skip over trees that\n        // don't contain effects, by checking subtreeFlags.\n        var BeforeMutationMask = // flag logic (see #20043)\n        Update | Snapshot | 0;\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\n        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n        var PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.\n        // This allows certain concepts to persist without recalculating them,\n        // e.g. whether a subtree contains passive effects or portals.\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        function getNearestMountedFiber(fiber) {\n            var node = fiber;\n            var nearestMounted = fiber;\n            if (!fiber.alternate) {\n                // If there is no alternate, this might be a new tree that isn't inserted\n                // yet. If it is, then it will have a pending insertion effect on it.\n                var nextNode = node;\n                do {\n                    node = nextNode;\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n                        // This is an insertion or in-progress hydration. The nearest possible\n                        // mounted fiber is the parent but we need to continue to figure out\n                        // if that one is still mounted.\n                        nearestMounted = node.return;\n                    }\n                    nextNode = node.return;\n                }while (nextNode);\n            } else {\n                while(node.return){\n                    node = node.return;\n                }\n            }\n            if (node.tag === HostRoot) {\n                // TODO: Check if this was a nested HostRoot when used with\n                // renderContainerIntoSubtree.\n                return nearestMounted;\n            } // If we didn't hit the root, that means that we're in an disconnected tree\n            // that has been unmounted.\n            return null;\n        }\n        function isFiberMounted(fiber) {\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function isMounted(component) {\n            {\n                var owner = ReactCurrentOwner.current;\n                if (owner !== null && owner.tag === ClassComponent) {\n                    var ownerFiber = owner;\n                    var instance = ownerFiber.stateNode;\n                    if (!instance._warnedAboutRefsInRender) {\n                        error(\"%s is accessing isMounted inside its render() function. \" + \"render() should be a pure function of props and state. It should \" + \"never access something that requires stale data from the previous \" + \"render, such as refs. Move this logic to componentDidMount and \" + \"componentDidUpdate instead.\", getComponentNameFromFiber(ownerFiber) || \"A component\");\n                    }\n                    instance._warnedAboutRefsInRender = true;\n                }\n            }\n            var fiber = get(component);\n            if (!fiber) {\n                return false;\n            }\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n            if (getNearestMountedFiber(fiber) !== fiber) {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n            var alternate = fiber.alternate;\n            if (!alternate) {\n                // If there is no alternate, then we only need to check if it is mounted.\n                var nearestMounted = getNearestMountedFiber(fiber);\n                if (nearestMounted === null) {\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                }\n                if (nearestMounted !== fiber) {\n                    return null;\n                }\n                return fiber;\n            } // If we have two possible branches, we'll walk backwards up to the root\n            // to see what path the root points to. On the way we may hit one of the\n            // special cases and we'll deal with them.\n            var a = fiber;\n            var b = alternate;\n            while(true){\n                var parentA = a.return;\n                if (parentA === null) {\n                    break;\n                }\n                var parentB = parentA.alternate;\n                if (parentB === null) {\n                    // There is no alternate. This is an unusual case. Currently, it only\n                    // happens when a Suspense component is hidden. An extra fragment fiber\n                    // is inserted in between the Suspense fiber and its children. Skip\n                    // over this extra fragment fiber and proceed to the next parent.\n                    var nextParent = parentA.return;\n                    if (nextParent !== null) {\n                        a = b = nextParent;\n                        continue;\n                    } // If there's no parent, we're at the root.\n                    break;\n                } // If both copies of the parent fiber point to the same child, we can\n                // assume that the child is current. This happens when we bailout on low\n                // priority: the bailed out fiber's child reuses the current child.\n                if (parentA.child === parentB.child) {\n                    var child = parentA.child;\n                    while(child){\n                        if (child === a) {\n                            // We've determined that A is the current branch.\n                            assertIsMounted(parentA);\n                            return fiber;\n                        }\n                        if (child === b) {\n                            // We've determined that B is the current branch.\n                            assertIsMounted(parentA);\n                            return alternate;\n                        }\n                        child = child.sibling;\n                    } // We should never have an alternate for any mounting node. So the only\n                    // way this could possibly happen is if this was unmounted, if at all.\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                }\n                if (a.return !== b.return) {\n                    // The return pointer of A and the return pointer of B point to different\n                    // fibers. We assume that return pointers never criss-cross, so A must\n                    // belong to the child set of A.return, and B must belong to the child\n                    // set of B.return.\n                    a = parentA;\n                    b = parentB;\n                } else {\n                    // The return pointers point to the same fiber. We'll have to use the\n                    // default, slow path: scan the child sets of each parent alternate to see\n                    // which child belongs to which set.\n                    //\n                    // Search parent A's child set\n                    var didFindChild = false;\n                    var _child = parentA.child;\n                    while(_child){\n                        if (_child === a) {\n                            didFindChild = true;\n                            a = parentA;\n                            b = parentB;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = true;\n                            b = parentA;\n                            a = parentB;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) {\n                        // Search parent B's child set\n                        _child = parentB.child;\n                        while(_child){\n                            if (_child === a) {\n                                didFindChild = true;\n                                a = parentB;\n                                b = parentA;\n                                break;\n                            }\n                            if (_child === b) {\n                                didFindChild = true;\n                                b = parentB;\n                                a = parentA;\n                                break;\n                            }\n                            _child = _child.sibling;\n                        }\n                        if (!didFindChild) {\n                            throw new Error(\"Child was not found in either parent set. This indicates a bug \" + \"in React related to the return pointer. Please file an issue.\");\n                        }\n                    }\n                }\n                if (a.alternate !== b) {\n                    throw new Error(\"Return fibers should always be each others' alternates. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\n            // unmounted.\n            if (a.tag !== HostRoot) {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.stateNode.current === a) {\n                // We've determined that A is the current branch.\n                return fiber;\n            } // Otherwise B has to be current branch.\n            return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            if (node.tag === HostComponent || node.tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                var match = findCurrentHostFiberImpl(child);\n                if (match !== null) {\n                    return match;\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            if (node.tag === HostComponent || node.tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                if (child.tag !== HostPortal) {\n                    var match = findCurrentHostFiberWithNoPortalsImpl(child);\n                    if (match !== null) {\n                        return match;\n                    }\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // This is a host config that's used for the `react-reconciler` package on npm.\n        // It is only used by third-party renderers.\n        //\n        // Its API lets you pass the host config as an argument.\n        // However, inside the `react-reconciler` we treat host config as a module.\n        // This file is a shim between two worlds.\n        //\n        // It works because the `react-reconciler` bundle is wrapped in something like:\n        //\n        // module.exports = function ($$$config) {\n        //   /* reconciler code */\n        // }\n        //\n        // So `$$$config` looks like a global variable, but it's\n        // really an argument to a top-level wrapping function.\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        var getPublicInstance = $$$hostConfig.getPublicInstance;\n        var getRootHostContext = $$$hostConfig.getRootHostContext;\n        var getChildHostContext = $$$hostConfig.getChildHostContext;\n        var prepareForCommit = $$$hostConfig.prepareForCommit;\n        var resetAfterCommit = $$$hostConfig.resetAfterCommit;\n        var createInstance = $$$hostConfig.createInstance;\n        var appendInitialChild = $$$hostConfig.appendInitialChild;\n        var finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;\n        var prepareUpdate = $$$hostConfig.prepareUpdate;\n        var shouldSetTextContent = $$$hostConfig.shouldSetTextContent;\n        var createTextInstance = $$$hostConfig.createTextInstance;\n        var scheduleTimeout = $$$hostConfig.scheduleTimeout;\n        var cancelTimeout = $$$hostConfig.cancelTimeout;\n        var noTimeout = $$$hostConfig.noTimeout;\n        var now = $$$hostConfig.now;\n        var isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;\n        var warnsIfNotActing = $$$hostConfig.warnsIfNotActing;\n        var supportsMutation = $$$hostConfig.supportsMutation;\n        var supportsPersistence = $$$hostConfig.supportsPersistence;\n        var supportsHydration = $$$hostConfig.supportsHydration;\n        var getInstanceFromNode = $$$hostConfig.getInstanceFromNode;\n        var beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;\n        var afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;\n        var preparePortalMount = $$$hostConfig.preparePortalMount;\n        var prepareScopeUpdate = $$$hostConfig.preparePortalMount;\n        var getInstanceFromScope = $$$hostConfig.getInstanceFromScope;\n        var getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;\n        var detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------\n        //      Microtasks\n        //     (optional)\n        // -------------------\n        var supportsMicrotasks = $$$hostConfig.supportsMicrotasks;\n        var scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------\n        //      Test selectors\n        //     (optional)\n        // -------------------\n        var supportsTestSelectors = $$$hostConfig.supportsTestSelectors;\n        var findFiberRoot = $$$hostConfig.findFiberRoot;\n        var getBoundingRect = $$$hostConfig.getBoundingRect;\n        var getTextContent = $$$hostConfig.getTextContent;\n        var isHiddenSubtree = $$$hostConfig.isHiddenSubtree;\n        var matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;\n        var setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;\n        var setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------\n        //      Mutation\n        //     (optional)\n        // -------------------\n        var appendChild = $$$hostConfig.appendChild;\n        var appendChildToContainer = $$$hostConfig.appendChildToContainer;\n        var commitTextUpdate = $$$hostConfig.commitTextUpdate;\n        var commitMount = $$$hostConfig.commitMount;\n        var commitUpdate = $$$hostConfig.commitUpdate;\n        var insertBefore = $$$hostConfig.insertBefore;\n        var insertInContainerBefore = $$$hostConfig.insertInContainerBefore;\n        var removeChild = $$$hostConfig.removeChild;\n        var removeChildFromContainer = $$$hostConfig.removeChildFromContainer;\n        var resetTextContent = $$$hostConfig.resetTextContent;\n        var hideInstance = $$$hostConfig.hideInstance;\n        var hideTextInstance = $$$hostConfig.hideTextInstance;\n        var unhideInstance = $$$hostConfig.unhideInstance;\n        var unhideTextInstance = $$$hostConfig.unhideTextInstance;\n        var clearContainer = $$$hostConfig.clearContainer; // -------------------\n        //     Persistence\n        //     (optional)\n        // -------------------\n        var cloneInstance = $$$hostConfig.cloneInstance;\n        var createContainerChildSet = $$$hostConfig.createContainerChildSet;\n        var appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;\n        var finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;\n        var replaceContainerChildren = $$$hostConfig.replaceContainerChildren;\n        var getOffscreenContainerType = $$$hostConfig.getOffscreenContainerType;\n        var getOffscreenContainerProps = $$$hostConfig.getOffscreenContainerProps;\n        var cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;\n        var cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------\n        //     Hydration\n        //     (optional)\n        // -------------------\n        var canHydrateInstance = $$$hostConfig.canHydrateInstance;\n        var canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;\n        var canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;\n        var isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;\n        var isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;\n        var registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;\n        var getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;\n        var getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;\n        var getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;\n        var getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;\n        var hydrateInstance = $$$hostConfig.hydrateInstance;\n        var hydrateTextInstance = $$$hostConfig.hydrateTextInstance;\n        var hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;\n        var getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;\n        var commitHydratedContainer = $$$hostConfig.commitHydratedContainer;\n        var commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;\n        var clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;\n        var clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;\n        var shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;\n        var didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;\n        var didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;\n        var didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;\n        var didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;\n        var didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;\n        var didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;\n        var didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;\n        var didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;\n        var didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;\n        var didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;\n        var didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;\n        var didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;\n        var didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;\n        var didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;\n        var errorHydratingContainer = $$$hostConfig.errorHydratingContainer;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            var control;\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            try {\n                // This should throw.\n                if (construct) {\n                    // Something should be setting the props in the constructor.\n                    var Fake = function() {\n                        throw Error();\n                    }; // $FlowFixMe\n                    Object.defineProperty(Fake.prototype, \"props\", {\n                        set: function() {\n                            // We use a throwing setter instead of frozen or non-writable props\n                            // because that won't throw in a non-strict mode function.\n                            throw Error();\n                        }\n                    });\n                    if (typeof Reflect === \"object\" && Reflect.construct) {\n                        // We construct a different control for this case to include any extra\n                        // frames added by the construct call.\n                        try {\n                            Reflect.construct(Fake, []);\n                        } catch (x) {\n                            control = x;\n                        }\n                        Reflect.construct(fn, [], Fake);\n                    } else {\n                        try {\n                            Fake.call();\n                        } catch (x) {\n                            control = x;\n                        }\n                        fn.call(Fake.prototype);\n                    }\n                } else {\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        control = x;\n                    }\n                    fn();\n                }\n            } catch (sample) {\n                // This is inlined manually because closure doesn't do it for us.\n                if (sample && control && typeof sample.stack === \"string\") {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sample.stack.split(\"\\n\");\n                    var controlLines = control.stack.split(\"\\n\");\n                    var s = sampleLines.length - 1;\n                    var c = controlLines.length - 1;\n                    while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                        // We expect at least one stack frame to be shared.\n                        // Typically this will be the root most one. However, stack frames may be\n                        // cut off due to maximum stack limits. In this case, one maybe cut off\n                        // earlier than the other. We assume that the sample is longer or the same\n                        // and there for cut off earlier. So we should find the root most frame in\n                        // the sample somewhere in the control.\n                        c--;\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        }\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement(null);\n                        }\n                    }\n                }\n            }\n        }\n        var valueStack = [];\n        var fiberStack;\n        {\n            fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n            return {\n                current: defaultValue\n            };\n        }\n        function pop(cursor, fiber) {\n            if (index < 0) {\n                {\n                    error(\"Unexpected pop.\");\n                }\n                return;\n            }\n            {\n                if (fiber !== fiberStack[index]) {\n                    error(\"Unexpected Fiber popped.\");\n                }\n            }\n            cursor.current = valueStack[index];\n            valueStack[index] = null;\n            {\n                fiberStack[index] = null;\n            }\n            index--;\n        }\n        function push(cursor, value, fiber) {\n            index++;\n            valueStack[index] = cursor.current;\n            {\n                fiberStack[index] = fiber;\n            }\n            cursor.current = value;\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n            warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n        var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n        // We use this to get access to the parent context after we have already\n        // pushed the next context provider, and now need to merge their contexts.\n        var previousContext = emptyContextObject;\n        function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n            {\n                if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n                    // If the fiber is a context provider itself, when we read its context\n                    // we may have already pushed its own child context on the stack. A context\n                    // provider should not \"see\" its own child context. Therefore we read the\n                    // previous (parent) context instead for a context provider.\n                    return previousContext;\n                }\n                return contextStackCursor.current;\n            }\n        }\n        function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n            {\n                var instance = workInProgress.stateNode;\n                instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n                instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n            }\n        }\n        function getMaskedContext(workInProgress, unmaskedContext) {\n            {\n                var type = workInProgress.type;\n                var contextTypes = type.contextTypes;\n                if (!contextTypes) {\n                    return emptyContextObject;\n                } // Avoid recreating masked context unless unmasked context has changed.\n                // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n                // This may trigger infinite loops if componentWillReceiveProps calls setState.\n                var instance = workInProgress.stateNode;\n                if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n                    return instance.__reactInternalMemoizedMaskedChildContext;\n                }\n                var context = {};\n                for(var key in contextTypes){\n                    context[key] = unmaskedContext[key];\n                }\n                {\n                    var name = getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    checkPropTypes(contextTypes, context, \"context\", name);\n                }\n                // Context is created before the class component is instantiated so check for instance.\n                if (instance) {\n                    cacheContext(workInProgress, unmaskedContext, context);\n                }\n                return context;\n            }\n        }\n        function hasContextChanged() {\n            {\n                return didPerformWorkStackCursor.current;\n            }\n        }\n        function isContextProvider(type) {\n            {\n                var childContextTypes = type.childContextTypes;\n                return childContextTypes !== null && childContextTypes !== undefined;\n            }\n        }\n        function popContext(fiber) {\n            {\n                pop(didPerformWorkStackCursor, fiber);\n                pop(contextStackCursor, fiber);\n            }\n        }\n        function popTopLevelContextObject(fiber) {\n            {\n                pop(didPerformWorkStackCursor, fiber);\n                pop(contextStackCursor, fiber);\n            }\n        }\n        function pushTopLevelContextObject(fiber, context, didChange) {\n            {\n                if (contextStackCursor.current !== emptyContextObject) {\n                    throw new Error(\"Unexpected context found on stack. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                push(contextStackCursor, context, fiber);\n                push(didPerformWorkStackCursor, didChange, fiber);\n            }\n        }\n        function processChildContext(fiber, type, parentContext) {\n            {\n                var instance = fiber.stateNode;\n                var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n                // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n                if (typeof instance.getChildContext !== \"function\") {\n                    {\n                        var componentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                        if (!warnedAboutMissingGetChildContext[componentName]) {\n                            warnedAboutMissingGetChildContext[componentName] = true;\n                            error(\"%s.childContextTypes is specified but there is no getChildContext() method \" + \"on the instance. You can either define getChildContext() on %s or remove \" + \"childContextTypes from it.\", componentName, componentName);\n                        }\n                    }\n                    return parentContext;\n                }\n                var childContext = instance.getChildContext();\n                for(var contextKey in childContext){\n                    if (!(contextKey in childContextTypes)) {\n                        throw new Error((getComponentNameFromFiber(fiber) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n                    }\n                }\n                {\n                    var name = getComponentNameFromFiber(fiber) || \"Unknown\";\n                    checkPropTypes(childContextTypes, childContext, \"child context\", name);\n                }\n                return assign({}, parentContext, childContext);\n            }\n        }\n        function pushContextProvider(workInProgress) {\n            {\n                var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n                // If the instance does not exist yet, we will push null at first,\n                // and replace it on the stack later when invalidating the context.\n                var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n                // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n                previousContext = contextStackCursor.current;\n                push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n                push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n                return true;\n            }\n        }\n        function invalidateContextProvider(workInProgress, type, didChange) {\n            {\n                var instance = workInProgress.stateNode;\n                if (!instance) {\n                    throw new Error(\"Expected to have an instance by this point. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                if (didChange) {\n                    // Merge parent and own context.\n                    // Skip this if we're not updating due to sCU.\n                    // This avoids unnecessarily recomputing memoized values.\n                    var mergedContext = processChildContext(workInProgress, type, previousContext);\n                    instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n                    // It is important to unwind the context in the reverse order.\n                    pop(didPerformWorkStackCursor, workInProgress);\n                    pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n                    push(contextStackCursor, mergedContext, workInProgress);\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\n                } else {\n                    pop(didPerformWorkStackCursor, workInProgress);\n                    push(didPerformWorkStackCursor, didChange, workInProgress);\n                }\n            }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n            {\n                // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n                // makes sense elsewhere\n                if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n                    throw new Error(\"Expected subtree parent to be a mounted class component. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                var node = fiber;\n                do {\n                    switch(node.tag){\n                        case HostRoot:\n                            return node.stateNode.context;\n                        case ClassComponent:\n                            {\n                                var Component = node.type;\n                                if (isContextProvider(Component)) {\n                                    return node.stateNode.__reactInternalMemoizedMergedChildContext;\n                                }\n                                break;\n                            }\n                    }\n                    node = node.return;\n                }while (node !== null);\n                throw new Error(\"Found unexpected detached subtree parent. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n        var ConcurrentMode = /*                 */ 1;\n        var ProfileMode = /*                    */ 2;\n        var StrictLegacyMode = /*               */ 8;\n        var StrictEffectsMode = /*              */ 16;\n        // TODO: This is pretty well supported by browsers. Maybe we can drop it.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        // If those values are changed that package should be rebuilt and redeployed.\n        var TotalLanes = 31;\n        var NoLanes = /*                        */ 0;\n        var NoLane = /*                          */ 0;\n        var SyncLane = /*                        */ 1;\n        var InputContinuousHydrationLane = /*    */ 2;\n        var InputContinuousLane = /*            */ 4;\n        var DefaultHydrationLane = /*            */ 8;\n        var DefaultLane = /*                    */ 16;\n        var TransitionHydrationLane = /*                */ 32;\n        var TransitionLanes = /*                       */ 4194240;\n        var TransitionLane1 = /*                        */ 64;\n        var TransitionLane2 = /*                        */ 128;\n        var TransitionLane3 = /*                        */ 256;\n        var TransitionLane4 = /*                        */ 512;\n        var TransitionLane5 = /*                        */ 1024;\n        var TransitionLane6 = /*                        */ 2048;\n        var TransitionLane7 = /*                        */ 4096;\n        var TransitionLane8 = /*                        */ 8192;\n        var TransitionLane9 = /*                        */ 16384;\n        var TransitionLane10 = /*                       */ 32768;\n        var TransitionLane11 = /*                       */ 65536;\n        var TransitionLane12 = /*                       */ 131072;\n        var TransitionLane13 = /*                       */ 262144;\n        var TransitionLane14 = /*                       */ 524288;\n        var TransitionLane15 = /*                       */ 1048576;\n        var TransitionLane16 = /*                       */ 2097152;\n        var RetryLanes = /*                            */ 130023424;\n        var RetryLane1 = /*                             */ 4194304;\n        var RetryLane2 = /*                             */ 8388608;\n        var RetryLane3 = /*                             */ 16777216;\n        var RetryLane4 = /*                             */ 33554432;\n        var RetryLane5 = /*                             */ 67108864;\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = /*          */ 134217728;\n        var NonIdleLanes = /*                                 */ 268435455;\n        var IdleHydrationLane = /*               */ 268435456;\n        var IdleLane = /*                       */ 536870912;\n        var OffscreenLane = /*                   */ 1073741824; // This function is used for the experimental timeline (react-devtools-timeline)\n        // It should be kept in sync with the Lanes values above.\n        function getLabelForLane(lane) {\n            {\n                if (lane & SyncLane) {\n                    return \"Sync\";\n                }\n                if (lane & InputContinuousHydrationLane) {\n                    return \"InputContinuousHydration\";\n                }\n                if (lane & InputContinuousLane) {\n                    return \"InputContinuous\";\n                }\n                if (lane & DefaultHydrationLane) {\n                    return \"DefaultHydration\";\n                }\n                if (lane & DefaultLane) {\n                    return \"Default\";\n                }\n                if (lane & TransitionHydrationLane) {\n                    return \"TransitionHydration\";\n                }\n                if (lane & TransitionLanes) {\n                    return \"Transition\";\n                }\n                if (lane & RetryLanes) {\n                    return \"Retry\";\n                }\n                if (lane & SelectiveHydrationLane) {\n                    return \"SelectiveHydration\";\n                }\n                if (lane & IdleHydrationLane) {\n                    return \"IdleHydration\";\n                }\n                if (lane & IdleLane) {\n                    return \"Idle\";\n                }\n                if (lane & OffscreenLane) {\n                    return \"Offscreen\";\n                }\n            }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n            switch(getHighestPriorityLane(lanes)){\n                case SyncLane:\n                    return SyncLane;\n                case InputContinuousHydrationLane:\n                    return InputContinuousHydrationLane;\n                case InputContinuousLane:\n                    return InputContinuousLane;\n                case DefaultHydrationLane:\n                    return DefaultHydrationLane;\n                case DefaultLane:\n                    return DefaultLane;\n                case TransitionHydrationLane:\n                    return TransitionHydrationLane;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                    return lanes & TransitionLanes;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    return lanes & RetryLanes;\n                case SelectiveHydrationLane:\n                    return SelectiveHydrationLane;\n                case IdleHydrationLane:\n                    return IdleHydrationLane;\n                case IdleLane:\n                    return IdleLane;\n                case OffscreenLane:\n                    return OffscreenLane;\n                default:\n                    {\n                        error(\"Should have found matching lanes. This is a bug in React.\");\n                    }\n                    return lanes;\n            }\n        }\n        function getNextLanes(root, wipLanes) {\n            // Early bailout if there's no pending work left.\n            var pendingLanes = root.pendingLanes;\n            if (pendingLanes === NoLanes) {\n                return NoLanes;\n            }\n            var nextLanes = NoLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n            // even if the work is suspended.\n            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n            if (nonIdlePendingLanes !== NoLanes) {\n                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n                if (nonIdleUnblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n                } else {\n                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n                    if (nonIdlePingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n                    }\n                }\n            } else {\n                // The only remaining work is Idle.\n                var unblockedLanes = pendingLanes & ~suspendedLanes;\n                if (unblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(unblockedLanes);\n                } else {\n                    if (pingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(pingedLanes);\n                    }\n                }\n            }\n            if (nextLanes === NoLanes) {\n                // This should only be reachable if we're suspended\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\n                return NoLanes;\n            } // If we're already in the middle of a render, switching lanes will interrupt\n            // it and we'll lose our progress. We should only do this if the new lanes are\n            // higher priority.\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n            // bother waiting until the root is complete.\n            (wipLanes & suspendedLanes) === NoLanes) {\n                var nextLane = getHighestPriorityLane(nextLanes);\n                var wipLane = getHighestPriorityLane(wipLanes);\n                if (// one. This works because the bits decrease in priority as you go left.\n                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n                // only difference between default updates and transition updates is that\n                // default updates do not support refresh transitions.\n                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n                    // Keep working on the existing in-progress tree. Do not interrupt.\n                    return wipLanes;\n                }\n            }\n            if ((nextLanes & InputContinuousLane) !== NoLanes) {\n                // When updates are sync by default, we entangle continuous priority updates\n                // and default updates, so they render in the same batch. The only reason\n                // they use separate lanes is because continuous updates should interrupt\n                // transitions, but default updates should not.\n                nextLanes |= pendingLanes & DefaultLane;\n            } // Check for entangled lanes and add them to the batch.\n            //\n            // A lane is said to be entangled with another when it's not allowed to render\n            // in a batch that does not also include the other lane. Typically we do this\n            // when multiple updates have the same source, and we only want to respond to\n            // the most recent event from that source.\n            //\n            // Note that we apply entanglements *after* checking for partial work above.\n            // This means that if a lane is entangled during an interleaved event while\n            // it's already rendering, we won't interrupt it. This is intentional, since\n            // entanglement is usually \"best effort\": we'll try our best to render the\n            // lanes in the same batch, but it's not worth throwing out partially\n            // completed work in order to do it.\n            // TODO: Reconsider this. The counter-argument is that the partial work\n            // represents an intermediate state, which we don't want to show to the user.\n            // And by spending extra time finishing it, we're increasing the amount of\n            // time it takes to show the final state, which is what they are actually\n            // waiting for.\n            //\n            // For those exceptions where entanglement is semantically important, like\n            // useMutableSource, we should ensure that there is no partial work at the\n            // time we apply the entanglement.\n            var entangledLanes = root.entangledLanes;\n            if (entangledLanes !== NoLanes) {\n                var entanglements = root.entanglements;\n                var lanes = nextLanes & entangledLanes;\n                while(lanes > 0){\n                    var index = pickArbitraryLaneIndex(lanes);\n                    var lane = 1 << index;\n                    nextLanes |= entanglements[index];\n                    lanes &= ~lane;\n                }\n            }\n            return nextLanes;\n        }\n        function getMostRecentEventTime(root, lanes) {\n            var eventTimes = root.eventTimes;\n            var mostRecentEventTime = NoTimestamp;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var eventTime = eventTimes[index];\n                if (eventTime > mostRecentEventTime) {\n                    mostRecentEventTime = eventTime;\n                }\n                lanes &= ~lane;\n            }\n            return mostRecentEventTime;\n        }\n        function computeExpirationTime(lane, currentTime) {\n            switch(lane){\n                case SyncLane:\n                case InputContinuousHydrationLane:\n                case InputContinuousLane:\n                    // User interactions should expire slightly more quickly.\n                    //\n                    // NOTE: This is set to the corresponding constant as in Scheduler.js.\n                    // When we made it larger, a product metric in www regressed, suggesting\n                    // there's a user interaction that's being starved by a series of\n                    // synchronous updates. If that theory is correct, the proper solution is\n                    // to fix the starvation. However, this scenario supports the idea that\n                    // expiration times are an important safeguard when starvation\n                    // does happen.\n                    return currentTime + 250;\n                case DefaultHydrationLane:\n                case DefaultLane:\n                case TransitionHydrationLane:\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                    return currentTime + 5000;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    // TODO: Retries should be allowed to expire if they are CPU bound for\n                    // too long, but when I made this change it caused a spike in browser\n                    // crashes. There must be some other underlying bug; not super urgent but\n                    // ideally should figure out why and fix it. Unfortunately we don't have\n                    // a repro for the crashes, only detected via production metrics.\n                    return NoTimestamp;\n                case SelectiveHydrationLane:\n                case IdleHydrationLane:\n                case IdleLane:\n                case OffscreenLane:\n                    // Anything idle priority or lower should never expire.\n                    return NoTimestamp;\n                default:\n                    {\n                        error(\"Should have found matching lanes. This is a bug in React.\");\n                    }\n                    return NoTimestamp;\n            }\n        }\n        function markStarvedLanesAsExpired(root, currentTime) {\n            // TODO: This gets called every time we yield. We can optimize by storing\n            // the earliest expiration time on the root. Then use that to quickly bail out\n            // of this function.\n            var pendingLanes = root.pendingLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes;\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n            // expiration time. If so, we'll assume the update is being starved and mark\n            // it as expired to force it to finish.\n            var lanes = pendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var expirationTime = expirationTimes[index];\n                if (expirationTime === NoTimestamp) {\n                    // Found a pending lane with no expiration time. If it's not suspended, or\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n                    // using the current time.\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                        // Assumes timestamps are monotonically increasing.\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n                    }\n                } else if (expirationTime <= currentTime) {\n                    // This lane expired\n                    root.expiredLanes |= lane;\n                }\n                lanes &= ~lane;\n            }\n        } // This returns the highest priority pending lanes regardless of whether they\n        // are suspended.\n        function getHighestPriorityPendingLanes(root) {\n            return getHighestPriorityLanes(root.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root) {\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n            if (everythingButOffscreen !== NoLanes) {\n                return everythingButOffscreen;\n            }\n            if (everythingButOffscreen & OffscreenLane) {\n                return OffscreenLane;\n            }\n            return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n            return (lanes & SyncLane) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n            return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n            return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyTransitions(lanes) {\n            return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root, lanes) {\n            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n            return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root, lanes) {\n            // This is a separate check from includesBlockingLane because a lane can\n            // expire after a render has already started.\n            return (lanes & root.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n            return (lane & TransitionLanes) !== 0;\n        }\n        function claimNextTransitionLane() {\n            // Cycle through the lanes, assigning each new transition to the next lane.\n            // In most cases, this means every transition gets its own lane, until we\n            // run out of lanes and cycle back to the beginning.\n            var lane = nextTransitionLane;\n            nextTransitionLane <<= 1;\n            if ((nextTransitionLane & TransitionLanes) === 0) {\n                nextTransitionLane = TransitionLane1;\n            }\n            return lane;\n        }\n        function claimNextRetryLane() {\n            var lane = nextRetryLane;\n            nextRetryLane <<= 1;\n            if ((nextRetryLane & RetryLanes) === 0) {\n                nextRetryLane = RetryLane1;\n            }\n            return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n            return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n            // This wrapper function gets inlined. Only exists so to communicate that it\n            // doesn't matter which bit is selected; you can pick any bit without\n            // affecting the algorithms where its used. Here I'm using\n            // getHighestPriorityLane because it requires the fewest operations.\n            return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n            return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n            return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n            return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set, subset) {\n            return (set & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n            return a | b;\n        }\n        function removeLanes(set, subset) {\n            return set & ~subset;\n        }\n        function intersectLanes(a, b) {\n            return a & b;\n        } // Seems redundant, but it changes the type from a single lane (used for\n        // updates) to a group of lanes (used for flushing work).\n        function laneToLanes(lane) {\n            return lane;\n        }\n        function higherPriorityLane(a, b) {\n            // This works because the bit ranges decrease in priority as you go left.\n            return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n            // Intentionally pushing one by one.\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n            var laneMap = [];\n            for(var i = 0; i < TotalLanes; i++){\n                laneMap.push(initial);\n            }\n            return laneMap;\n        }\n        function markRootUpdated(root, updateLane, eventTime) {\n            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n            // could unblock them. Clear the suspended lanes so that we can try rendering\n            // them again.\n            //\n            // TODO: We really only need to unsuspend only lanes that are in the\n            // `subtreeLanes` of the updated fiber, or the update lanes of the return\n            // path. This would exclude suspended updates in an unrelated sibling tree,\n            // since there's no way for this update to unblock it.\n            //\n            // We don't do this if the incoming update is idle, because we never process\n            // idle updates until after all the regular updates have finished; there's no\n            // way it could unblock a transition.\n            if (updateLane !== IdleLane) {\n                root.suspendedLanes = NoLanes;\n                root.pingedLanes = NoLanes;\n            }\n            var eventTimes = root.eventTimes;\n            var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n            // recent event, and we assume time is monotonically increasing.\n            eventTimes[index] = eventTime;\n        }\n        function markRootSuspended(root, suspendedLanes) {\n            root.suspendedLanes |= suspendedLanes;\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n            var expirationTimes = root.expirationTimes;\n            var lanes = suspendedLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n        }\n        function markRootPinged(root, pingedLanes, eventTime) {\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root, remainingLanes) {\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n            root.pendingLanes = remainingLanes; // Let's try everything again\n            root.suspendedLanes = 0;\n            root.pingedLanes = 0;\n            root.expiredLanes &= remainingLanes;\n            root.mutableReadLanes &= remainingLanes;\n            root.entangledLanes &= remainingLanes;\n            var entanglements = root.entanglements;\n            var eventTimes = root.eventTimes;\n            var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n            var lanes = noLongerPendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                entanglements[index] = NoLanes;\n                eventTimes[index] = NoTimestamp;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n        }\n        function markRootEntangled(root, entangledLanes) {\n            // In addition to entangling each of the given lanes with each other, we also\n            // have to consider _transitive_ entanglements. For each lane that is already\n            // entangled with *any* of the given lanes, that lane is now transitively\n            // entangled with *all* the given lanes.\n            //\n            // Translated: If C is entangled with A, then entangling A with B also\n            // entangles C with B.\n            //\n            // If this is hard to grasp, it might help to intentionally break this\n            // function and look at the tests that fail in ReactTransition-test.js. Try\n            // commenting out one of the conditions below.\n            var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n            var entanglements = root.entanglements;\n            var lanes = rootEntangledLanes;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n                entanglements[index] & entangledLanes) {\n                    entanglements[index] |= entangledLanes;\n                }\n                lanes &= ~lane;\n            }\n        }\n        function getBumpedLaneForHydration(root, renderLanes) {\n            var renderLane = getHighestPriorityLane(renderLanes);\n            var lane;\n            switch(renderLane){\n                case InputContinuousLane:\n                    lane = InputContinuousHydrationLane;\n                    break;\n                case DefaultLane:\n                    lane = DefaultHydrationLane;\n                    break;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                case TransitionLane16:\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                case RetryLane5:\n                    lane = TransitionHydrationLane;\n                    break;\n                case IdleLane:\n                    lane = IdleHydrationLane;\n                    break;\n                default:\n                    // Everything else is already either a hydration lane, or shouldn't\n                    // be retried at a hydration lane.\n                    lane = NoLane;\n                    break;\n            } // Check if the lane we chose is suspended. If so, that indicates that we\n            // already attempted and failed to hydrate at that level. Also check if we're\n            // already rendering that lane, which is rare but could happen.\n            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n                // Give up trying to hydrate and fall back to client render.\n                return NoLane;\n            }\n            return lane;\n        }\n        function addFiberToLanesMap(root, fiber, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                updaters.add(fiber);\n                lanes &= ~lane;\n            }\n        }\n        function movePendingFibersToMemoized(root, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            var memoizedUpdaters = root.memoizedUpdaters;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                if (updaters.size > 0) {\n                    updaters.forEach(function(fiber) {\n                        var alternate = fiber.alternate;\n                        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                            memoizedUpdaters.add(fiber);\n                        }\n                    });\n                    updaters.clear();\n                }\n                lanes &= ~lane;\n            }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var currentUpdatePriority = NoLane;\n        function getCurrentUpdatePriority() {\n            return currentUpdatePriority;\n        }\n        function setCurrentUpdatePriority(newPriority) {\n            currentUpdatePriority = newPriority;\n        }\n        function runWithPriority(priority, fn) {\n            var previousPriority = currentUpdatePriority;\n            try {\n                currentUpdatePriority = priority;\n                return fn();\n            } finally{\n                currentUpdatePriority = previousPriority;\n            }\n        }\n        function higherEventPriority(a, b) {\n            return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n            return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n            return a !== 0 && a < b;\n        }\n        function lanesToEventPriority(lanes) {\n            var lane = getHighestPriorityLane(lanes);\n            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n                return DiscreteEventPriority;\n            }\n            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n                return ContinuousEventPriority;\n            }\n            if (includesNonIdleWork(lane)) {\n                return DefaultEventPriority;\n            }\n            return IdleEventPriority;\n        }\n        // This module only exists as an ESM wrapper around the external CommonJS\n        var scheduleCallback = Scheduler.unstable_scheduleCallback;\n        var cancelCallback = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now$1 = Scheduler.unstable_now;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority = Scheduler.unstable_NormalPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority;\n        // this doesn't actually exist on the scheduler, but it *does*\n        // on scheduler/unstable_mock, which we'll need for internal testing\n        var unstable_yieldValue = Scheduler.unstable_yieldValue;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n        function injectInternals(internals) {\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n                // No DevTools\n                return false;\n            }\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n            if (hook.isDisabled) {\n                // This isn't a real property on the hook, but it can be set to opt out\n                // of DevTools integration and associated warnings and logs.\n                // https://github.com/facebook/react/issues/3877\n                return true;\n            }\n            if (!hook.supportsFiber) {\n                {\n                    error(\"The installed version of React DevTools is too old and will not work \" + \"with the current version of React. Please update React DevTools. \" + \"https://reactjs.org/link/react-devtools\");\n                }\n                return true;\n            }\n            try {\n                if (enableSchedulingProfiler) {\n                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n                    // This gives DevTools a way to feature detect that isn't tied to version number\n                    // (since profiling and timeline are controlled by different feature flags).\n                    internals = assign({}, internals, {\n                        getLaneLabelMap: getLaneLabelMap,\n                        injectProfilingHooks: injectProfilingHooks\n                    });\n                }\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n                injectedHook = hook;\n            } catch (err) {\n                // Catch all errors because it is unsafe to throw during initialization.\n                {\n                    error(\"React instrumentation encountered an error: %s.\", err);\n                }\n            }\n            if (hook.checkDCE) {\n                // This is the real DevTools.\n                return true;\n            } else {\n                // This is likely a hook installed by Fast Refresh runtime.\n                return false;\n            }\n        }\n        function onScheduleRoot(root, children) {\n            {\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === \"function\") {\n                    try {\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n                    } catch (err) {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitRoot(root, eventPriority) {\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === \"function\") {\n                try {\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\n                    if (enableProfilerTimer) {\n                        var schedulerPriority;\n                        switch(eventPriority){\n                            case DiscreteEventPriority:\n                                schedulerPriority = ImmediatePriority;\n                                break;\n                            case ContinuousEventPriority:\n                                schedulerPriority = UserBlockingPriority;\n                                break;\n                            case DefaultEventPriority:\n                                schedulerPriority = NormalPriority;\n                                break;\n                            case IdleEventPriority:\n                                schedulerPriority = IdlePriority;\n                                break;\n                            default:\n                                schedulerPriority = NormalPriority;\n                                break;\n                        }\n                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n                    } else {\n                        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);\n                    }\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onPostCommitRoot(root) {\n            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === \"function\") {\n                try {\n                    injectedHook.onPostCommitFiberRoot(rendererID, root);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitUnmount(fiber) {\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === \"function\") {\n                try {\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error(\"React instrumentation encountered an error: %s\", err);\n                        }\n                    }\n                }\n            }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n            {\n                if (typeof unstable_yieldValue === \"function\") {\n                    // We're in a test because Scheduler.unstable_yieldValue only exists\n                    // in SchedulerMock. To reduce the noise in strict mode tests,\n                    // suppress warnings and disable scheduler yielding during the double render\n                    unstable_setDisableYieldValue(newIsStrictMode);\n                    setSuppressWarning(newIsStrictMode);\n                }\n                if (injectedHook && typeof injectedHook.setStrictMode === \"function\") {\n                    try {\n                        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n                    } catch (err) {\n                        {\n                            if (!hasLoggedError) {\n                                hasLoggedError = true;\n                                error(\"React instrumentation encountered an error: %s\", err);\n                            }\n                        }\n                    }\n                }\n            }\n        } // Profiler API hooks\n        function injectProfilingHooks(profilingHooks) {\n            injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n            {\n                var map = new Map();\n                var lane = 1;\n                for(var index = 0; index < TotalLanes; index++){\n                    var label = getLabelForLane(lane);\n                    map.set(lane, label);\n                    lane *= 2;\n                }\n                return map;\n            }\n        }\n        function markCommitStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === \"function\") {\n                    injectedProfilingHooks.markCommitStarted(lanes);\n                }\n            }\n        }\n        function markCommitStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === \"function\") {\n                    injectedProfilingHooks.markCommitStopped();\n                }\n            }\n        }\n        function markComponentRenderStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === \"function\") {\n                    injectedProfilingHooks.markComponentRenderStarted(fiber);\n                }\n            }\n        }\n        function markComponentRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === \"function\") {\n                    injectedProfilingHooks.markComponentRenderStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === \"function\") {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === \"function\") {\n                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n                }\n            }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === \"function\") {\n                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === \"function\") {\n                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === \"function\") {\n                    injectedProfilingHooks.markLayoutEffectsStopped();\n                }\n            }\n        }\n        function markPassiveEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === \"function\") {\n                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                }\n            }\n        }\n        function markPassiveEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === \"function\") {\n                    injectedProfilingHooks.markPassiveEffectsStopped();\n                }\n            }\n        }\n        function markRenderStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === \"function\") {\n                    injectedProfilingHooks.markRenderStarted(lanes);\n                }\n            }\n        }\n        function markRenderYielded() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === \"function\") {\n                    injectedProfilingHooks.markRenderYielded();\n                }\n            }\n        }\n        function markRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === \"function\") {\n                    injectedProfilingHooks.markRenderStopped();\n                }\n            }\n        }\n        function markRenderScheduled(lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === \"function\") {\n                    injectedProfilingHooks.markRenderScheduled(lane);\n                }\n            }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === \"function\") {\n                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === \"function\") {\n                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        var syncQueue = null;\n        var includesLegacySyncCallbacks = false;\n        var isFlushingSyncQueue = false;\n        function scheduleSyncCallback(callback) {\n            // Push this callback into an internal queue. We'll flush these either in\n            // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n            if (syncQueue === null) {\n                syncQueue = [\n                    callback\n                ];\n            } else {\n                // Push onto existing queue. Don't need to schedule a callback because\n                // we already scheduled one when we created the queue.\n                syncQueue.push(callback);\n            }\n        }\n        function scheduleLegacySyncCallback(callback) {\n            includesLegacySyncCallbacks = true;\n            scheduleSyncCallback(callback);\n        }\n        function flushSyncCallbacksOnlyInLegacyMode() {\n            // Only flushes the queue if there's a legacy sync callback scheduled.\n            // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n            // it might make more sense for the queue to be a list of roots instead of a\n            // list of generic callbacks. Then we can have two: one for legacy roots, one\n            // for concurrent roots. And this method would only flush the legacy ones.\n            if (includesLegacySyncCallbacks) {\n                flushSyncCallbacks();\n            }\n        }\n        function flushSyncCallbacks() {\n            if (!isFlushingSyncQueue && syncQueue !== null) {\n                // Prevent re-entrance.\n                isFlushingSyncQueue = true;\n                var i = 0;\n                var previousUpdatePriority = getCurrentUpdatePriority();\n                try {\n                    var isSync = true;\n                    var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n                    // queue is in the render or commit phases.\n                    setCurrentUpdatePriority(DiscreteEventPriority);\n                    for(; i < queue.length; i++){\n                        var callback = queue[i];\n                        do {\n                            callback = callback(isSync);\n                        }while (callback !== null);\n                    }\n                    syncQueue = null;\n                    includesLegacySyncCallbacks = false;\n                } catch (error) {\n                    // If something throws, leave the remaining callbacks on the queue.\n                    if (syncQueue !== null) {\n                        syncQueue = syncQueue.slice(i + 1);\n                    } // Resume flushing in the next tick\n                    scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n                    throw error;\n                } finally{\n                    setCurrentUpdatePriority(previousUpdatePriority);\n                    isFlushingSyncQueue = false;\n                }\n            }\n            return null;\n        }\n        // This is imported by the event replaying implementation in React DOM. It's\n        // in a separate file to break a circular dependency between the renderer and\n        // the reconciler.\n        function isRootDehydrated(root) {\n            var currentState = root.current.memoizedState;\n            return currentState.isDehydrated;\n        }\n        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\n        var NoTransition = null;\n        function requestCurrentTransition() {\n            return ReactCurrentBatchConfig.transition;\n        }\n        /**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n            if (objectIs(objA, objB)) {\n                return true;\n            }\n            if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n                return false;\n            }\n            var keysA = Object.keys(objA);\n            var keysB = Object.keys(objB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            } // Test for A's keys different from B.\n            for(var i = 0; i < keysA.length; i++){\n                var currentKey = keysA[i];\n                if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function describeFiber(fiber) {\n            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\n            var source = fiber._debugSource;\n            switch(fiber.tag){\n                case HostComponent:\n                    return describeBuiltInComponentFrame(fiber.type);\n                case LazyComponent:\n                    return describeBuiltInComponentFrame(\"Lazy\");\n                case SuspenseComponent:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case SuspenseListComponent:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n                case FunctionComponent:\n                case IndeterminateComponent:\n                case SimpleMemoComponent:\n                    return describeFunctionComponentFrame(fiber.type);\n                case ForwardRef:\n                    return describeFunctionComponentFrame(fiber.type.render);\n                case ClassComponent:\n                    return describeClassComponentFrame(fiber.type);\n                default:\n                    return \"\";\n            }\n        }\n        function getStackByFiberInDevAndProd(workInProgress) {\n            try {\n                var info = \"\";\n                var node = workInProgress;\n                do {\n                    info += describeFiber(node);\n                    node = node.return;\n                }while (node);\n                return info;\n            } catch (x) {\n                return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n            }\n        }\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberOwnerNameInDevOrNull() {\n            {\n                if (current === null) {\n                    return null;\n                }\n                var owner = current._debugOwner;\n                if (owner !== null && typeof owner !== \"undefined\") {\n                    return getComponentNameFromFiber(owner);\n                }\n            }\n            return null;\n        }\n        function getCurrentFiberStackInDev() {\n            {\n                if (current === null) {\n                    return \"\";\n                } // Safe because if current fiber exists, we are reconciling,\n                // and it is guaranteed to be the work-in-progress version.\n                return getStackByFiberInDevAndProd(current);\n            }\n        }\n        function resetCurrentFiber() {\n            {\n                ReactDebugCurrentFrame$1.getCurrentStack = null;\n                current = null;\n                isRendering = false;\n            }\n        }\n        function setCurrentFiber(fiber) {\n            {\n                ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;\n                current = fiber;\n                isRendering = false;\n            }\n        }\n        function setIsRendering(rendering) {\n            {\n                isRendering = rendering;\n            }\n        }\n        var ReactStrictModeWarnings = {\n            recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n            flushPendingUnsafeLifecycleWarnings: function() {},\n            recordLegacyContextWarning: function(fiber, instance) {},\n            flushLegacyContextWarning: function() {},\n            discardPendingWarnings: function() {}\n        };\n        {\n            var findStrictRoot = function(fiber) {\n                var maybeStrictRoot = null;\n                var node = fiber;\n                while(node !== null){\n                    if (node.mode & StrictLegacyMode) {\n                        maybeStrictRoot = node;\n                    }\n                    node = node.return;\n                }\n                return maybeStrictRoot;\n            };\n            var setToSortedString = function(set) {\n                var array = [];\n                set.forEach(function(value) {\n                    array.push(value);\n                });\n                return array.sort().join(\", \");\n            };\n            var pendingComponentWillMountWarnings = [];\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\n            var pendingComponentWillReceivePropsWarnings = [];\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            var pendingComponentWillUpdateWarnings = [];\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n            var didWarnAboutUnsafeLifecycles = new Set();\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n                // Dedupe strategy: Warn once per component.\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n                    return;\n                }\n                if (typeof instance.componentWillMount === \"function\" && // Don't warn about react-lifecycles-compat polyfilled components.\n                instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillMountWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === \"function\") {\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillUpdateWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n                // We do an initial pass to gather component names\n                var componentWillMountUniqueNames = new Set();\n                if (pendingComponentWillMountWarnings.length > 0) {\n                    pendingComponentWillMountWarnings.forEach(function(fiber) {\n                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillMountWarnings = [];\n                }\n                var UNSAFE_componentWillMountUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\n                }\n                var componentWillReceivePropsUniqueNames = new Set();\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\n                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillReceivePropsWarnings = [];\n                }\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                }\n                var componentWillUpdateUniqueNames = new Set();\n                if (pendingComponentWillUpdateWarnings.length > 0) {\n                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillUpdateWarnings = [];\n                }\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                } // Finally, we flush all the warnings\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n                    error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\" + \"\\nPlease update the following components: %s\", sortedNames);\n                }\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n                    error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* If you're updating state whenever props change, \" + \"refactor your code to use memoization techniques or move it to \" + \"static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\" + \"\\nPlease update the following components: %s\", _sortedNames);\n                }\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n                    error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended \" + \"and may indicate bugs in your code. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames2);\n                }\n                if (componentWillMountUniqueNames.size > 0) {\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n                    warn(\"componentWillMount has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\" + \"* Rename componentWillMount to UNSAFE_componentWillMount to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames3);\n                }\n                if (componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n                    warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* If you're updating state whenever props change, refactor your \" + \"code to use memoization techniques or move it to \" + \"static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\" + \"* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames4);\n                }\n                if (componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n                    warn(\"componentWillUpdate has been renamed, and is not recommended for use. \" + \"See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n\" + \"* Move data fetching code or side effects to componentDidUpdate.\\n\" + \"* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress \" + \"this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. \" + \"To rename all deprecated lifecycles to their new names, you can run \" + \"`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\" + \"\\nPlease update the following components: %s\", _sortedNames5);\n                }\n            };\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n            var didWarnAboutLegacyContext = new Set();\n            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n                var strictRoot = findStrictRoot(fiber);\n                if (strictRoot === null) {\n                    error(\"Expected to find a StrictMode component in a strict mode tree. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                    return;\n                } // Dedup strategy: Warn once per component.\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\n                    return;\n                }\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \"function\") {\n                    if (warningsForRoot === undefined) {\n                        warningsForRoot = [];\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n                    }\n                    warningsForRoot.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n                    if (fiberArray.length === 0) {\n                        return;\n                    }\n                    var firstFiber = fiberArray[0];\n                    var uniqueNames = new Set();\n                    fiberArray.forEach(function(fiber) {\n                        uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                        didWarnAboutLegacyContext.add(fiber.type);\n                    });\n                    var sortedNames = setToSortedString(uniqueNames);\n                    try {\n                        setCurrentFiber(firstFiber);\n                        error(\"Legacy context API has been detected within a strict-mode tree.\" + \"\\n\\nThe old API will be supported in all 16.x releases, but applications \" + \"using it should migrate to the new version.\" + \"\\n\\nPlease update the following components: %s\" + \"\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context\", sortedNames);\n                    } finally{\n                        resetCurrentFiber();\n                    }\n                });\n            };\n            ReactStrictModeWarnings.discardPendingWarnings = function() {\n                pendingComponentWillMountWarnings = [];\n                pendingUNSAFE_ComponentWillMountWarnings = [];\n                pendingComponentWillReceivePropsWarnings = [];\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                pendingComponentWillUpdateWarnings = [];\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                pendingLegacyContextWarning = new Map();\n            };\n        }\n        /*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n                return type;\n            }\n        } // $FlowFixMe only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function checkPropStringCoercion(value, propName) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided `%s` prop is an unsupported type %s.\" + \" This value must be coerced to a string before before using it here.\", propName, typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n            if (Component && Component.defaultProps) {\n                // Resolve default props. Taken from ReactElement\n                var props = assign({}, baseProps);\n                var defaultProps = Component.defaultProps;\n                for(var propName in defaultProps){\n                    if (props[propName] === undefined) {\n                        props[propName] = defaultProps[propName];\n                    }\n                }\n                return props;\n            }\n            return baseProps;\n        }\n        var valueCursor = createCursor(null);\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n            // This is called right before React yields execution, to ensure `readContext`\n            // cannot be called outside the render phase.\n            currentlyRenderingFiber = null;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function enterDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = true;\n            }\n        }\n        function exitDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n            if (isPrimaryRenderer) {\n                push(valueCursor, context._currentValue, providerFiber);\n                context._currentValue = nextValue;\n                {\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            } else {\n                push(valueCursor, context._currentValue2, providerFiber);\n                context._currentValue2 = nextValue;\n                {\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error(\"Detected multiple renderers concurrently rendering the \" + \"same context provider. This is currently unsupported.\");\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n        }\n        function popProvider(context, providerFiber) {\n            var currentValue = valueCursor.current;\n            pop(valueCursor, providerFiber);\n            if (isPrimaryRenderer) {\n                {\n                    context._currentValue = currentValue;\n                }\n            } else {\n                {\n                    context._currentValue2 = currentValue;\n                }\n            }\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n            // Update the child lanes of all the ancestors, including the alternates.\n            var node = parent;\n            while(node !== null){\n                var alternate = node.alternate;\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\n                    if (alternate !== null) {\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                    }\n                } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                }\n                if (node === propagationRoot) {\n                    break;\n                }\n                node = node.return;\n            }\n            {\n                if (node !== propagationRoot) {\n                    error(\"Expected to find the propagation root when scheduling context work. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        function propagateContextChange(workInProgress, context, renderLanes) {\n            {\n                propagateContextChange_eager(workInProgress, context, renderLanes);\n            }\n        }\n        function propagateContextChange_eager(workInProgress, context, renderLanes) {\n            var fiber = workInProgress.child;\n            if (fiber !== null) {\n                // Set the return pointer of the child to the work-in-progress fiber.\n                fiber.return = workInProgress;\n            }\n            while(fiber !== null){\n                var nextFiber = void 0; // Visit this fiber.\n                var list = fiber.dependencies;\n                if (list !== null) {\n                    nextFiber = fiber.child;\n                    var dependency = list.firstContext;\n                    while(dependency !== null){\n                        // Check if the context matches.\n                        if (dependency.context === context) {\n                            // Match! Schedule an update on this fiber.\n                            if (fiber.tag === ClassComponent) {\n                                // Schedule a force update on the work-in-progress.\n                                var lane = pickArbitraryLane(renderLanes);\n                                var update = createUpdate(NoTimestamp, lane);\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n                                // update to the current fiber, too, which means it will persist even if\n                                // this render is thrown away. Since it's a race condition, not sure it's\n                                // worth fixing.\n                                // Inlined `enqueueUpdate` to remove interleaved update check\n                                var updateQueue = fiber.updateQueue;\n                                if (updateQueue === null) ;\n                                else {\n                                    var sharedQueue = updateQueue.shared;\n                                    var pending = sharedQueue.pending;\n                                    if (pending === null) {\n                                        // This is the first update. Create a circular list.\n                                        update.next = update;\n                                    } else {\n                                        update.next = pending.next;\n                                        pending.next = update;\n                                    }\n                                    sharedQueue.pending = update;\n                                }\n                            }\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n                            var alternate = fiber.alternate;\n                            if (alternate !== null) {\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n                            }\n                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n                            break;\n                        }\n                        dependency = dependency.next;\n                    }\n                } else if (fiber.tag === ContextProvider) {\n                    // Don't scan deeper if this is a matching provider\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n                } else if (fiber.tag === DehydratedFragment) {\n                    // If a dehydrated suspense boundary is in this subtree, we don't know\n                    // if it will have any context consumers in it. The best we can do is\n                    // mark it as having updates.\n                    var parentSuspense = fiber.return;\n                    if (parentSuspense === null) {\n                        throw new Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                    }\n                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n                    var _alternate = parentSuspense.alternate;\n                    if (_alternate !== null) {\n                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n                    } // This is intentionally passing this fiber as the parent\n                    // because we want to schedule this fiber as having work\n                    // on its children. We'll use the childLanes on\n                    // this fiber to indicate that a context has changed.\n                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n                    nextFiber = fiber.sibling;\n                } else {\n                    // Traverse down.\n                    nextFiber = fiber.child;\n                }\n                if (nextFiber !== null) {\n                    // Set the return pointer of the child to the work-in-progress fiber.\n                    nextFiber.return = fiber;\n                } else {\n                    // No child. Traverse to next sibling.\n                    nextFiber = fiber;\n                    while(nextFiber !== null){\n                        if (nextFiber === workInProgress) {\n                            // We're back to the root of this subtree. Exit.\n                            nextFiber = null;\n                            break;\n                        }\n                        var sibling = nextFiber.sibling;\n                        if (sibling !== null) {\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\n                            sibling.return = nextFiber.return;\n                            nextFiber = sibling;\n                            break;\n                        } // No more siblings. Traverse up.\n                        nextFiber = nextFiber.return;\n                    }\n                }\n                fiber = nextFiber;\n            }\n        }\n        function prepareToReadContext(workInProgress, renderLanes) {\n            currentlyRenderingFiber = workInProgress;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            var dependencies = workInProgress.dependencies;\n            if (dependencies !== null) {\n                {\n                    var firstContext = dependencies.firstContext;\n                    if (firstContext !== null) {\n                        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n                            // Context list has a pending update. Mark that this fiber performed work.\n                            markWorkInProgressReceivedUpdate();\n                        } // Reset the work-in-progress list\n                        dependencies.firstContext = null;\n                    }\n                }\n            }\n        }\n        function readContext(context) {\n            {\n                // This warning would fire if you read context inside a Hook like useMemo.\n                // Unlike the class check below, it's not enforced in production for perf.\n                if (isDisallowedContextReadInDEV) {\n                    error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                }\n            }\n            var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n            if (lastFullyObservedContext === context) ;\n            else {\n                var contextItem = {\n                    context: context,\n                    memoizedValue: value,\n                    next: null\n                };\n                if (lastContextDependency === null) {\n                    if (currentlyRenderingFiber === null) {\n                        throw new Error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n                    } // This is the first dependency for this component. Create a new list.\n                    lastContextDependency = contextItem;\n                    currentlyRenderingFiber.dependencies = {\n                        lanes: NoLanes,\n                        firstContext: contextItem\n                    };\n                } else {\n                    // Append a new context item.\n                    lastContextDependency = lastContextDependency.next = contextItem;\n                }\n            }\n            return value;\n        }\n        // An array of all update queues that received updates during the current\n        // render. When this render exits, either because it finishes or because it is\n        // interrupted, the interleaved updates will be transferred onto the main part\n        // of the queue.\n        var interleavedQueues = null;\n        function pushInterleavedQueue(queue) {\n            if (interleavedQueues === null) {\n                interleavedQueues = [\n                    queue\n                ];\n            } else {\n                interleavedQueues.push(queue);\n            }\n        }\n        function enqueueInterleavedUpdates() {\n            // Transfer the interleaved updates onto the main queue. Each queue has a\n            // `pending` field and an `interleaved` field. When they are not null, they\n            // point to the last node in a circular linked list. We need to append the\n            // interleaved list to the end of the pending list by joining them into a\n            // single, circular list.\n            if (interleavedQueues !== null) {\n                for(var i = 0; i < interleavedQueues.length; i++){\n                    var queue = interleavedQueues[i];\n                    var lastInterleavedUpdate = queue.interleaved;\n                    if (lastInterleavedUpdate !== null) {\n                        queue.interleaved = null;\n                        var firstInterleavedUpdate = lastInterleavedUpdate.next;\n                        var lastPendingUpdate = queue.pending;\n                        if (lastPendingUpdate !== null) {\n                            var firstPendingUpdate = lastPendingUpdate.next;\n                            lastPendingUpdate.next = firstInterleavedUpdate;\n                            lastInterleavedUpdate.next = firstPendingUpdate;\n                        }\n                        queue.pending = lastInterleavedUpdate;\n                    }\n                }\n                interleavedQueues = null;\n            }\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n        // It should only be read right after calling `processUpdateQueue`, via\n        // `checkHasForceUpdateAfterProcessing`.\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n            didWarnUpdateInsideUpdate = false;\n            currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n            var queue = {\n                baseState: fiber.memoizedState,\n                firstBaseUpdate: null,\n                lastBaseUpdate: null,\n                shared: {\n                    pending: null,\n                    interleaved: null,\n                    lanes: NoLanes\n                },\n                effects: null\n            };\n            fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current, workInProgress) {\n            // Clone the update queue from current. Unless it's already a clone.\n            var queue = workInProgress.updateQueue;\n            var currentQueue = current.updateQueue;\n            if (queue === currentQueue) {\n                var clone = {\n                    baseState: currentQueue.baseState,\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\n                    shared: currentQueue.shared,\n                    effects: currentQueue.effects\n                };\n                workInProgress.updateQueue = clone;\n            }\n        }\n        function createUpdate(eventTime, lane) {\n            var update = {\n                eventTime: eventTime,\n                lane: lane,\n                tag: UpdateState,\n                payload: null,\n                callback: null,\n                next: null\n            };\n            return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isInterleavedUpdate(fiber)) {\n                var interleaved = sharedQueue.interleaved;\n                if (interleaved === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update; // At the end of the current render, this queue's interleaved updates will\n                    // be transferred to the pending queue.\n                    pushInterleavedQueue(sharedQueue);\n                } else {\n                    update.next = interleaved.next;\n                    interleaved.next = update;\n                }\n                sharedQueue.interleaved = update;\n            } else {\n                var pending = sharedQueue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                sharedQueue.pending = update;\n            }\n            {\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n                    error(\"An update (setState, replaceState, or forceUpdate) was scheduled \" + \"from inside an update function. Update functions should be pure, \" + \"with zero side-effects. Consider using componentDidUpdate or a \" + \"callback.\");\n                    didWarnUpdateInsideUpdate = true;\n                }\n            }\n        }\n        function entangleTransitions(root, fiber, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isTransitionLane(lane)) {\n                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n                // have finished. We can remove them from the shared queue, which represents\n                // a superset of the actually pending lanes. In some cases we may entangle\n                // more than we need to, but that's OK. In fact it's worse if we *don't*\n                // entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n            // Captured updates are updates that are thrown by a child during the render\n            // phase. They should be discarded if the render is aborted. Therefore,\n            // we should only put them on the work-in-progress queue, not the current one.\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n            var current = workInProgress.alternate;\n            if (current !== null) {\n                var currentQueue = current.updateQueue;\n                if (queue === currentQueue) {\n                    // The work-in-progress queue is the same as current. This happens when\n                    // we bail out on a parent fiber that then captures an error thrown by\n                    // a child. Since we want to append the update only to the work-in\n                    // -progress queue, we need to clone the updates. We usually clone during\n                    // processUpdateQueue, but that didn't happen in this case because we\n                    // skipped over the parent when we bailed out.\n                    var newFirst = null;\n                    var newLast = null;\n                    var firstBaseUpdate = queue.firstBaseUpdate;\n                    if (firstBaseUpdate !== null) {\n                        // Loop through the updates and clone them.\n                        var update = firstBaseUpdate;\n                        do {\n                            var clone = {\n                                eventTime: update.eventTime,\n                                lane: update.lane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                callback: update.callback,\n                                next: null\n                            };\n                            if (newLast === null) {\n                                newFirst = newLast = clone;\n                            } else {\n                                newLast.next = clone;\n                                newLast = clone;\n                            }\n                            update = update.next;\n                        }while (update !== null); // Append the captured update the end of the cloned list.\n                        if (newLast === null) {\n                            newFirst = newLast = capturedUpdate;\n                        } else {\n                            newLast.next = capturedUpdate;\n                            newLast = capturedUpdate;\n                        }\n                    } else {\n                        // There are no base updates.\n                        newFirst = newLast = capturedUpdate;\n                    }\n                    queue = {\n                        baseState: currentQueue.baseState,\n                        firstBaseUpdate: newFirst,\n                        lastBaseUpdate: newLast,\n                        shared: currentQueue.shared,\n                        effects: currentQueue.effects\n                    };\n                    workInProgress.updateQueue = queue;\n                    return;\n                }\n            } // Append the update to the end of the list.\n            var lastBaseUpdate = queue.lastBaseUpdate;\n            if (lastBaseUpdate === null) {\n                queue.firstBaseUpdate = capturedUpdate;\n            } else {\n                lastBaseUpdate.next = capturedUpdate;\n            }\n            queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n            switch(update.tag){\n                case ReplaceState:\n                    {\n                        var payload = update.payload;\n                        if (typeof payload === \"function\") {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            var nextState = payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                            return nextState;\n                        } // State object\n                        return payload;\n                    }\n                case CaptureUpdate:\n                    {\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n                    }\n                // Intentional fallthrough\n                case UpdateState:\n                    {\n                        var _payload = update.payload;\n                        var partialState;\n                        if (typeof _payload === \"function\") {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            partialState = _payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        _payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                        } else {\n                            // Partial state object\n                            partialState = _payload;\n                        }\n                        if (partialState === null || partialState === undefined) {\n                            // Null and undefined are treated as no-ops.\n                            return prevState;\n                        } // Merge the partial state and the previous state.\n                        return assign({}, prevState, partialState);\n                    }\n                case ForceUpdate:\n                    {\n                        hasForceUpdate = true;\n                        return prevState;\n                    }\n            }\n            return prevState;\n        }\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n            // This is always non-null on a ClassComponent or HostRoot\n            var queue = workInProgress.updateQueue;\n            hasForceUpdate = false;\n            {\n                currentlyProcessingQueue = queue.shared;\n            }\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n            var pendingQueue = queue.shared.pending;\n            if (pendingQueue !== null) {\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n                // and last so that it's non-circular.\n                var lastPendingUpdate = pendingQueue;\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = null; // Append pending updates to base queue\n                if (lastBaseUpdate === null) {\n                    firstBaseUpdate = firstPendingUpdate;\n                } else {\n                    lastBaseUpdate.next = firstPendingUpdate;\n                }\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n                // we need to transfer the updates to that queue, too. Because the base\n                // queue is a singly-linked list with no cycles, we can append to both\n                // lists and take advantage of structural sharing.\n                // TODO: Pass `current` as argument\n                var current = workInProgress.alternate;\n                if (current !== null) {\n                    // This is always non-null on a ClassComponent or HostRoot\n                    var currentQueue = current.updateQueue;\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\n                        if (currentLastBaseUpdate === null) {\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\n                        } else {\n                            currentLastBaseUpdate.next = firstPendingUpdate;\n                        }\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\n                    }\n                }\n            } // These values may change as we process the queue.\n            if (firstBaseUpdate !== null) {\n                // Iterate through the list of updates to compute the result.\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n                // from the original lanes.\n                var newLanes = NoLanes;\n                var newBaseState = null;\n                var newFirstBaseUpdate = null;\n                var newLastBaseUpdate = null;\n                var update = firstBaseUpdate;\n                do {\n                    var updateLane = update.lane;\n                    var updateEventTime = update.eventTime;\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            eventTime: updateEventTime,\n                            lane: updateLane,\n                            tag: update.tag,\n                            payload: update.payload,\n                            callback: update.callback,\n                            next: null\n                        };\n                        if (newLastBaseUpdate === null) {\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\n                            newBaseState = newState;\n                        } else {\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                        } // Update the remaining priority in the queue.\n                        newLanes = mergeLanes(newLanes, updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        if (newLastBaseUpdate !== null) {\n                            var _clone = {\n                                eventTime: updateEventTime,\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                callback: update.callback,\n                                next: null\n                            };\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                        } // Process this update.\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n                        var callback = update.callback;\n                        if (callback !== null && // If the update was already committed, we should not queue its\n                        // callback again.\n                        update.lane !== NoLane) {\n                            workInProgress.flags |= Callback;\n                            var effects = queue.effects;\n                            if (effects === null) {\n                                queue.effects = [\n                                    update\n                                ];\n                            } else {\n                                effects.push(update);\n                            }\n                        }\n                    }\n                    update = update.next;\n                    if (update === null) {\n                        pendingQueue = queue.shared.pending;\n                        if (pendingQueue === null) {\n                            break;\n                        } else {\n                            // An update was scheduled from inside a reducer. Add the new\n                            // pending updates to the end of the list and keep processing.\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n                            // unravel them when transferring them to the base queue.\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\n                            _lastPendingUpdate.next = null;\n                            update = _firstPendingUpdate;\n                            queue.lastBaseUpdate = _lastPendingUpdate;\n                            queue.shared.pending = null;\n                        }\n                    }\n                }while (true);\n                if (newLastBaseUpdate === null) {\n                    newBaseState = newState;\n                }\n                queue.baseState = newBaseState;\n                queue.firstBaseUpdate = newFirstBaseUpdate;\n                queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n                // process them during this render, but we do need to track which lanes\n                // are remaining.\n                var lastInterleaved = queue.shared.interleaved;\n                if (lastInterleaved !== null) {\n                    var interleaved = lastInterleaved;\n                    do {\n                        newLanes = mergeLanes(newLanes, interleaved.lane);\n                        interleaved = interleaved.next;\n                    }while (interleaved !== lastInterleaved);\n                } else if (firstBaseUpdate === null) {\n                    // `queue.lanes` is used for entangling transitions. We can set it back to\n                    // zero once the queue is empty.\n                    queue.shared.lanes = NoLanes;\n                } // Set the remaining expiration time to be whatever is remaining in the queue.\n                // This should be fine because the only two other things that contribute to\n                // expiration time are props and context. We're already in the middle of the\n                // begin phase by the time we start processing the queue, so we've already\n                // dealt with the props. Context in components that specify\n                // shouldComponentUpdate is tricky; but we'll have to account for\n                // that regardless.\n                markSkippedUpdateLanes(newLanes);\n                workInProgress.lanes = newLanes;\n                workInProgress.memoizedState = newState;\n            }\n            {\n                currentlyProcessingQueue = null;\n            }\n        }\n        function callCallback(callback, context) {\n            if (typeof callback !== \"function\") {\n                throw new Error(\"Invalid argument passed as callback. Expected a function. Instead \" + (\"received: \" + callback));\n            }\n            callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n            hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n            return hasForceUpdate;\n        }\n        function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n            // Commit the effects\n            var effects = finishedQueue.effects;\n            finishedQueue.effects = null;\n            if (effects !== null) {\n                for(var i = 0; i < effects.length; i++){\n                    var effect = effects[i];\n                    var callback = effect.callback;\n                    if (callback !== null) {\n                        effect.callback = null;\n                        callCallback(callback, instance);\n                    }\n                }\n            }\n        }\n        var fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n        // We'll use it to determine whether we need to initialize legacy refs.\n        var emptyRefsObject = new React.Component().refs;\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var warnOnUndefinedDerivedState;\n        var warnOnInvalidCallback;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        {\n            didWarnAboutStateAssignmentForComponent = new Set();\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutContextTypeAndContextTypes = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            var didWarnOnInvalidCallback = new Set();\n            warnOnInvalidCallback = function(callback, callerName) {\n                if (callback === null || typeof callback === \"function\") {\n                    return;\n                }\n                var key = callerName + \"_\" + callback;\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error(\"%s(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callerName, callback);\n                }\n            };\n            warnOnUndefinedDerivedState = function(type, partialState) {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || \"Component\";\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. \" + \"You have returned undefined.\", componentName);\n                    }\n                }\n            }; // This is so gross but it's at least non-critical and can be removed if\n            // it causes problems. This is meant to give a nicer error message for\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\n            // exception.\n            Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n                enumerable: false,\n                value: function() {\n                    throw new Error(\"_processChildContext is not available in React 16+. This likely \" + \"means you have multiple copies of React and are attempting to nest \" + \"a React 15 tree inside a React 16 tree using \" + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + \"to make sure you have only one copy of React (and ideally, switch \" + \"to ReactDOM.createPortal).\");\n                }\n            });\n            Object.freeze(fakeInternalInstance);\n        }\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n            var prevState = workInProgress.memoizedState;\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        // Invoke the function an extra time to help detect side-effects.\n                        partialState = getDerivedStateFromProps(nextProps, prevState);\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n            // base state.\n            if (workInProgress.lanes === NoLanes) {\n                // Queue is always non-null for classes\n                var updateQueue = workInProgress.updateQueue;\n                updateQueue.baseState = memoizedState;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: isMounted,\n            enqueueSetState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"setState\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.tag = ReplaceState;\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"replaceState\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueForceUpdate: function(inst, callback) {\n                var fiber = get(inst);\n                var eventTime = requestEventTime();\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(eventTime, lane);\n                update.tag = ForceUpdate;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback, \"forceUpdate\");\n                    }\n                    update.callback = callback;\n                }\n                enqueueUpdate(fiber, update);\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        };\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n            var instance = workInProgress.stateNode;\n            if (typeof instance.shouldComponentUpdate === \"function\") {\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            // Invoke the function an extra time to help detect side-effects.\n                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    if (shouldUpdate === undefined) {\n                        error(\"%s.shouldComponentUpdate(): Returned undefined instead of a \" + \"boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n                    }\n                }\n                return shouldUpdate;\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n            }\n            return true;\n        }\n        function checkClassInstance(workInProgress, ctor, newProps) {\n            var instance = workInProgress.stateNode;\n            {\n                var name = getComponentNameFromType(ctor) || \"Component\";\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: did you accidentally return an object from the constructor?\", name);\n                    } else {\n                        error(\"%s(...): No `render` method found on the returned component \" + \"instance: you may have forgotten to define `render`.\", name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error(\"getInitialState was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Did you mean to define a state property instead?\", name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps was defined on %s, a plain JavaScript class. \" + \"This is only supported for classes created using React.createClass. \" + \"Use a static property to define defaultProps instead.\", name);\n                }\n                if (instance.propTypes) {\n                    error(\"propTypes was defined as an instance property on %s. Use a static \" + \"property to define propTypes instead.\", name);\n                }\n                if (instance.contextType) {\n                    error(\"contextType was defined as an instance property on %s. Use a static \" + \"property to define contextType instead.\", name);\n                }\n                {\n                    if (instance.contextTypes) {\n                        error(\"contextTypes was defined as an instance property on %s. Use a static \" + \"property to define contextTypes instead.\", name);\n                    }\n                    if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                        didWarnAboutContextTypeAndContextTypes.add(ctor);\n                        error(\"%s declares both contextTypes and contextType static properties. \" + \"The legacy contextTypes property will be ignored.\", name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === \"function\") {\n                    error(\"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n                    error(\"%s has a method called shouldComponentUpdate(). \" + \"shouldComponentUpdate should not be used when extending React.PureComponent. \" + \"Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n                }\n                if (typeof instance.componentDidUnmount === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidUnmount(). But there is no such lifecycle method. \" + \"Did you mean componentWillUnmount()?\", name);\n                }\n                if (typeof instance.componentDidReceiveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentDidReceiveProps(). But there is no such lifecycle method. \" + \"If you meant to update the state in response to changing props, \" + \"use componentWillReceiveProps(). If you meant to fetch data or \" + \"run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n                }\n                if (typeof instance.componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n                    error(\"%s has a method called \" + \"UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error(\"%s(...): When calling super() in `%s`, make sure to pass \" + \"up the same props that your component's constructor was passed.\", name, name);\n                }\n                if (instance.defaultProps) {\n                    error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored.\" + \" Instead, define defaultProps as a static property on %s.\", name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). \" + \"This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === \"function\") {\n                    error(\"%s: getDerivedStateFromProps() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof instance.getDerivedStateFromError === \"function\") {\n                    error(\"%s: getDerivedStateFromError() is defined as an instance method \" + \"and will be ignored. Instead, declare it as a static method.\", name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n                    error(\"%s: getSnapshotBeforeUpdate() is defined as a static method \" + \"and will be ignored. Instead, declare it as an instance method.\", name);\n                }\n                var _state = instance.state;\n                if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n                    error(\"%s.state: must be set to an object or null\", name);\n                }\n                if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n                    error(\"%s.getChildContext(): childContextTypes must be defined in order to \" + \"use getChildContext().\", name);\n                }\n            }\n        }\n        function adoptClassInstance(workInProgress, instance) {\n            instance.updater = classComponentUpdater;\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n            set(instance, workInProgress);\n            {\n                instance._reactInternalInstance = fakeInternalInstance;\n            }\n        }\n        function constructClassInstance(workInProgress, ctor, props) {\n            var isLegacyContextConsumer = false;\n            var unmaskedContext = emptyContextObject;\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if (\"contextType\" in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = \"\";\n                        if (contextType === undefined) {\n                            addendum = \" However, it is set to undefined. \" + \"This can be caused by a typo or by mixing up named and default imports. \" + \"This can also happen due to a circular dependency, so \" + \"try moving the createContext() call to a separate file.\";\n                        } else if (typeof contextType !== \"object\") {\n                            addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                            addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                        } else if (contextType._context !== undefined) {\n                            // <Context.Consumer>\n                            addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                        } else {\n                            addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                        }\n                        error(\"%s defines an invalid contextType. \" + \"contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n                    }\n                }\n            }\n            if (typeof contextType === \"object\" && contextType !== null) {\n                context = readContext(contextType);\n            } else {\n                unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                var contextTypes = ctor.contextTypes;\n                isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n                context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n            }\n            var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        instance = new ctor(props, context); // eslint-disable-line no-new\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n            }\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n            adoptClassInstance(workInProgress, instance);\n            {\n                if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error(\"`%s` uses `getDerivedStateFromProps` but its initial state is \" + \"%s. This is not recommended. Instead, define the initial state by \" + \"assigning an object to `this.state` in the constructor of `%s`. \" + \"This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = \"componentWillMount\";\n                    } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        foundWillMountName = \"UNSAFE_componentWillMount\";\n                    }\n                    if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = \"componentWillReceiveProps\";\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                        foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n                    }\n                    if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = \"componentWillUpdate\";\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                        var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n\" + \"%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n\" + \"The above lifecycles should be removed. Learn more about this warning here:\\n\" + \"https://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                        }\n                    }\n                }\n            }\n            // ReactFiberContext usually updates this cache but can't for newly-created instances.\n            if (isLegacyContextConsumer) {\n                cacheContext(workInProgress, unmaskedContext, context);\n            }\n            return instance;\n        }\n        function callComponentWillMount(workInProgress, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === \"function\") {\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error(\"%s.componentWillMount(): Assigning directly to this.state is \" + \"deprecated (except inside a component's \" + \"constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\");\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillReceiveProps === \"function\") {\n                instance.componentWillReceiveProps(newProps, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n            }\n            if (instance.state !== oldState) {\n                {\n                    var componentName = getComponentNameFromFiber(workInProgress) || \"Component\";\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\n                        error(\"%s.componentWillReceiveProps(): Assigning directly to \" + \"this.state is deprecated (except inside a component's \" + \"constructor). Use setState instead.\", componentName);\n                    }\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            {\n                checkClassInstance(workInProgress, ctor, newProps);\n            }\n            var instance = workInProgress.stateNode;\n            instance.props = newProps;\n            instance.state = workInProgress.memoizedState;\n            instance.refs = emptyRefsObject;\n            initializeUpdateQueue(workInProgress);\n            var contextType = ctor.contextType;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                instance.context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || \"Component\";\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error(\"%s: It is not recommended to assign props directly to state \" + \"because updates to props won't be reflected in state. \" + \"In most cases, it is better to use props directly.\", componentName);\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n                }\n                {\n                    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n                }\n            }\n            instance.state = workInProgress.memoizedState;\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                instance.state = workInProgress.memoizedState;\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n                instance.state = workInProgress.memoizedState;\n            }\n            if (typeof instance.componentDidMount === \"function\") {\n                var fiberFlags = Update;\n                {\n                    fiberFlags |= LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    fiberFlags |= MountLayoutDev;\n                }\n                workInProgress.flags |= fiberFlags;\n            }\n        }\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            var oldProps = workInProgress.memoizedProps;\n            instance.props = oldProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                nextContext = readContext(contextType);\n            } else {\n                var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\"; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n                if (oldProps !== newProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            newState = workInProgress.memoizedState;\n            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === \"function\") {\n                    var fiberFlags = Update;\n                    {\n                        fiberFlags |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        fiberFlags |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= fiberFlags;\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n                    if (typeof instance.componentWillMount === \"function\") {\n                        instance.componentWillMount();\n                    }\n                    if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                        instance.UNSAFE_componentWillMount();\n                    }\n                }\n                if (typeof instance.componentDidMount === \"function\") {\n                    var _fiberFlags = Update;\n                    {\n                        _fiberFlags |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        _fiberFlags |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= _fiberFlags;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === \"function\") {\n                    var _fiberFlags2 = Update;\n                    {\n                        _fiberFlags2 |= LayoutStatic;\n                    }\n                    if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                        _fiberFlags2 |= MountLayoutDev;\n                    }\n                    workInProgress.flags |= _fiberFlags2;\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n            instance.props = oldProps;\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === \"object\" && contextType !== null) {\n                nextContext = readContext(contextType);\n            } else {\n                var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n                nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\"; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            newState = workInProgress.memoizedState;\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === \"function\") {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n            // both before and after `shouldComponentUpdate` has been called. Not ideal,\n            // but I'm loath to refactor this function. This only happens for memoized\n            // components so it's not that common.\n            enableLazyContextPropagation;\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === \"function\" || typeof instance.componentWillUpdate === \"function\")) {\n                    if (typeof instance.componentWillUpdate === \"function\") {\n                        instance.componentWillUpdate(newProps, newState, nextContext);\n                    }\n                    if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n                    }\n                }\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    workInProgress.flags |= Update;\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    workInProgress.flags |= Snapshot;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized props/state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        }\n        // TODO: Use the unified fiber stack module instead of this local one?\n        // Intentionally not using it yet to derisk the initial implementation, because\n        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n        // rather the ids be wrong than crash the whole reconciler.\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = \"\";\n        function isForkedChild(workInProgress) {\n            warnIfNotHydrating();\n            return (workInProgress.flags & Forked) !== NoFlags;\n        }\n        function getForksAtLevel(workInProgress) {\n            warnIfNotHydrating();\n            return treeForkCount;\n        }\n        function getTreeId() {\n            var overflow = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress, totalChildren) {\n            // This is called right after we reconcile an array (or iterator) of child\n            // fibers, because that's the only place where we know how many children in\n            // the whole set without doing extra work later, or storing addtional\n            // information on the fiber.\n            //\n            // That's why this function is separate from pushTreeId — it's called during\n            // the render phase of the fork parent, not the child, which is where we push\n            // the other context values.\n            //\n            // In the Fizz implementation this is much simpler because the child is\n            // rendered in the same callstack as the parent.\n            //\n            // It might be better to just add a `forks` field to the Fiber type. It would\n            // make this module simpler.\n            warnIfNotHydrating();\n            forkStack[forkStackIndex++] = treeForkCount;\n            forkStack[forkStackIndex++] = treeForkProvider;\n            treeForkProvider = workInProgress;\n            treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress, totalChildren, index) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextProvider = workInProgress;\n            var baseIdWithLeadingBit = treeContextId;\n            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                treeContextId = 1 << restOfLength | id;\n                treeContextOverflow = overflow;\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                treeContextId = 1 << length | _id;\n                treeContextOverflow = _overflow;\n            }\n        }\n        function pushMaterializedTreeId(workInProgress) {\n            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n            // in its children.\n            var returnFiber = workInProgress.return;\n            if (returnFiber !== null) {\n                var numberOfForks = 1;\n                var slotIndex = 0;\n                pushTreeFork(workInProgress, numberOfForks);\n                pushTreeId(workInProgress, numberOfForks, slotIndex);\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress) {\n            // Restore the previous values.\n            // This is a bit more complicated than other context-like modules in Fiber\n            // because the same Fiber may appear on the stack multiple times and for\n            // different reasons. We have to keep popping until the work-in-progress is\n            // no longer at the top of the stack.\n            while(workInProgress === treeForkProvider){\n                treeForkProvider = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n                treeForkCount = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n            }\n            while(workInProgress === treeContextProvider){\n                treeContextProvider = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextOverflow = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextId = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n            }\n        }\n        function getSuspendedTreeContext() {\n            warnIfNotHydrating();\n            if (treeContextProvider !== null) {\n                return {\n                    id: treeContextId,\n                    overflow: treeContextOverflow\n                };\n            } else {\n                return null;\n            }\n        }\n        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextId = suspendedContext.id;\n            treeContextOverflow = suspendedContext.overflow;\n            treeContextProvider = workInProgress;\n        }\n        function warnIfNotHydrating() {\n            {\n                if (!getIsHydrating()) {\n                    error(\"Expected to be hydrating. This is a bug in React. Please file \" + \"an issue.\");\n                }\n            }\n        }\n        // This may have been an insertion or a hydration.\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false;\n        var didSuspend = false; // Hydration errors that were thrown inside this boundary\n        var hydrationErrors = null;\n        function warnIfHydrating() {\n            {\n                if (isHydrating) {\n                    error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\");\n                }\n            }\n        }\n        function markDidSuspendWhileHydratingDEV() {\n            {\n                didSuspend = true;\n            }\n        }\n        function enterHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            var parentInstance = fiber.stateNode.containerInfo;\n            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspend = false;\n            return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n            if (!supportsHydration) {\n                return false;\n            }\n            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspend = false;\n            if (treeContext !== null) {\n                restoreSuspendedTreeContext(fiber, treeContext);\n            }\n            return true;\n        }\n        function warnUnhydratedInstance(returnFiber, instance) {\n            {\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n                        break;\n                    case HostComponent:\n                        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n                        break;\n                    case SuspenseComponent:\n                        var suspenseState = returnFiber.memoizedState;\n                        if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n                        break;\n                }\n            }\n        }\n        function deleteHydratableInstance(returnFiber, instance) {\n            warnUnhydratedInstance(returnFiber, instance);\n            var childToDelete = createFiberFromHostInstanceForDeletion();\n            childToDelete.stateNode = instance;\n            childToDelete.return = returnFiber;\n            var deletions = returnFiber.deletions;\n            if (deletions === null) {\n                returnFiber.deletions = [\n                    childToDelete\n                ];\n                returnFiber.flags |= ChildDeletion;\n            } else {\n                deletions.push(childToDelete);\n            }\n        }\n        function warnNonhydratedInstance(returnFiber, fiber) {\n            {\n                if (didSuspend) {\n                    // Inside a boundary that already suspended. We're currently rendering the\n                    // siblings of a suspended node. The mismatch may be due to the missing\n                    // data, so it's probably a false positive.\n                    return;\n                }\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        {\n                            var parentContainer = returnFiber.stateNode.containerInfo;\n                            switch(fiber.tag){\n                                case HostComponent:\n                                    var type = fiber.type;\n                                    var props = fiber.pendingProps;\n                                    didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n                                    break;\n                                case HostText:\n                                    var text = fiber.pendingProps;\n                                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n                                    break;\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            var parentType = returnFiber.type;\n                            var parentProps = returnFiber.memoizedProps;\n                            var parentInstance = returnFiber.stateNode;\n                            switch(fiber.tag){\n                                case HostComponent:\n                                    var _type = fiber.type;\n                                    var _props = fiber.pendingProps;\n                                    didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n                                    break;\n                                case HostText:\n                                    var _text = fiber.pendingProps;\n                                    didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n                                    break;\n                            }\n                            break;\n                        }\n                    case SuspenseComponent:\n                        {\n                            var suspenseState = returnFiber.memoizedState;\n                            var _parentInstance = suspenseState.dehydrated;\n                            if (_parentInstance !== null) switch(fiber.tag){\n                                case HostComponent:\n                                    var _type2 = fiber.type;\n                                    var _props2 = fiber.pendingProps;\n                                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);\n                                    break;\n                                case HostText:\n                                    var _text2 = fiber.pendingProps;\n                                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n                                    break;\n                                case SuspenseComponent:\n                                    didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);\n                                    break;\n                            }\n                            break;\n                        }\n                    default:\n                        return;\n                }\n            }\n        }\n        function insertNonHydratedInstance(returnFiber, fiber) {\n            fiber.flags = fiber.flags & ~Hydrating | Placement;\n            warnNonhydratedInstance(returnFiber, fiber);\n        }\n        function tryHydrate(fiber, nextInstance) {\n            switch(fiber.tag){\n                case HostComponent:\n                    {\n                        var type = fiber.type;\n                        var props = fiber.pendingProps;\n                        var instance = canHydrateInstance(nextInstance, type, props);\n                        if (instance !== null) {\n                            fiber.stateNode = instance;\n                            hydrationParentFiber = fiber;\n                            nextHydratableInstance = getFirstHydratableChild(instance);\n                            return true;\n                        }\n                        return false;\n                    }\n                case HostText:\n                    {\n                        var text = fiber.pendingProps;\n                        var textInstance = canHydrateTextInstance(nextInstance, text);\n                        if (textInstance !== null) {\n                            fiber.stateNode = textInstance;\n                            hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n                            nextHydratableInstance = null;\n                            return true;\n                        }\n                        return false;\n                    }\n                case SuspenseComponent:\n                    {\n                        {\n                            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n                            if (suspenseInstance !== null) {\n                                var suspenseState = {\n                                    dehydrated: suspenseInstance,\n                                    treeContext: getSuspendedTreeContext(),\n                                    retryLane: OffscreenLane\n                                };\n                                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n                                // This simplifies the code for getHostSibling and deleting nodes,\n                                // since it doesn't have to consider all Suspense boundaries and\n                                // check if they're dehydrated ones or not.\n                                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                                dehydratedFragment.return = fiber;\n                                fiber.child = dehydratedFragment;\n                                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n                                // it during the first pass. Instead, we'll reenter it later.\n                                nextHydratableInstance = null;\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n                default:\n                    return false;\n            }\n        }\n        function shouldClientRenderOnMismatch(fiber) {\n            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n        }\n        function throwOnHydrationMismatch(fiber) {\n            throw new Error(\"Hydration failed because the initial UI does not match what was \" + \"rendered on the server.\");\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance) {\n                if (shouldClientRenderOnMismatch(fiber)) {\n                    warnNonhydratedInstance(hydrationParentFiber, fiber);\n                    throwOnHydrationMismatch();\n                } // Nothing to hydrate. Make it an insertion.\n                insertNonHydratedInstance(hydrationParentFiber, fiber);\n                isHydrating = false;\n                hydrationParentFiber = fiber;\n                return;\n            }\n            var firstAttemptedInstance = nextInstance;\n            if (!tryHydrate(fiber, nextInstance)) {\n                if (shouldClientRenderOnMismatch(fiber)) {\n                    warnNonhydratedInstance(hydrationParentFiber, fiber);\n                    throwOnHydrationMismatch();\n                } // If we can't hydrate this instance let's try the next one.\n                // We use this as a heuristic. It's based on intuition and not data so it\n                // might be flawed or unnecessary.\n                nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n                var prevHydrationParentFiber = hydrationParentFiber;\n                if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n                    // Nothing to hydrate. Make it an insertion.\n                    insertNonHydratedInstance(hydrationParentFiber, fiber);\n                    isHydrating = false;\n                    hydrationParentFiber = fiber;\n                    return;\n                } // We matched the next one, we'll now assume that the first one was\n                // superfluous and we'll delete it. Since we can't eagerly delete it\n                // we'll have to schedule a deletion. To do that, this node needs a dummy\n                // fiber associated with it.\n                deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n            }\n        }\n        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var instance = fiber.stateNode;\n            var shouldWarnIfMismatchDev = !didSuspend;\n            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n            fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n            // is a new ref we mark this as an update.\n            if (updatePayload !== null) {\n                return true;\n            }\n            return false;\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostTextInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var textInstance = fiber.stateNode;\n            var textContent = fiber.memoizedProps;\n            var shouldWarnIfMismatchDev = !didSuspend;\n            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n            if (shouldUpdate) {\n                // We assume that prepareToHydrateHostTextInstance is called in a context where the\n                // hydration parent is the parent host component of this host text.\n                var returnFiber = hydrationParentFiber;\n                if (returnFiber !== null) {\n                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                    switch(returnFiber.tag){\n                        case HostRoot:\n                            {\n                                var parentContainer = returnFiber.stateNode.containerInfo;\n                                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);\n                                break;\n                            }\n                        case HostComponent:\n                            {\n                                var parentType = returnFiber.type;\n                                var parentProps = returnFiber.memoizedProps;\n                                var parentInstance = returnFiber.stateNode;\n                                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, isConcurrentMode);\n                                break;\n                            }\n                    }\n                }\n            }\n            return shouldUpdate;\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error(\"Expected to have a hydrated suspense instance. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n            var parent = fiber.return;\n            while(parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent){\n                parent = parent.return;\n            }\n            hydrationParentFiber = parent;\n        }\n        function popHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            if (fiber !== hydrationParentFiber) {\n                // We're deeper than the current hydration context, inside an inserted\n                // tree.\n                return false;\n            }\n            if (!isHydrating) {\n                // If we're not currently hydrating but we're in a hydration context, then\n                // we were an insertion and now need to pop up reenter hydration of our\n                // siblings.\n                popToNextHostParent(fiber);\n                isHydrating = true;\n                return false;\n            } // If we have any remaining hydratable nodes, we need to delete them now.\n            // We only do this deeper than head and body since they tend to have random\n            // other nodes in them. We also ignore components with pure text content in\n            // side of them. We also don't delete anything inside the root container.\n            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n                var nextInstance = nextHydratableInstance;\n                if (nextInstance) {\n                    if (shouldClientRenderOnMismatch(fiber)) {\n                        warnIfUnhydratedTailNodes(fiber);\n                        throwOnHydrationMismatch();\n                    } else {\n                        while(nextInstance){\n                            deleteHydratableInstance(fiber, nextInstance);\n                            nextInstance = getNextHydratableSibling(nextInstance);\n                        }\n                    }\n                }\n            }\n            popToNextHostParent(fiber);\n            if (fiber.tag === SuspenseComponent) {\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n            } else {\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n            }\n            return true;\n        }\n        function hasUnhydratedTailNodes() {\n            return isHydrating && nextHydratableInstance !== null;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n            var nextInstance = nextHydratableInstance;\n            while(nextInstance){\n                warnUnhydratedInstance(fiber, nextInstance);\n                nextInstance = getNextHydratableSibling(nextInstance);\n            }\n        }\n        function resetHydrationState() {\n            if (!supportsHydration) {\n                return;\n            }\n            hydrationParentFiber = null;\n            nextHydratableInstance = null;\n            isHydrating = false;\n            didSuspend = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n            if (hydrationErrors !== null) {\n                // Successfully completed a forced client render. The errors that occurred\n                // during the hydration attempt are now recovered. We will log them in\n                // commit phase, once the entire tree has finished.\n                queueRecoverableErrors(hydrationErrors);\n                hydrationErrors = null;\n            }\n        }\n        function getIsHydrating() {\n            return isHydrating;\n        }\n        function queueHydrationError(error) {\n            if (hydrationErrors === null) {\n                hydrationErrors = [\n                    error\n                ];\n            } else {\n                hydrationErrors.push(error);\n            }\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var didWarnAboutStringRefs;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {};\n        {\n            didWarnAboutMaps = false;\n            didWarnAboutGenerators = false;\n            didWarnAboutStringRefs = {};\n            /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ ownerHasKeyUseWarning = {};\n            ownerHasFunctionTypeWarning = {};\n            warnForMissingKey = function(child, returnFiber) {\n                if (child === null || typeof child !== \"object\") {\n                    return;\n                }\n                if (!child._store || child._store.validated || child.key != null) {\n                    return;\n                }\n                if (typeof child._store !== \"object\") {\n                    throw new Error(\"React Component in warnForMissingKey should have a _store. \" + \"This error is likely caused by a bug in React. Please file an issue.\");\n                }\n                child._store.validated = true;\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (ownerHasKeyUseWarning[componentName]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[componentName] = true;\n                error(\"Each child in a list should have a unique \" + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + \"more information.\");\n            };\n        }\n        function coerceRef(returnFiber, current, element) {\n            var mixedRef = element.ref;\n            if (mixedRef !== null && typeof mixedRef !== \"function\" && typeof mixedRef !== \"object\") {\n                {\n                    // TODO: Clean this up once we turn on the string ref warning for\n                    // everyone, because the strict mode case will no longer be relevant\n                    if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n                    // because these cannot be automatically converted to an arrow function\n                    // using a codemod. Therefore, we don't have to warn about string refs again.\n                    !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n                        var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                        if (!didWarnAboutStringRefs[componentName]) {\n                            {\n                                error('A string ref, \"%s\", has been found within a strict mode tree. ' + \"String refs are a source of potential bugs and should be avoided. \" + \"We recommend using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", mixedRef);\n                            }\n                            didWarnAboutStringRefs[componentName] = true;\n                        }\n                    }\n                }\n                if (element._owner) {\n                    var owner = element._owner;\n                    var inst;\n                    if (owner) {\n                        var ownerFiber = owner;\n                        if (ownerFiber.tag !== ClassComponent) {\n                            throw new Error(\"Function components cannot have string refs. \" + \"We recommend using useRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\");\n                        }\n                        inst = ownerFiber.stateNode;\n                    }\n                    if (!inst) {\n                        throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n                    } // Assigning this to a const so Flow knows it won't change in the closure\n                    var resolvedInst = inst;\n                    {\n                        checkPropStringCoercion(mixedRef, \"ref\");\n                    }\n                    var stringRef = \"\" + mixedRef; // Check if previous string ref matches new string ref\n                    if (current !== null && current.ref !== null && typeof current.ref === \"function\" && current.ref._stringRef === stringRef) {\n                        return current.ref;\n                    }\n                    var ref = function(value) {\n                        var refs = resolvedInst.refs;\n                        if (refs === emptyRefsObject) {\n                            // This is a lazy pooled frozen object, so we need to initialize.\n                            refs = resolvedInst.refs = {};\n                        }\n                        if (value === null) {\n                            delete refs[stringRef];\n                        } else {\n                            refs[stringRef] = value;\n                        }\n                    };\n                    ref._stringRef = stringRef;\n                    return ref;\n                } else {\n                    if (typeof mixedRef !== \"string\") {\n                        throw new Error(\"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\n                    }\n                    if (!element._owner) {\n                        throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + \" the following reasons:\\n\" + \"1. You may be adding a ref to a function component\\n\" + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + \"3. You have multiple copies of React loaded\\n\" + \"See https://reactjs.org/link/refs-must-have-owner for more information.\");\n                    }\n                }\n            }\n            return mixedRef;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n            var childString = Object.prototype.toString.call(newChild);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : childString) + \"). \" + \"If you meant to render a collection of children, use an array \" + \"instead.\");\n        }\n        function warnOnFunctionType(returnFiber) {\n            {\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (ownerHasFunctionTypeWarning[componentName]) {\n                    return;\n                }\n                ownerHasFunctionTypeWarning[componentName] = true;\n                error(\"Functions are not valid as a React child. This may happen if \" + \"you return a Component instead of <Component /> from render. \" + \"Or maybe you meant to call this function rather than return it.\");\n            }\n        }\n        function resolveLazy(lazyType) {\n            var payload = lazyType._payload;\n            var init = lazyType._init;\n            return init(payload);\n        } // This wrapper function exists because I expect to clone the code in each path\n        // to be able to optimize each path individually by branching early. This needs\n        // a compiler or we can do it manually. Helpers that don't need this branching\n        // live outside of this function.\n        function ChildReconciler(shouldTrackSideEffects) {\n            function deleteChild(returnFiber, childToDelete) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return;\n                }\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        childToDelete\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(childToDelete);\n                }\n            }\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return null;\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n                // assuming that after the first child we've already added everything.\n                var childToDelete = currentFirstChild;\n                while(childToDelete !== null){\n                    deleteChild(returnFiber, childToDelete);\n                    childToDelete = childToDelete.sibling;\n                }\n                return null;\n            }\n            function mapRemainingChildren(returnFiber, currentFirstChild) {\n                // Add the remaining children to a temporary map so that we can find them by\n                // keys quickly. Implicit (null) keys get added to this set with their index\n                // instead.\n                var existingChildren = new Map();\n                var existingChild = currentFirstChild;\n                while(existingChild !== null){\n                    if (existingChild.key !== null) {\n                        existingChildren.set(existingChild.key, existingChild);\n                    } else {\n                        existingChildren.set(existingChild.index, existingChild);\n                    }\n                    existingChild = existingChild.sibling;\n                }\n                return existingChildren;\n            }\n            function useFiber(fiber, pendingProps) {\n                // We currently set sibling to null and index to 0 here because it is easy\n                // to forget to do before returning it. E.g. for the single child case.\n                var clone = createWorkInProgress(fiber, pendingProps);\n                clone.index = 0;\n                clone.sibling = null;\n                return clone;\n            }\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\n                newFiber.index = newIndex;\n                if (!shouldTrackSideEffects) {\n                    // During hydration, the useId algorithm needs to know which fibers are\n                    // part of a list of children (arrays, iterators).\n                    newFiber.flags |= Forked;\n                    return lastPlacedIndex;\n                }\n                var current = newFiber.alternate;\n                if (current !== null) {\n                    var oldIndex = current.index;\n                    if (oldIndex < lastPlacedIndex) {\n                        // This is a move.\n                        newFiber.flags |= Placement;\n                        return lastPlacedIndex;\n                    } else {\n                        // This item can stay in place.\n                        return oldIndex;\n                    }\n                } else {\n                    // This is an insertion.\n                    newFiber.flags |= Placement;\n                    return lastPlacedIndex;\n                }\n            }\n            function placeSingleChild(newFiber) {\n                // This is simpler for the single child case. We only need to do a\n                // placement for inserting new children.\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\n                    newFiber.flags |= Placement;\n                }\n                return newFiber;\n            }\n            function updateTextNode(returnFiber, current, textContent, lanes) {\n                if (current === null || current.tag !== HostText) {\n                    // Insert\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function updateElement(returnFiber, current, element, lanes) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                    return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n                }\n                if (current !== null) {\n                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.\n                    // We need to do this after the Hot Reloading check above,\n                    // because hot reloading has different semantics than prod because\n                    // it doesn't resuspend. So we can't let the call below suspend.\n                    typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n                        // Move based on index\n                        var existing = useFiber(current, element.props);\n                        existing.ref = coerceRef(returnFiber, current, element);\n                        existing.return = returnFiber;\n                        {\n                            existing._debugSource = element._source;\n                            existing._debugOwner = element._owner;\n                        }\n                        return existing;\n                    }\n                } // Insert\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\n                created.ref = coerceRef(returnFiber, current, element);\n                created.return = returnFiber;\n                return created;\n            }\n            function updatePortal(returnFiber, current, portal, lanes) {\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n                    // Insert\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, portal.children || []);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function updateFragment(returnFiber, current, fragment, lanes, key) {\n                if (current === null || current.tag !== Fragment) {\n                    // Insert\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, fragment);\n                    existing.return = returnFiber;\n                    return existing;\n                }\n            }\n            function createChild(returnFiber, newChild, lanes) {\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    var created = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    return created;\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                                _created.ref = coerceRef(returnFiber, null, newChild);\n                                _created.return = returnFiber;\n                                return _created;\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                                _created2.return = returnFiber;\n                                return _created2;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                {\n                                    var payload = newChild._payload;\n                                    var init = newChild._init;\n                                    return createChild(returnFiber, init(payload), lanes);\n                                }\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                        _created3.return = returnFiber;\n                        return _created3;\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n                // Update the fiber if the keys match, otherwise return null.\n                var key = oldFiber !== null ? oldFiber.key : null;\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    if (key !== null) {\n                        return null;\n                    }\n                    return updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                {\n                                    var payload = newChild._payload;\n                                    var init = newChild._init;\n                                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n                                }\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        if (key !== null) {\n                            return null;\n                        }\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    // Text nodes don't have keys, so we neither have to check the old nor\n                    // new node for the key. If both are text nodes, they match.\n                    var matchedFiber = existingChildren.get(newIdx) || null;\n                    return updateTextNode(returnFiber, matchedFiber, \"\" + newChild, lanes);\n                }\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild)) {\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return null;\n            }\n            /**\n   * Warns if there is a duplicate or missing key\n   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {\n                {\n                    if (typeof child !== \"object\" || child === null) {\n                        return knownKeys;\n                    }\n                    switch(child.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                        case REACT_PORTAL_TYPE:\n                            warnForMissingKey(child, returnFiber);\n                            var key = child.key;\n                            if (typeof key !== \"string\") {\n                                break;\n                            }\n                            if (knownKeys === null) {\n                                knownKeys = new Set();\n                                knownKeys.add(key);\n                                break;\n                            }\n                            if (!knownKeys.has(key)) {\n                                knownKeys.add(key);\n                                break;\n                            }\n                            error(\"Encountered two children with the same key, `%s`. \" + \"Keys should be unique so that components maintain their identity \" + \"across updates. Non-unique keys may cause children to be \" + \"duplicated and/or omitted — the behavior is unsupported and \" + \"could change in a future version.\", key);\n                            break;\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = child._payload;\n                                var init = child._init;\n                                warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                                break;\n                            }\n                    }\n                }\n                return knownKeys;\n            }\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n                // This algorithm can't optimize by searching from both ends since we\n                // don't have backpointers on fibers. I'm trying to see how far we can get\n                // with that model. If it ends up not being worth the tradeoffs, we can\n                // add it later.\n                // Even with a two ended optimization, we'd want to optimize for the case\n                // where there are few changes and brute force the comparison instead of\n                // going for the Map. It'd like to explore hitting that path first in\n                // forward-only mode and only go for the Map once we notice that we need\n                // lots of look ahead. This doesn't handle reversal as well as two ended\n                // search but that's unusual. Besides, for the two ended optimization to\n                // work on Iterables, we'd need to copy the whole set.\n                // In this first iteration, we'll just live with hitting the bad case\n                // (adding everything to a Map) in for every insert/move.\n                // If you change this code, also update reconcileChildrenIterator() which\n                // uses the same algorithm.\n                {\n                    // First, validate keys.\n                    var knownKeys = null;\n                    for(var i = 0; i < newChildren.length; i++){\n                        var child = newChildren[i];\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                    }\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (newIdx === newChildren.length) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; newIdx < newChildren.length; newIdx++){\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n                        if (_newFiber === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber;\n                        } else {\n                            previousNewFiber.sibling = _newFiber;\n                        }\n                        previousNewFiber = _newFiber;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; newIdx < newChildren.length; newIdx++){\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n                    if (_newFiber2 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber2.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber2;\n                        } else {\n                            previousNewFiber.sibling = _newFiber2;\n                        }\n                        previousNewFiber = _newFiber2;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks2 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks2);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n                // This is the same implementation as reconcileChildrenArray(),\n                // but using the iterator instead.\n                var iteratorFn = getIteratorFn(newChildrenIterable);\n                if (typeof iteratorFn !== \"function\") {\n                    throw new Error(\"An object is not an iterable. This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n                }\n                {\n                    // We don't support rendering Generators because it's a mutation.\n                    // See https://github.com/facebook/react/issues/12995\n                    if (typeof Symbol === \"function\" && // $FlowFixMe Flow doesn't know about toStringTag\n                    newChildrenIterable[Symbol.toStringTag] === \"Generator\") {\n                        if (!didWarnAboutGenerators) {\n                            error(\"Using Generators as children is unsupported and will likely yield \" + \"unexpected results because enumerating a generator mutates it. \" + \"You may convert it to an array with `Array.from()` or the \" + \"`[...spread]` operator before rendering. Keep in mind \" + \"you might need to polyfill these features for older browsers.\");\n                        }\n                        didWarnAboutGenerators = true;\n                    } // Warn about using Maps as children\n                    if (newChildrenIterable.entries === iteratorFn) {\n                        if (!didWarnAboutMaps) {\n                            error(\"Using Maps as children is not supported. \" + \"Use an array of keyed ReactElements instead.\");\n                        }\n                        didWarnAboutMaps = true;\n                    } // First, validate keys.\n                    // We'll get a different iterator later for the main pass.\n                    var _newChildren = iteratorFn.call(newChildrenIterable);\n                    if (_newChildren) {\n                        var knownKeys = null;\n                        var _step = _newChildren.next();\n                        for(; !_step.done; _step = _newChildren.next()){\n                            var child = _step.value;\n                            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                        }\n                    }\n                }\n                var newChildren = iteratorFn.call(newChildrenIterable);\n                if (newChildren == null) {\n                    throw new Error(\"An iterable object provided no iterator.\");\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                var step = newChildren.next();\n                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (step.done) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; !step.done; newIdx++, step = newChildren.next()){\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes);\n                        if (_newFiber3 === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber3;\n                        } else {\n                            previousNewFiber.sibling = _newFiber3;\n                        }\n                        previousNewFiber = _newFiber3;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks3 = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks3);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; !step.done; newIdx++, step = newChildren.next()){\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n                    if (_newFiber4 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber4.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber4;\n                        } else {\n                            previousNewFiber.sibling = _newFiber4;\n                        }\n                        previousNewFiber = _newFiber4;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks4 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks4);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n                // There's no need to check for keys on text nodes since we don't have a\n                // way to define them.\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n                    // We already have an existing node so let's just update it and delete\n                    // the rest.\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                    var existing = useFiber(currentFirstChild, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                } // The existing first child is not a text node so we need to create one\n                // and delete the existing ones.\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            }\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n                var key = element.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        var elementType = element.type;\n                        if (elementType === REACT_FRAGMENT_TYPE) {\n                            if (child.tag === Fragment) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var existing = useFiber(child, element.props.children);\n                                existing.return = returnFiber;\n                                {\n                                    existing._debugSource = element._source;\n                                    existing._debugOwner = element._owner;\n                                }\n                                return existing;\n                            }\n                        } else {\n                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                            // We need to do this after the Hot Reloading check above,\n                            // because hot reloading has different semantics than prod because\n                            // it doesn't resuspend. So we can't let the call below suspend.\n                            typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var _existing = useFiber(child, element.props);\n                                _existing.ref = coerceRef(returnFiber, child, element);\n                                _existing.return = returnFiber;\n                                {\n                                    _existing._debugSource = element._source;\n                                    _existing._debugOwner = element._owner;\n                                }\n                                return _existing;\n                            }\n                        } // Didn't match.\n                        deleteRemainingChildren(returnFiber, child);\n                        break;\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                if (element.type === REACT_FRAGMENT_TYPE) {\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n                    created.return = returnFiber;\n                    return created;\n                } else {\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n                    _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n                    _created4.return = returnFiber;\n                    return _created4;\n                }\n            }\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n                var key = portal.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                            deleteRemainingChildren(returnFiber, child.sibling);\n                            var existing = useFiber(child, portal.children || []);\n                            existing.return = returnFiber;\n                            return existing;\n                        } else {\n                            deleteRemainingChildren(returnFiber, child);\n                            break;\n                        }\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            } // This API will tag the children with the side-effect of the reconciliation\n            // itself. They will be added to the side-effect list as we pass through the\n            // children and the parent.\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n                // This function is not recursive.\n                // If the top level item is an array, we treat it as a set of children,\n                // not as a fragment. Nested arrays on the other hand will be treated as\n                // fragment nodes. Recursion happens at the normal flow.\n                // Handle top level unkeyed fragments as if they were arrays.\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n                // We treat the ambiguous cases above the same.\n                var isUnkeyedTopLevelFragment = typeof newChild === \"object\" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n                if (isUnkeyedTopLevelFragment) {\n                    newChild = newChild.props.children;\n                } // Handle object types\n                if (typeof newChild === \"object\" && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_PORTAL_TYPE:\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n                                return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n                            }\n                    }\n                    if (isArray(newChild)) {\n                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n                    }\n                    if (getIteratorFn(newChild)) {\n                        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, \"\" + newChild, lanes));\n                }\n                {\n                    if (typeof newChild === \"function\") {\n                        warnOnFunctionType(returnFiber);\n                    }\n                }\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\n            }\n            return reconcileChildFibers;\n        }\n        var reconcileChildFibers = ChildReconciler(true);\n        var mountChildFibers = ChildReconciler(false);\n        function cloneChildFibers(current, workInProgress) {\n            if (current !== null && workInProgress.child !== current.child) {\n                throw new Error(\"Resuming work not yet implemented.\");\n            }\n            if (workInProgress.child === null) {\n                return;\n            }\n            var currentChild = workInProgress.child;\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n            workInProgress.child = newChild;\n            newChild.return = workInProgress;\n            while(currentChild.sibling !== null){\n                currentChild = currentChild.sibling;\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n                newChild.return = workInProgress;\n            }\n            newChild.sibling = null;\n        } // Reset a workInProgress child set to prepare it for a second pass.\n        function resetChildFibers(workInProgress, lanes) {\n            var child = workInProgress.child;\n            while(child !== null){\n                resetWorkInProgress(child, lanes);\n                child = child.sibling;\n            }\n        }\n        var NO_CONTEXT = {};\n        var contextStackCursor$1 = createCursor(NO_CONTEXT);\n        var contextFiberStackCursor = createCursor(NO_CONTEXT);\n        var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n        function requiredContext(c) {\n            if (c === NO_CONTEXT) {\n                throw new Error(\"Expected host context to exist. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n            }\n            return c;\n        }\n        function getRootHostContainer() {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n            // Push current root instance onto the stack;\n            // This allows us to reset root when portals are popped.\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n            // However, we can't just call getRootHostContext() and push it because\n            // we'd have a different number of entries on the stack depending on\n            // whether getRootHostContext() throws somewhere in renderer code or not.\n            // So we push an empty value first. This lets us safely unwind on errors.\n            push(contextStackCursor$1, NO_CONTEXT, fiber);\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n            pop(contextStackCursor$1, fiber);\n            push(contextStackCursor$1, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n            pop(contextStackCursor$1, fiber);\n            pop(contextFiberStackCursor, fiber);\n            pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n            var context = requiredContext(contextStackCursor$1.current);\n            return context;\n        }\n        function pushHostContext(fiber) {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            var context = requiredContext(contextStackCursor$1.current);\n            var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n            if (context === nextContext) {\n                return;\n            } // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber);\n            push(contextStackCursor$1, nextContext, fiber);\n        }\n        function popHostContext(fiber) {\n            // Do not pop unless this Fiber provided the current context.\n            // pushHostContext() only pushes Fibers that provide unique contexts.\n            if (contextFiberStackCursor.current !== fiber) {\n                return;\n            }\n            pop(contextStackCursor$1, fiber);\n            pop(contextFiberStackCursor, fiber);\n        }\n        var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\n        // inherited deeply down the subtree. The upper bits only affect\n        // this immediate suspense boundary and gets reset each new\n        // boundary or suspense list.\n        var SubtreeSuspenseContextMask = 1; // Subtree Flags:\n        // InvisibleParentSuspenseContext indicates that one of our parent Suspense\n        // boundaries is not currently showing visible main content.\n        // Either because it is already showing a fallback or is not mounted at all.\n        // We can use this to determine if it is desirable to trigger a fallback at\n        // the parent. If not, then we might need to trigger undesirable boundaries\n        // and/or suspend the commit to avoid hiding the parent content.\n        var InvisibleParentSuspenseContext = 1; // Shallow Flags:\n        // ForceSuspenseFallback can be used by SuspenseList to force newly added\n        // items into their fallback state during one of the render passes.\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseContext(parentContext, flag) {\n            return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseContext(parentContext) {\n            return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseContext(parentContext, shallowContext) {\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function addSubtreeSuspenseContext(parentContext, subtreeContext) {\n            return parentContext | subtreeContext;\n        }\n        function pushSuspenseContext(fiber, newContext) {\n            push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseContext(fiber) {\n            pop(suspenseStackCursor, fiber);\n        }\n        function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n            // If it was the primary children that just suspended, capture and render the\n            // fallback. Otherwise, don't capture and bubble to the next boundary.\n            var nextState = workInProgress.memoizedState;\n            if (nextState !== null) {\n                if (nextState.dehydrated !== null) {\n                    // A dehydrated boundary always captures.\n                    return true;\n                }\n                return false;\n            }\n            var props = workInProgress.memoizedProps; // Regular boundaries always capture.\n            {\n                return true;\n            }\n        }\n        function findFirstSuspended(row) {\n            var node = row;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        var dehydrated = state.dehydrated;\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                            return node;\n                        }\n                    }\n                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n                // keep track of whether it suspended or not.\n                node.memoizedProps.revealOrder !== undefined) {\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags;\n                    if (didSuspend) {\n                        return node;\n                    }\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === row) {\n                    return null;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === row) {\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n            return null;\n        }\n        var NoFlags$1 = /*   */ 0; // Represents whether effect should fire.\n        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.\n        var Insertion = /*  */ 2;\n        var Layout = /*    */ 4;\n        var Passive$1 = /*   */ 8;\n        // and should be reset before starting a new render.\n        // This tracks which mutable sources need to be reset after a render.\n        var workInProgressSources = [];\n        function resetWorkInProgressVersions() {\n            for(var i = 0; i < workInProgressSources.length; i++){\n                var mutableSource = workInProgressSources[i];\n                if (isPrimaryRenderer) {\n                    mutableSource._workInProgressVersionPrimary = null;\n                } else {\n                    mutableSource._workInProgressVersionSecondary = null;\n                }\n            }\n            workInProgressSources.length = 0;\n        }\n        // This ensures that the version used for server rendering matches the one\n        // that is eventually read during hydration.\n        // If they don't match there's a potential tear and a full deopt render is required.\n        function registerMutableSourceForHydration(root, mutableSource) {\n            var getVersion = mutableSource._getVersion;\n            var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\n            // Retaining it forever may interfere with GC.\n            if (root.mutableSourceEagerHydrationData == null) {\n                root.mutableSourceEagerHydrationData = [\n                    mutableSource,\n                    version\n                ];\n            } else {\n                root.mutableSourceEagerHydrationData.push(mutableSource, version);\n            }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        {\n            didWarnAboutMismatchedHooksForComponent = new Set();\n        }\n        // These are set right before calling the component.\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n        // the work-in-progress hook.\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n        // current hook list is the list that belongs to the current fiber. The\n        // work-in-progress hook list is a new list that will be added to the\n        // work-in-progress fiber.\n        var currentHook = null;\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n        // does not get reset if we do another render pass; only when we're completely\n        // finished evaluating this component. This is an optimization so we know\n        // whether we need to clear render phase updates after a throw.\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n        // gets reset after each attempt.\n        // TODO: Maybe there's some way to consolidate this with\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n        var didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n        var localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n        // hydration). This counter is global, so client ids are not stable across\n        // render attempts.\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n        // The list stores the order of hooks used during the initial render (mount).\n        // Subsequent renders (updates) reference this list.\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev === null) {\n                    hookTypesDev = [\n                        hookName\n                    ];\n                } else {\n                    hookTypesDev.push(hookName);\n                }\n            }\n        }\n        function updateHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev !== null) {\n                    hookTypesUpdateIndexDev++;\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                        warnOnHookMismatchInDev(hookName);\n                    }\n                }\n            }\n        }\n        function checkDepsAreArrayDev(deps) {\n            {\n                if (deps !== undefined && deps !== null && !isArray(deps)) {\n                    // Verify deps, but only on mount to avoid extra checks.\n                    // It's unlikely their type would change as usually you define them inline.\n                    error(\"%s received a final argument that is not an array (instead, received `%s`). When \" + \"specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n                }\n            }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\n                    if (hookTypesDev !== null) {\n                        var table = \"\";\n                        var secondColumnStart = 30;\n                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){\n                            var oldHookName = hookTypesDev[i];\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n                            // lol @ IE not supporting String#repeat\n                            while(row.length < secondColumnStart){\n                                row += \" \";\n                            }\n                            row += newHookName + \"\\n\";\n                            table += row;\n                        }\n                        error(\"React has detected a change in the order of Hooks called by %s. \" + \"This will lead to bugs and errors if not fixed. \" + \"For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n\" + \"   Previous render            Next render\\n\" + \"   ------------------------------------------------------\\n\" + \"%s\" + \"   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n                    }\n                }\n            }\n        }\n        function throwInvalidHookError() {\n            throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for\" + \" one of the following reasons:\\n\" + \"1. You might have mismatching versions of React and the renderer (such as React DOM)\\n\" + \"2. You might be breaking the Rules of Hooks\\n\" + \"3. You might have more than one copy of React in the same app\\n\" + \"See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            {\n                if (ignorePreviousDependencies) {\n                    // Only true when this component is being hot reloaded.\n                    return false;\n                }\n            }\n            if (prevDeps === null) {\n                {\n                    error(\"%s received a final argument during this render, but not during \" + \"the previous render. Even though the final argument is optional, \" + \"its type cannot change between renders.\", currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error(\"The final argument passed to %s changed size between renders. The \" + \"order and size of this array must remain constant.\\n\\n\" + \"Previous: %s\\n\" + \"Incoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n            renderLanes = nextRenderLanes;\n            currentlyRenderingFiber$1 = workInProgress;\n            {\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n            }\n            workInProgress.memoizedState = null;\n            workInProgress.updateQueue = null;\n            workInProgress.lanes = NoLanes; // The following should have already been reset\n            // currentHook = null;\n            // workInProgressHook = null;\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\n            // Currently we will identify the update render as a mount because memoizedState === null.\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n            // so memoizedState would be null during updates and mounts.\n            {\n                if (current !== null && current.memoizedState !== null) {\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n                } else if (hookTypesDev !== null) {\n                    // This dispatcher handles an edge case where a component is updating,\n                    // but no stateful hooks have been used.\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n                    // This dispatcher does that.\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n                } else {\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n                }\n            }\n            var children = Component(props, secondArg); // Check if there was a render phase update\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                // Keep rendering in a loop for as long as render phase updates continue to\n                // be scheduled. Use a counter to prevent infinite loops.\n                var numberOfReRenders = 0;\n                do {\n                    didScheduleRenderPhaseUpdateDuringThisPass = false;\n                    localIdCounter = 0;\n                    if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                        throw new Error(\"Too many re-renders. React limits the number of renders to prevent \" + \"an infinite loop.\");\n                    }\n                    numberOfReRenders += 1;\n                    {\n                        // Even when hot reloading, allow dependencies to stabilize\n                        // after first render to prevent infinite render phase updates.\n                        ignorePreviousDependencies = false;\n                    }\n                    currentHook = null;\n                    workInProgressHook = null;\n                    workInProgress.updateQueue = null;\n                    {\n                        // Also validate hook order for cascading updates.\n                        hookTypesUpdateIndexDev = -1;\n                    }\n                    ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;\n                    children = Component(props, secondArg);\n                }while (didScheduleRenderPhaseUpdateDuringThisPass);\n            } // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n            {\n                workInProgress._debugHookTypes = hookTypesDev;\n            }\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                currentHookNameInDev = null;\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n                // render. If this fires, it suggests that we incorrectly reset the static\n                // flags in some other part of the codebase. This has happened before, for\n                // example, in the SuspenseList implementation.\n                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n                // and creates false positives. To make this work in legacy mode, we'd\n                // need to mark fibers that commit in an incomplete state, somehow. For\n                // now I'll disable the warning that most of the bugs that would trigger\n                // it are either exclusive to concurrent mode or exist in both.\n                (current.mode & ConcurrentMode) !== NoMode) {\n                    error(\"Internal React error: Expected static flag was missing. Please \" + \"notify the React team.\");\n                }\n            }\n            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n            // localIdCounter = 0;\n            if (didRenderTooFewHooks) {\n                throw new Error(\"Rendered fewer hooks than expected. This may be caused by an accidental \" + \"early return statement.\");\n            }\n            return children;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every renderWithHooks call.\n            // Conceptually, it's part of the return value of renderWithHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            localIdCounter = 0;\n            return didRenderIdHook;\n        }\n        function bailoutHooks(current, workInProgress, lanes) {\n            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n            // complete phase (bubbleProperties).\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n            } else {\n                workInProgress.flags &= ~(Passive | Update);\n            }\n            current.lanes = removeLanes(current.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n            // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n            if (didScheduleRenderPhaseUpdate) {\n                // There were render phase updates. These are only valid for this render\n                // phase, which we are now aborting. Remove the updates from the queues so\n                // they do not persist to the next render. Do not remove updates from hooks\n                // that weren't processed.\n                //\n                // Only reset the updates from the queue if it has a clone. If it does\n                // not have a clone, that means it wasn't processed, and the updates were\n                // scheduled before we entered the render phase.\n                var hook = currentlyRenderingFiber$1.memoizedState;\n                while(hook !== null){\n                    var queue = hook.queue;\n                    if (queue !== null) {\n                        queue.pending = null;\n                    }\n                    hook = hook.next;\n                }\n                didScheduleRenderPhaseUpdate = false;\n            }\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1;\n                currentHookNameInDev = null;\n                isUpdatingOpaqueValueInRenderPhase = false;\n            }\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n        }\n        function mountWorkInProgressHook() {\n            var hook = {\n                memoizedState: null,\n                baseState: null,\n                baseQueue: null,\n                queue: null,\n                next: null\n            };\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n            } else {\n                // Append to the end of the list\n                workInProgressHook = workInProgressHook.next = hook;\n            }\n            return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n            // This function is used both for updates and for re-renders triggered by a\n            // render phase update. It assumes there is either a current hook we can\n            // clone, or a work-in-progress hook from a previous render pass that we can\n            // use as a base. When we reach the end of the base list, we must switch to\n            // the dispatcher used for mounts.\n            var nextCurrentHook;\n            if (currentHook === null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    nextCurrentHook = current.memoizedState;\n                } else {\n                    nextCurrentHook = null;\n                }\n            } else {\n                nextCurrentHook = currentHook.next;\n            }\n            var nextWorkInProgressHook;\n            if (workInProgressHook === null) {\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n            } else {\n                nextWorkInProgressHook = workInProgressHook.next;\n            }\n            if (nextWorkInProgressHook !== null) {\n                // There's already a work-in-progress. Reuse it.\n                workInProgressHook = nextWorkInProgressHook;\n                nextWorkInProgressHook = workInProgressHook.next;\n                currentHook = nextCurrentHook;\n            } else {\n                // Clone from the current hook.\n                if (nextCurrentHook === null) {\n                    throw new Error(\"Rendered more hooks than during the previous render.\");\n                }\n                currentHook = nextCurrentHook;\n                var newHook = {\n                    memoizedState: currentHook.memoizedState,\n                    baseState: currentHook.baseState,\n                    baseQueue: currentHook.baseQueue,\n                    queue: currentHook.queue,\n                    next: null\n                };\n                if (workInProgressHook === null) {\n                    // This is the first hook in the list.\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n                } else {\n                    // Append to the end of the list.\n                    workInProgressHook = workInProgressHook.next = newHook;\n                }\n            }\n            return workInProgressHook;\n        }\n        function createFunctionComponentUpdateQueue() {\n            return {\n                lastEffect: null,\n                stores: null\n            };\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe: Flow doesn't like mixed types\n            return typeof action === \"function\" ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n            var hook = mountWorkInProgressHook();\n            var initialState;\n            if (init !== undefined) {\n                initialState = init(initialArg);\n            } else {\n                initialState = initialArg;\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                interleaved: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: reducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n            }\n            queue.lastRenderedReducer = reducer;\n            var current = currentHook; // The last rebase update that is NOT part of the base state.\n            var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n            var pendingQueue = queue.pending;\n            if (pendingQueue !== null) {\n                // We have new updates that haven't been processed yet.\n                // We'll add them to the base queue.\n                if (baseQueue !== null) {\n                    // Merge the pending queue and the base queue.\n                    var baseFirst = baseQueue.next;\n                    var pendingFirst = pendingQueue.next;\n                    baseQueue.next = pendingFirst;\n                    pendingQueue.next = baseFirst;\n                }\n                {\n                    if (current.baseQueue !== baseQueue) {\n                        // Internal invariant that should never happen, but feasibly could in\n                        // the future if we implement resuming, or some form of that.\n                        error(\"Internal error: Expected work-in-progress queue to be a clone. \" + \"This is a bug in React.\");\n                    }\n                }\n                current.baseQueue = baseQueue = pendingQueue;\n                queue.pending = null;\n            }\n            if (baseQueue !== null) {\n                // We have a queue to process.\n                var first = baseQueue.next;\n                var newState = current.baseState;\n                var newBaseState = null;\n                var newBaseQueueFirst = null;\n                var newBaseQueueLast = null;\n                var update = first;\n                do {\n                    var updateLane = update.lane;\n                    if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            action: update.action,\n                            hasEagerState: update.hasEagerState,\n                            eagerState: update.eagerState,\n                            next: null\n                        };\n                        if (newBaseQueueLast === null) {\n                            newBaseQueueFirst = newBaseQueueLast = clone;\n                            newBaseState = newState;\n                        } else {\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\n                        } // Update the remaining priority in the queue.\n                        // TODO: Don't need to accumulate this. Instead, we can remove\n                        // renderLanes from the original lanes.\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                        markSkippedUpdateLanes(updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        if (newBaseQueueLast !== null) {\n                            var _clone = {\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                action: update.action,\n                                hasEagerState: update.hasEagerState,\n                                eagerState: update.eagerState,\n                                next: null\n                            };\n                            newBaseQueueLast = newBaseQueueLast.next = _clone;\n                        } // Process this update.\n                        if (update.hasEagerState) {\n                            // If this update is a state update (not a reducer) and was processed eagerly,\n                            // we can use the eagerly computed state\n                            newState = update.eagerState;\n                        } else {\n                            var action = update.action;\n                            newState = reducer(newState, action);\n                        }\n                    }\n                    update = update.next;\n                }while (update !== null && update !== first);\n                if (newBaseQueueLast === null) {\n                    newBaseState = newState;\n                } else {\n                    newBaseQueueLast.next = newBaseQueueFirst;\n                } // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState;\n                hook.baseState = newBaseState;\n                hook.baseQueue = newBaseQueueLast;\n                queue.lastRenderedState = newState;\n            } // Interleaved updates are stored on a separate queue. We aren't going to\n            // process them during this render, but we do need to track which lanes\n            // are remaining.\n            var lastInterleaved = queue.interleaved;\n            if (lastInterleaved !== null) {\n                var interleaved = lastInterleaved;\n                do {\n                    var interleavedLane = interleaved.lane;\n                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n                    markSkippedUpdateLanes(interleavedLane);\n                    interleaved = interleaved.next;\n                }while (interleaved !== lastInterleaved);\n            } else if (baseQueue === null) {\n                // `queue.lanes` is used for entangling transitions. We can set it back to\n                // zero once the queue is empty.\n                queue.lanes = NoLanes;\n            }\n            var dispatch = queue.dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n            }\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n            // work-in-progress hook.\n            var dispatch = queue.dispatch;\n            var lastRenderPhaseUpdate = queue.pending;\n            var newState = hook.memoizedState;\n            if (lastRenderPhaseUpdate !== null) {\n                // The queue doesn't persist past this render pass.\n                queue.pending = null;\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                var update = firstRenderPhaseUpdate;\n                do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var action = update.action;\n                    newState = reducer(newState, action);\n                    update = update.next;\n                }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n                // the base state unless the queue is empty.\n                // TODO: Not sure if this is the desired semantics, but it's what we\n                // do for gDSFP. I can't remember why.\n                if (hook.baseQueue === null) {\n                    hook.baseState = newState;\n                }\n                queue.lastRenderedState = newState;\n            }\n            return [\n                newState,\n                dispatch\n            ];\n        }\n        function mountMutableSource(source, getSnapshot, subscribe) {\n            {\n                return undefined;\n            }\n        }\n        function updateMutableSource(source, getSnapshot, subscribe) {\n            {\n                return undefined;\n            }\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = mountWorkInProgressHook();\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                if (getServerSnapshot === undefined) {\n                    throw new Error(\"Missing getServerSnapshot, which is required for \" + \"server-rendered content. Will revert to client rendering.\");\n                }\n                nextSnapshot = getServerSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        if (nextSnapshot !== getServerSnapshot()) {\n                            error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                //\n                // We won't do this if we're hydrating server-rendered content, because if\n                // the content is stale, it's already visible anyway. Instead we'll patch\n                // it up in a passive effect.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                }\n                if (!includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            } // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            hook.memoizedState = nextSnapshot;\n            var inst = {\n                value: nextSnapshot,\n                getSnapshot: getSnapshot\n            };\n            hook.queue = inst; // Schedule an effect to subscribe to the store.\n            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Schedule an effect to update the mutable instance fields. We will update\n            // this whenever subscribe, getSnapshot, or value changes. Because there's no\n            // clean-up function, and we track the deps correctly, we can call pushEffect\n            // directly, without storing any additional state. For the same reason, we\n            // don't need to set a static flag, either.\n            // TODO: We can move this to the passive phase once we add a pre-commit\n            // consistency check. See the next comment.\n            fiber.flags |= Passive;\n            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n            return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            var nextSnapshot = getSnapshot();\n            {\n                if (!didWarnUncachedGetSnapshot) {\n                    var cachedSnapshot = getSnapshot();\n                    if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                        error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                        didWarnUncachedGetSnapshot = true;\n                    }\n                }\n            }\n            var prevSnapshot = hook.memoizedState;\n            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n            if (snapshotChanged) {\n                hook.memoizedState = nextSnapshot;\n                markWorkInProgressReceivedUpdate();\n            }\n            var inst = hook.queue;\n            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Whenever getSnapshot or subscribe changes, we need to check in the\n            // commit phase if there was an interleaved mutation. In concurrent mode\n            // this can happen all the time, but even in synchronous mode, an earlier\n            // effect may have mutated the store.\n            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n            // checking whether we scheduled a subscription effect above.\n            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n                fiber.flags |= Passive;\n                pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                }\n                if (!includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            }\n            return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n            fiber.flags |= StoreConsistency;\n            var check = {\n                getSnapshot: getSnapshot,\n                value: renderedSnapshot\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.stores = [\n                    check\n                ];\n            } else {\n                var stores = componentUpdateQueue.stores;\n                if (stores === null) {\n                    componentUpdateQueue.stores = [\n                        check\n                    ];\n                } else {\n                    stores.push(check);\n                }\n            }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n            // These are updated in the passive phase\n            inst.value = nextSnapshot;\n            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n            // have been in an event that fired before the passive effects, or it could\n            // have been in a layout effect. In that case, we would have used the old\n            // snapsho and getSnapshot values to bail out. We need to check one more time.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceStoreRerender(fiber);\n            }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n            var handleStoreChange = function() {\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceStoreRerender(fiber);\n                }\n            }; // Subscribe to the store and return a clean-up function.\n            return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function forceStoreRerender(fiber) {\n            scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n        }\n        function mountState(initialState) {\n            var hook = mountWorkInProgressHook();\n            if (typeof initialState === \"function\") {\n                // $FlowFixMe: Flow doesn't like mixed types\n                initialState = initialState();\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                interleaved: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateState(initialState) {\n            return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n            return rerenderReducer(basicStateReducer);\n        }\n        function pushEffect(tag, create, destroy, deps) {\n            var effect = {\n                tag: tag,\n                create: create,\n                destroy: destroy,\n                deps: deps,\n                // Circular\n                next: null\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n                var lastEffect = componentUpdateQueue.lastEffect;\n                if (lastEffect === null) {\n                    componentUpdateQueue.lastEffect = effect.next = effect;\n                } else {\n                    var firstEffect = lastEffect.next;\n                    lastEffect.next = effect;\n                    effect.next = firstEffect;\n                    componentUpdateQueue.lastEffect = effect;\n                }\n            }\n            return effect;\n        }\n        function mountRef(initialValue) {\n            var hook = mountWorkInProgressHook();\n            {\n                var _ref2 = {\n                    current: initialValue\n                };\n                hook.memoizedState = _ref2;\n                return _ref2;\n            }\n        }\n        function updateRef(initialValue) {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var destroy = undefined;\n            if (currentHook !== null) {\n                var prevEffect = currentHook.memoizedState;\n                destroy = prevEffect.destroy;\n                if (nextDeps !== null) {\n                    var prevDeps = prevEffect.deps;\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n                        return;\n                    }\n                }\n            }\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n        }\n        function mountEffect(create, deps) {\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n            } else {\n                return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n            }\n        }\n        function updateEffect(create, deps) {\n            return updateEffectImpl(Passive, Passive$1, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n            return mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n            return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n            var fiberFlags = Update;\n            {\n                fiberFlags |= LayoutStatic;\n            }\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n            return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n            if (typeof ref === \"function\") {\n                var refCallback = ref;\n                var _inst = create();\n                refCallback(_inst);\n                return function() {\n                    refCallback(null);\n                };\n            } else if (ref !== null && ref !== undefined) {\n                var refObject = ref;\n                {\n                    if (!refObject.hasOwnProperty(\"current\")) {\n                        error(\"Expected useImperativeHandle() first argument to either be a \" + \"ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\");\n                    }\n                }\n                var _inst2 = create();\n                refObject.current = _inst2;\n                return function() {\n                    refObject.current = null;\n                };\n            }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== \"function\") {\n                    error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            var fiberFlags = Update;\n            {\n                fiberFlags |= LayoutStatic;\n            }\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== \"function\") {\n                    error(\"Expected useImperativeHandle() second argument to be a function \" + \"that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        // The react-debug-hooks package injects its own implementation\n        // so that e.g. DevTools can display custom hook values.\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function updateCallback(callback, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (prevState !== null) {\n                if (nextDeps !== null) {\n                    var prevDeps = prevState[1];\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        return prevState[0];\n                    }\n                }\n            }\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var nextValue = nextCreate();\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (prevState !== null) {\n                // Assume these are defined. If they're not, areHookInputsEqual will warn.\n                if (nextDeps !== null) {\n                    var prevDeps = prevState[1];\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        return prevState[0];\n                    }\n                }\n            }\n            var nextValue = nextCreate();\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function mountDeferredValue(value) {\n            var _mountState = mountState(value), prevValue = _mountState[0], setValue = _mountState[1];\n            mountEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function updateDeferredValue(value) {\n            var _updateState = updateState(), prevValue = _updateState[0], setValue = _updateState[1];\n            updateEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function rerenderDeferredValue(value) {\n            var _rerenderState = rerenderState(), prevValue = _rerenderState[0], setValue = _rerenderState[1];\n            updateEffect(function() {\n                var prevTransition = ReactCurrentBatchConfig$1.transition;\n                ReactCurrentBatchConfig$1.transition = {};\n                try {\n                    setValue(value);\n                } finally{\n                    ReactCurrentBatchConfig$1.transition = prevTransition;\n                }\n            }, [\n                value\n            ]);\n            return prevValue;\n        }\n        function startTransition(setPending, callback, options) {\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n            setPending(true);\n            var prevTransition = ReactCurrentBatchConfig$1.transition;\n            ReactCurrentBatchConfig$1.transition = {};\n            var currentTransition = ReactCurrentBatchConfig$1.transition;\n            {\n                ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();\n            }\n            try {\n                setPending(false);\n                callback();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$1.transition = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        if (updatedFibersCount > 10) {\n                            warn(\"Detected a large number of updates inside startTransition. \" + \"If this is due to a subscription please re-write it to use React provided hooks. \" + \"Otherwise concurrent mode guarantees are off the table.\");\n                        }\n                        currentTransition._updatedFibers.clear();\n                    }\n                }\n            }\n        }\n        function mountTransition() {\n            var _mountState2 = mountState(false), isPending = _mountState2[0], setPending = _mountState2[1]; // The `start` method never changes.\n            var start = startTransition.bind(null, setPending);\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = start;\n            return [\n                isPending,\n                start\n            ];\n        }\n        function updateTransition() {\n            var _updateState2 = updateState(), isPending = _updateState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            return [\n                isPending,\n                start\n            ];\n        }\n        function rerenderTransition() {\n            var _rerenderState2 = rerenderState(), isPending = _rerenderState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            return [\n                isPending,\n                start\n            ];\n        }\n        var isUpdatingOpaqueValueInRenderPhase = false;\n        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n            {\n                return isUpdatingOpaqueValueInRenderPhase;\n            }\n        }\n        function mountId() {\n            var hook = mountWorkInProgressHook();\n            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n            // should do this in Fiber, too? Deferring this decision for now because\n            // there's no other place to store the prefix except for an internal field on\n            // the public createRoot object, which the fiber tree does not currently have\n            // a reference to.\n            var identifierPrefix = root.identifierPrefix;\n            var id;\n            if (getIsHydrating()) {\n                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n                id = \":\" + identifierPrefix + \"R\" + treeId; // Unless this is the first id at this level, append a number at the end\n                // that represents the position of this useId hook among all the useId\n                // hooks for this fiber.\n                var localId = localIdCounter++;\n                if (localId > 0) {\n                    id += \"H\" + localId.toString(32);\n                }\n                id += \":\";\n            } else {\n                // Use a lowercase r prefix for client-generated ids.\n                var globalClientId = globalClientIdCounter++;\n                id = \":\" + identifierPrefix + \"r\" + globalClientId.toString(32) + \":\";\n            }\n            hook.memoizedState = id;\n            return id;\n        }\n        function updateId() {\n            var hook = updateWorkInProgressHook();\n            var id = hook.memoizedState;\n            return id;\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === \"function\") {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                enqueueUpdate$1(fiber, queue, update);\n                var eventTime = requestEventTime();\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === \"function\") {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + \"second callback argument. To execute a side effect after \" + \"rendering, declare it in the component body with useEffect().\");\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                enqueueUpdate$1(fiber, queue, update);\n                var alternate = fiber.alternate;\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    var lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        var prevDispatcher;\n                        {\n                            prevDispatcher = ReactCurrentDispatcher$1.current;\n                            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                        }\n                        try {\n                            var currentState = queue.lastRenderedState;\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.hasEagerState = true;\n                            update.eagerState = eagerState;\n                            if (objectIs(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                return;\n                            }\n                        } catch (error) {} finally{\n                            {\n                                ReactCurrentDispatcher$1.current = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n                var eventTime = requestEventTime();\n                var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n                if (root !== null) {\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n            var alternate = fiber.alternate;\n            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n            var pending = queue.pending;\n            if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n            } else {\n                update.next = pending.next;\n                pending.next = update;\n            }\n            queue.pending = update;\n        }\n        function enqueueUpdate$1(fiber, queue, update, lane) {\n            if (isInterleavedUpdate(fiber)) {\n                var interleaved = queue.interleaved;\n                if (interleaved === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update; // At the end of the current render, this queue's interleaved updates will\n                    // be transferred to the pending queue.\n                    pushInterleavedQueue(queue);\n                } else {\n                    update.next = interleaved.next;\n                    interleaved.next = update;\n                }\n                queue.interleaved = update;\n            } else {\n                var pending = queue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                queue.pending = update;\n            }\n        }\n        function entangleTransitionUpdate(root, queue, lane) {\n            if (isTransitionLane(lane)) {\n                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n                // must have finished. We can remove them from the shared queue, which\n                // represents a superset of the actually pending lanes. In some cases we\n                // may entangle more than we need to, but that's OK. In fact it's worse if\n                // we *don't* entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n            {\n                markStateUpdateScheduled(fiber, lane);\n            }\n        }\n        var ContextOnlyDispatcher = {\n            readContext: readContext,\n            useCallback: throwInvalidHookError,\n            useContext: throwInvalidHookError,\n            useEffect: throwInvalidHookError,\n            useImperativeHandle: throwInvalidHookError,\n            useInsertionEffect: throwInvalidHookError,\n            useLayoutEffect: throwInvalidHookError,\n            useMemo: throwInvalidHookError,\n            useReducer: throwInvalidHookError,\n            useRef: throwInvalidHookError,\n            useState: throwInvalidHookError,\n            useDebugValue: throwInvalidHookError,\n            useDeferredValue: throwInvalidHookError,\n            useTransition: throwInvalidHookError,\n            useMutableSource: throwInvalidHookError,\n            useSyncExternalStore: throwInvalidHookError,\n            useId: throwInvalidHookError,\n            unstable_isNewReconciler: enableNewReconciler\n        };\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n            var warnInvalidContextAccess = function() {\n                error(\"Context can only be read while React is rendering. \" + \"In classes, you can read it in the render method or getDerivedStateFromProps. \" + \"In function components, you can read it directly in the function body, but not \" + \"inside Hooks like useReducer() or useMemo().\");\n            };\n            var warnInvalidHookAccess = function() {\n                error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. \" + \"You can only call Hooks at the top level of your React function. \" + \"For more information, see \" + \"https://reactjs.org/link/rules-of-hooks\");\n            };\n            HooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    mountHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    mountHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    mountHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnMountWithHookTypesInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return updateDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            HooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = \"useCallback\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = \"useContext\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = \"useEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = \"useImperativeHandle\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = \"useInsertionEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = \"useLayoutEffect\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = \"useMemo\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = \"useReducer\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = \"useRef\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = \"useState\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactCurrentDispatcher$1.current;\n                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactCurrentDispatcher$1.current = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = \"useDebugValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value) {\n                    currentHookNameInDev = \"useDeferredValue\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = \"useTransition\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useMutableSource: function(source, getSnapshot, subscribe) {\n                    currentHookNameInDev = \"useMutableSource\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateMutableSource();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = \"useSyncExternalStore\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = \"useId\";\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                },\n                unstable_isNewReconciler: enableNewReconciler\n            };\n        }\n        var now$2 = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        /**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */ var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n            return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n            {\n                nestedUpdateScheduled = true;\n            }\n        }\n        function resetNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = false;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function syncNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = nestedUpdateScheduled;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function getCommitTime() {\n            return commitTime;\n        }\n        function recordCommitTime() {\n            commitTime = now$2();\n        }\n        function startProfilerTimer(fiber) {\n            profilerStartTime = now$2();\n            if (fiber.actualStartTime < 0) {\n                fiber.actualStartTime = now$2();\n            }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n            profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n            if (profilerStartTime >= 0) {\n                var elapsedTime = now$2() - profilerStartTime;\n                fiber.actualDuration += elapsedTime;\n                if (overrideBaseTime) {\n                    fiber.selfBaseDuration = elapsedTime;\n                }\n                profilerStartTime = -1;\n            }\n        }\n        function recordLayoutEffectDuration(fiber) {\n            if (layoutEffectStartTime >= 0) {\n                var elapsedTime = now$2() - layoutEffectStartTime;\n                layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            root.effectDuration += elapsedTime;\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += elapsedTime;\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function recordPassiveEffectDuration(fiber) {\n            if (passiveEffectStartTime >= 0) {\n                var elapsedTime = now$2() - passiveEffectStartTime;\n                passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            if (root !== null) {\n                                root.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            if (parentStateNode !== null) {\n                                // Detached fibers have their state node cleared out.\n                                // In this case, the return pointer is also cleared out,\n                                // so we won't be able to report the time spent in this Profiler's subtree.\n                                parentStateNode.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function startLayoutEffectTimer() {\n            layoutEffectStartTime = now$2();\n        }\n        function startPassiveEffectTimer() {\n            passiveEffectStartTime = now$2();\n        }\n        function transferActualDuration(fiber) {\n            // Transfer time spent rendering these children so we don't lose it\n            // after we rerender. This is used as a helper in special cases\n            // where we should count the work of multiple passes.\n            var child = fiber.child;\n            while(child){\n                fiber.actualDuration += child.actualDuration;\n                child = child.sibling;\n            }\n        }\n        function createCapturedValue(value, source) {\n            // If the value is an error, call this function immediately after it is thrown\n            // so the stack is accurate.\n            return {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n        }\n        // This module is forked in different environments.\n        // By default, return `true` to log errors to the console.\n        // Forks can return `false` if this isn't desirable.\n        function showErrorDialog(boundary, errorInfo) {\n            return true;\n        }\n        function logCapturedError(boundary, errorInfo) {\n            try {\n                var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\n                // This enables renderers like ReactNative to better manage redbox behavior.\n                if (logError === false) {\n                    return;\n                }\n                var error = errorInfo.value;\n                if (true) {\n                    var source = errorInfo.source;\n                    var stack = errorInfo.stack;\n                    var componentStack = stack !== null ? stack : \"\"; // Browsers support silencing uncaught errors by calling\n                    // `preventDefault()` in window `error` handler.\n                    // We record this information as an expando on the error.\n                    if (error != null && error._suppressLogging) {\n                        if (boundary.tag === ClassComponent) {\n                            // The error is recoverable and was silenced.\n                            // Ignore it and don't print the stack addendum.\n                            // This is handy for testing error boundaries without noise.\n                            return;\n                        } // The error is fatal. Since the silencing might have\n                        // been accidental, we'll surface it anyway.\n                        // However, the browser would have silenced the original error\n                        // so we'll print it first, and then print the stack addendum.\n                        console[\"error\"](error); // Don't transform to our wrapper\n                    // For a more detailed description of this block, see:\n                    // https://github.com/facebook/react/pull/13384\n                    }\n                    var componentName = source ? getComponentNameFromFiber(source) : null;\n                    var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : \"The above error occurred in one of your React components:\";\n                    var errorBoundaryMessage;\n                    if (boundary.tag === HostRoot) {\n                        errorBoundaryMessage = \"Consider adding an error boundary to your tree to customize error handling behavior.\\n\" + \"Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\";\n                    } else {\n                        var errorBoundaryName = getComponentNameFromFiber(boundary) || \"Anonymous\";\n                        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n                    }\n                    var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n                    // We don't include the original error message and JS stack because the browser\n                    // has already printed it. Even if the application swallows the error, it is still\n                    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n                    console[\"error\"](combinedMessage); // Don't transform to our wrapper\n                } else {}\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        var PossiblyWeakMap$1 = typeof WeakMap === \"function\" ? WeakMap : Map;\n        function createRootErrorUpdate(fiber, errorInfo, lane) {\n            var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: null\n            };\n            var error = errorInfo.value;\n            update.callback = function() {\n                onUncaughtError(error);\n                logCapturedError(fiber, errorInfo);\n            };\n            return update;\n        }\n        function createClassErrorUpdate(fiber, errorInfo, lane) {\n            var update = createUpdate(NoTimestamp, lane);\n            update.tag = CaptureUpdate;\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n            if (typeof getDerivedStateFromError === \"function\") {\n                var error$1 = errorInfo.value;\n                update.payload = function() {\n                    return getDerivedStateFromError(error$1);\n                };\n                update.callback = function() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    logCapturedError(fiber, errorInfo);\n                };\n            }\n            var inst = fiber.stateNode;\n            if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n                update.callback = function callback() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    logCapturedError(fiber, errorInfo);\n                    if (typeof getDerivedStateFromError !== \"function\") {\n                        // To preserve the preexisting retry behavior of error boundaries,\n                        // we keep track of which ones already failed during this batch.\n                        // This gets reset before we yield back to the browser.\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\n                        // not defined.\n                        markLegacyErrorBoundaryAsFailed(this);\n                    }\n                    var error$1 = errorInfo.value;\n                    var stack = errorInfo.stack;\n                    this.componentDidCatch(error$1, {\n                        componentStack: stack !== null ? stack : \"\"\n                    });\n                    {\n                        if (typeof getDerivedStateFromError !== \"function\") {\n                            // If componentDidCatch is the only error boundary method defined,\n                            // then it needs to call setState to recover from errors.\n                            // If no state update is scheduled then the boundary will swallow the error.\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                                error(\"%s: Error boundaries should implement getDerivedStateFromError(). \" + \"In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n                            }\n                        }\n                    }\n                };\n            }\n            return update;\n        }\n        function attachPingListener(root, wakeable, lanes) {\n            // Attach a ping listener\n            //\n            // The data might resolve before we have a chance to commit the fallback. Or,\n            // in the case of a refresh, we'll never commit a fallback. So we need to\n            // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n            // try rendering the tree again.\n            //\n            // Only attach a listener if one does not already exist for the lanes\n            // we're currently rendering (which acts like a \"thread ID\" here).\n            //\n            // We only need to do this in concurrent mode. Legacy Suspense always\n            // commits fallbacks synchronously, so there are no pings.\n            var pingCache = root.pingCache;\n            var threadIDs;\n            if (pingCache === null) {\n                pingCache = root.pingCache = new PossiblyWeakMap$1();\n                threadIDs = new Set();\n                pingCache.set(wakeable, threadIDs);\n            } else {\n                threadIDs = pingCache.get(wakeable);\n                if (threadIDs === undefined) {\n                    threadIDs = new Set();\n                    pingCache.set(wakeable, threadIDs);\n                }\n            }\n            if (!threadIDs.has(lanes)) {\n                // Memoize using the thread ID to prevent redundant listeners.\n                threadIDs.add(lanes);\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n                {\n                    if (isDevToolsPresent) {\n                        // If we have pending work still, restore the original updaters\n                        restorePendingUpdaters(root, lanes);\n                    }\n                }\n                wakeable.then(ping, ping);\n            }\n        }\n        function attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n            // Retry listener\n            //\n            // If the fallback does commit, we need to attach a different type of\n            // listener. This one schedules an update on the Suspense boundary to turn\n            // the fallback state off.\n            //\n            // Stash the wakeable on the boundary fiber so we can access it in the\n            // commit phase.\n            //\n            // When the wakeable resolves, we'll attempt to render the boundary\n            // again (\"retry\").\n            var wakeables = suspenseBoundary.updateQueue;\n            if (wakeables === null) {\n                var updateQueue = new Set();\n                updateQueue.add(wakeable);\n                suspenseBoundary.updateQueue = updateQueue;\n            } else {\n                wakeables.add(wakeable);\n            }\n        }\n        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n            // A legacy mode Suspense quirk, only relevant to hook components.\n            var tag = sourceFiber.tag;\n            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n                var currentSource = sourceFiber.alternate;\n                if (currentSource) {\n                    sourceFiber.updateQueue = currentSource.updateQueue;\n                    sourceFiber.memoizedState = currentSource.memoizedState;\n                    sourceFiber.lanes = currentSource.lanes;\n                } else {\n                    sourceFiber.updateQueue = null;\n                    sourceFiber.memoizedState = null;\n                }\n            }\n        }\n        function getNearestSuspenseBoundaryToCapture(returnFiber) {\n            var node = returnFiber;\n            do {\n                if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n                    return node;\n                } // This boundary already captured during this render. Continue to the next\n                // boundary.\n                node = node.return;\n            }while (node !== null);\n            return null;\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n            // This marks a Suspense boundary so that when we're unwinding the stack,\n            // it captures the suspended \"exception\" and does a second (fallback) pass.\n            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n                // Legacy Mode Suspense\n                //\n                // If the boundary is in legacy mode, we should *not*\n                // suspend the commit. Pretend as if the suspended component rendered\n                // null and keep rendering. When the Suspense boundary completes,\n                // we'll do a second pass to render the fallback.\n                if (suspenseBoundary === returnFiber) {\n                    // Special case where we suspended while reconciling the children of\n                    // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n                    // when a React.lazy component is a direct child of a\n                    // Suspense boundary.\n                    //\n                    // Suspense boundaries are implemented as multiple fibers, but they\n                    // are a single conceptual unit. The legacy mode behavior where we\n                    // pretend the suspended fiber committed as `null` won't work,\n                    // because in this case the \"suspended\" fiber is the inner\n                    // Offscreen wrapper.\n                    //\n                    // Because the contents of the boundary haven't started rendering\n                    // yet (i.e. nothing in the tree has partially rendered) we can\n                    // switch to the regular, concurrent mode behavior: mark the\n                    // boundary with ShouldCapture and enter the unwind phase.\n                    suspenseBoundary.flags |= ShouldCapture;\n                } else {\n                    suspenseBoundary.flags |= DidCapture;\n                    sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n                    // But we shouldn't call any lifecycle methods or callbacks. Remove\n                    // all lifecycle effect tags.\n                    sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n                    if (supportsPersistence && enablePersistentOffscreenHostContainer) {\n                        // Another legacy Suspense quirk. In persistent mode, if this is the\n                        // initial mount, override the props of the host container to hide\n                        // its contents.\n                        var currentSuspenseBoundary = suspenseBoundary.alternate;\n                        if (currentSuspenseBoundary === null) {\n                            var offscreenFiber = suspenseBoundary.child;\n                            var offscreenContainer = offscreenFiber.child;\n                            if (offscreenContainer !== null) {\n                                var children = offscreenContainer.memoizedProps.children;\n                                var containerProps = getOffscreenContainerProps(\"hidden\", children);\n                                offscreenContainer.pendingProps = containerProps;\n                                offscreenContainer.memoizedProps = containerProps;\n                            }\n                        }\n                    }\n                    if (sourceFiber.tag === ClassComponent) {\n                        var currentSourceFiber = sourceFiber.alternate;\n                        if (currentSourceFiber === null) {\n                            // This is a new mount. Change the tag so it's not mistaken for a\n                            // completed class component. For example, we should not call\n                            // componentWillUnmount if it is deleted.\n                            sourceFiber.tag = IncompleteClassComponent;\n                        } else {\n                            // When we try rendering again, we should not reuse the current fiber,\n                            // since it's known to be in an inconsistent state. Use a force update to\n                            // prevent a bail out.\n                            var update = createUpdate(NoTimestamp, SyncLane);\n                            update.tag = ForceUpdate;\n                            enqueueUpdate(sourceFiber, update);\n                        }\n                    } // The source fiber did not complete. Mark it with Sync priority to\n                    // indicate that it still has pending work.\n                    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n                }\n                return suspenseBoundary;\n            } // Confirmed that the boundary is in a concurrent mode tree. Continue\n            // with the normal suspend path.\n            //\n            // After this we'll use a set of heuristics to determine whether this\n            // render pass will run to completion or restart or \"suspend\" the commit.\n            // The actual logic for this is spread out in different places.\n            //\n            // This first principle is that if we're going to suspend when we complete\n            // a root, then we should also restart if we get an update or ping that\n            // might unsuspend it, and vice versa. The only reason to suspend is\n            // because you think you might want to restart before committing. However,\n            // it doesn't make sense to restart only while in the period we're suspended.\n            //\n            // Restarting too aggressively is also not good because it starves out any\n            // intermediate loading state. So we use heuristics to determine when.\n            // Suspense Heuristics\n            //\n            // If nothing threw a Promise or all the same fallbacks are already showing,\n            // then don't suspend/restart.\n            //\n            // If this is an initial render of a new tree of Suspense boundaries and\n            // those trigger a fallback, then don't suspend/restart. We want to ensure\n            // that we can show the initial loading state as quickly as possible.\n            //\n            // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n            // a fallback, then we should always suspend/restart. Transitions apply\n            // to this case. If none is defined, JND is used instead.\n            //\n            // If we're already showing a fallback and it gets \"retried\", allowing us to show\n            // another level, but there's still an inner boundary that would show a fallback,\n            // then we suspend/restart for 500ms since the last time we showed a fallback\n            // anywhere in the tree. This effectively throttles progressive loading into a\n            // consistent train of commits. This also gives us an opportunity to restart to\n            // get to the completed state slightly earlier.\n            //\n            // If there's ambiguity due to batching it's resolved in preference of:\n            // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n            //\n            // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n            // ensure that new initial loading states can commit as soon as possible.\n            suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n            // the begin phase to prevent an early bailout.\n            suspenseBoundary.lanes = rootRenderLanes;\n            return suspenseBoundary;\n        }\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n            // The source fiber did not complete.\n            sourceFiber.flags |= Incomplete;\n            {\n                if (isDevToolsPresent) {\n                    // If we have pending work still, restore the original updaters\n                    restorePendingUpdaters(root, rootRenderLanes);\n                }\n            }\n            if (value !== null && typeof value === \"object\" && typeof value.then === \"function\") {\n                // This is a wakeable. The component suspended.\n                var wakeable = value;\n                resetSuspendedComponent(sourceFiber);\n                var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n                if (suspenseBoundary !== null) {\n                    suspenseBoundary.flags &= ~ForceClientRender;\n                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n                    // commits fallbacks synchronously, so there are no pings.\n                    if (suspenseBoundary.mode & ConcurrentMode) {\n                        attachPingListener(root, wakeable, rootRenderLanes);\n                    }\n                    attachRetryListener(suspenseBoundary, root, wakeable);\n                    return;\n                } else {\n                    // No boundary was found. Unless this is a sync update, this is OK.\n                    // We can suspend and wait for more data to arrive.\n                    if (!includesSyncLane(rootRenderLanes)) {\n                        // This is not a sync update. Suspend. Since we're not activating a\n                        // Suspense boundary, this will unwind all the way to the root without\n                        // performing a second pass to render a fallback. (This is arguably how\n                        // refresh transitions should work, too, since we're not going to commit\n                        // the fallbacks anyway.)\n                        //\n                        // This case also applies to initial hydration.\n                        attachPingListener(root, wakeable, rootRenderLanes);\n                        renderDidSuspendDelayIfPossible();\n                        return;\n                    } // This is a sync/discrete update. We treat this case like an error\n                    // because discrete renders are expected to produce a complete tree\n                    // synchronously to maintain consistency with external state.\n                    var uncaughtSuspenseError = new Error(\"A component suspended while responding to synchronous input. This \" + \"will cause the UI to be replaced with a loading indicator. To \" + \"fix, updates that suspend should be wrapped \" + \"with startTransition.\"); // If we're outside a transition, fall through to the regular error path.\n                    // The error will be caught by the nearest suspense boundary.\n                    value = uncaughtSuspenseError;\n                }\n            } else {\n                // This is a regular error, not a Suspense wakeable.\n                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n                    markDidSuspendWhileHydratingDEV();\n                    var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n                    // discarding the dehydrated content and switching to a client render.\n                    // Instead of surfacing the error, find the nearest Suspense boundary\n                    // and render it again without hydration.\n                    if (_suspenseBoundary !== null) {\n                        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n                            // Set a flag to indicate that we should try rendering the normal\n                            // children again, not the fallback.\n                            _suspenseBoundary.flags |= ForceClientRender;\n                        }\n                        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n                        // still log it so it can be fixed.\n                        queueHydrationError(value);\n                        return;\n                    }\n                }\n            } // We didn't find a boundary that could handle this type of exception. Start\n            // over and traverse parent path again, this time treating the exception\n            // as an error.\n            renderDidError(value);\n            value = createCapturedValue(value, sourceFiber);\n            var workInProgress = returnFiber;\n            do {\n                switch(workInProgress.tag){\n                    case HostRoot:\n                        {\n                            var _errorInfo = value;\n                            workInProgress.flags |= ShouldCapture;\n                            var lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n                            var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\n                            enqueueCapturedUpdate(workInProgress, update);\n                            return;\n                        }\n                    case ClassComponent:\n                        // Capture and retry\n                        var errorInfo = value;\n                        var ctor = workInProgress.type;\n                        var instance = workInProgress.stateNode;\n                        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === \"function\" || instance !== null && typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\n                            var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);\n                            enqueueCapturedUpdate(workInProgress, _update);\n                            return;\n                        }\n                        break;\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress !== null);\n        }\n        function getSuspendedCache() {\n            {\n                return null;\n            }\n        }\n        function markUpdate(workInProgress) {\n            // Tag the fiber with an update effect. This turns a Placement into\n            // a PlacementAndUpdate.\n            workInProgress.flags |= Update;\n        }\n        function markRef(workInProgress) {\n            workInProgress.flags |= Ref;\n            {\n                workInProgress.flags |= RefStatic;\n            }\n        }\n        function hadNoMutationsEffects(current, completedWork) {\n            var didBailout = current !== null && current.child === completedWork.child;\n            if (didBailout) {\n                return true;\n            }\n            if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n                return false;\n            } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n            // then we only have to check the `completedWork.subtreeFlags`.\n            var child = completedWork.child;\n            while(child !== null){\n                if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n                    return false;\n                }\n                child = child.sibling;\n            }\n            return true;\n        }\n        var appendAllChildren;\n        var updateHostContainer;\n        var updateHostComponent;\n        var updateHostText;\n        if (supportsMutation) {\n            // Mutation mode\n            appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent || node.tag === HostText) {\n                        appendInitialChild(parent, node.stateNode);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            };\n            updateHostContainer = function(current, workInProgress) {};\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                if (oldProps === newProps) {\n                    // In mutation mode, this is sufficient for a bailout because\n                    // we won't touch this node even if children changed.\n                    return;\n                } // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n                // component is hitting the resume path. Figure out why. Possibly\n                // related to `hidden`.\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n                workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n                // is a new ref we mark this as an update. All the work is done in commitWork.\n                if (updatePayload) {\n                    markUpdate(workInProgress);\n                }\n            };\n            updateHostText = function(current, workInProgress, oldText, newText) {\n                // If the text differs, mark it as an update. All the work in done in commitWork.\n                if (oldText !== newText) {\n                    markUpdate(workInProgress);\n                }\n            };\n        } else if (supportsPersistence) {\n            // Persistent host tree mode\n            appendAllChildren = function(parent, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    // eslint-disable-next-line no-labels\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props, node);\n                        }\n                        appendInitialChild(parent, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance = cloneHiddenTextInstance(_instance, text, node);\n                        }\n                        appendInitialChild(parent, _instance);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        }\n                        {\n                            appendAllChildren(parent, node, true, true);\n                        }\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n            var appendAllChildrenToContainer = function(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    // eslint-disable-next-line no-labels\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props, node);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance2 = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance2 = cloneHiddenTextInstance(_instance2, text, node);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, _instance2);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        }\n                        {\n                            appendAllChildrenToContainer(containerChildSet, node, true, true);\n                        }\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            };\n            updateHostContainer = function(current, workInProgress) {\n                var portalOrRoot = workInProgress.stateNode;\n                var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n                if (childrenUnchanged) ;\n                else {\n                    var container = portalOrRoot.containerInfo;\n                    var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n                    portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n                    markUpdate(workInProgress);\n                    finalizeContainerChildren(container, newChildSet);\n                }\n            };\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {\n                var currentInstance = current.stateNode;\n                var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n                // This guarantees that we can reuse all of them.\n                var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n                if (childrenUnchanged && oldProps === newProps) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var recyclableInstance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = null;\n                if (oldProps !== newProps) {\n                    updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n                }\n                if (childrenUnchanged && updatePayload === null) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n                if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n                    markUpdate(workInProgress);\n                }\n                workInProgress.stateNode = newInstance;\n                if (childrenUnchanged) {\n                    // If there are no other effects in this tree, we need to flag this node as having one.\n                    // Even though we're not going to use it for anything.\n                    // Otherwise parents won't know that there are new children to propagate upwards.\n                    markUpdate(workInProgress);\n                } else {\n                    // If children might have changed, we have to add them all to the set.\n                    appendAllChildren(newInstance, workInProgress, false, false);\n                }\n            };\n            updateHostText = function(current, workInProgress, oldText, newText) {\n                if (oldText !== newText) {\n                    // If the text content differs, we'll create a new text instance for it.\n                    var rootContainerInstance = getRootHostContainer();\n                    var currentHostContext = getHostContext();\n                    workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n                    // This lets the parents know that at least one of their children has changed.\n                    markUpdate(workInProgress);\n                } else {\n                    workInProgress.stateNode = current.stateNode;\n                }\n            };\n        } else {\n            // No host operations\n            updateHostContainer = function(current, workInProgress) {};\n            updateHostComponent = function(current, workInProgress, type, newProps, rootContainerInstance) {};\n            updateHostText = function(current, workInProgress, oldText, newText) {};\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n            if (getIsHydrating()) {\n                // If we're hydrating, we should consume as many items as we can\n                // so we don't leave any behind.\n                return;\n            }\n            switch(renderState.tailMode){\n                case \"hidden\":\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var tailNode = renderState.tail;\n                        var lastTailNode = null;\n                        while(tailNode !== null){\n                            if (tailNode.alternate !== null) {\n                                lastTailNode = tailNode;\n                            }\n                            tailNode = tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            renderState.tail = null;\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n                case \"collapsed\":\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var _tailNode = renderState.tail;\n                        var _lastTailNode = null;\n                        while(_tailNode !== null){\n                            if (_tailNode.alternate !== null) {\n                                _lastTailNode = _tailNode;\n                            }\n                            _tailNode = _tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (_lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\n                                // We suspended during the head. We want to show at least one\n                                // row at the tail. So we'll keep on and cut off the rest.\n                                renderState.tail.sibling = null;\n                            } else {\n                                renderState.tail = null;\n                            }\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            _lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n            }\n        }\n        function bubbleProperties(completedWork) {\n            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n            var newChildLanes = NoLanes;\n            var subtreeFlags = NoFlags;\n            if (!didBailout) {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var actualDuration = completedWork.actualDuration;\n                    var treeBaseDuration = completedWork.selfBaseDuration;\n                    var child = completedWork.child;\n                    while(child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                        subtreeFlags |= child.subtreeFlags;\n                        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n                        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n                        // When work is done, it should bubble to the parent's actualDuration. If\n                        // the fiber has not been cloned though, (meaning no work was done), then\n                        // this value will reflect the amount of time spent working on a previous\n                        // render. In that case it should not bubble. We determine whether it was\n                        // cloned by comparing the child pointer.\n                        actualDuration += child.actualDuration;\n                        treeBaseDuration += child.treeBaseDuration;\n                        child = child.sibling;\n                    }\n                    completedWork.actualDuration = actualDuration;\n                    completedWork.treeBaseDuration = treeBaseDuration;\n                } else {\n                    var _child = completedWork.child;\n                    while(_child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                        subtreeFlags |= _child.subtreeFlags;\n                        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child.return = completedWork;\n                        _child = _child.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            } else {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var _treeBaseDuration = completedWork.selfBaseDuration;\n                    var _child2 = completedWork.child;\n                    while(_child2 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child2.flags & StaticMask;\n                        _treeBaseDuration += _child2.treeBaseDuration;\n                        _child2 = _child2.sibling;\n                    }\n                    completedWork.treeBaseDuration = _treeBaseDuration;\n                } else {\n                    var _child3 = completedWork.child;\n                    while(_child3 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child3.return = completedWork;\n                        _child3 = _child3.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            }\n            completedWork.childLanes = newChildLanes;\n            return didBailout;\n        }\n        function completeWork(current, workInProgress, renderLanes) {\n            var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case IndeterminateComponent:\n                case LazyComponent:\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                case ForwardRef:\n                case Fragment:\n                case Mode:\n                case Profiler:\n                case ContextConsumer:\n                case MemoComponent:\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            popContext(workInProgress);\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        var fiberRoot = workInProgress.stateNode;\n                        popHostContainer(workInProgress);\n                        popTopLevelContextObject(workInProgress);\n                        resetWorkInProgressVersions();\n                        if (fiberRoot.pendingContext) {\n                            fiberRoot.context = fiberRoot.pendingContext;\n                            fiberRoot.pendingContext = null;\n                        }\n                        if (current === null || current.child === null) {\n                            // If we hydrated, pop so that we can delete any remaining children\n                            // that weren't hydrated.\n                            var wasHydrated = popHydrationState(workInProgress);\n                            if (wasHydrated) {\n                                // If we hydrated, then we'll need to schedule an update for\n                                // the commit side-effects on the root.\n                                markUpdate(workInProgress);\n                            } else {\n                                if (current !== null) {\n                                    var prevState = current.memoizedState;\n                                    if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                                    (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                                        // Schedule an effect to clear this container at the start of the\n                                        // next commit. This handles the case of React rendering into a\n                                        // container with previous children. It's also safe to do for\n                                        // updates too, because current.child would only be null if the\n                                        // previous render was null (so the container would already\n                                        // be empty).\n                                        workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                                        // recoverable errors during first hydration attempt. If so, add\n                                        // them to a queue so we can log them in the commit phase.\n                                        upgradeHydrationErrorsToRecoverable();\n                                    }\n                                }\n                            }\n                        }\n                        updateHostContainer(current, workInProgress);\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(workInProgress);\n                        var rootContainerInstance = getRootHostContainer();\n                        var type = workInProgress.type;\n                        if (current !== null && workInProgress.stateNode != null) {\n                            updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n                            if (current.ref !== workInProgress.ref) {\n                                markRef(workInProgress);\n                            }\n                        } else {\n                            if (!newProps) {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                                } // This can happen when we abort work.\n                                bubbleProperties(workInProgress);\n                                return null;\n                            }\n                            var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                            // \"stack\" as the parent. Then append children as we go in beginWork\n                            // or completeWork depending on whether we want to add them top->down or\n                            // bottom->up. Top->down is faster in IE11.\n                            var _wasHydrated = popHydrationState(workInProgress);\n                            if (_wasHydrated) {\n                                // TODO: Move this and createInstance step into the beginPhase\n                                // to consolidate.\n                                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n                                    // If changes to the hydrated node need to be applied at the\n                                    // commit-phase we mark this as such.\n                                    markUpdate(workInProgress);\n                                }\n                            } else {\n                                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n                                appendAllChildren(instance, workInProgress, false, false);\n                                workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n                                // (eg DOM renderer supports auto-focus for certain elements).\n                                // Make sure such renderers get scheduled for later work.\n                                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                            if (workInProgress.ref !== null) {\n                                // If there is a ref on a host node we need to schedule a callback\n                                markRef(workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostText:\n                    {\n                        var newText = newProps;\n                        if (current && workInProgress.stateNode != null) {\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                            // to schedule a side-effect to do the updates.\n                            updateHostText(current, workInProgress, oldText, newText);\n                        } else {\n                            if (typeof newText !== \"string\") {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error(\"We must have new props for new mounts. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                                } // This can happen when we abort work.\n                            }\n                            var _rootContainerInstance = getRootHostContainer();\n                            var _currentHostContext = getHostContext();\n                            var _wasHydrated2 = popHydrationState(workInProgress);\n                            if (_wasHydrated2) {\n                                if (prepareToHydrateHostTextInstance(workInProgress)) {\n                                    markUpdate(workInProgress);\n                                }\n                            } else {\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        var nextState = workInProgress.memoizedState;\n                        {\n                            if (hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n                                warnIfUnhydratedTailNodes(workInProgress);\n                                resetHydrationState();\n                                workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n                                return workInProgress;\n                            }\n                            if (nextState !== null && nextState.dehydrated !== null) {\n                                // We might be inside a hydration state the first time we're picking up this\n                                // Suspense boundary, and also after we've reentered it for further hydration.\n                                var _wasHydrated3 = popHydrationState(workInProgress);\n                                if (current === null) {\n                                    if (!_wasHydrated3) {\n                                        throw new Error(\"A dehydrated suspense component was completed without a hydrated node. \" + \"This is probably a bug in React.\");\n                                    }\n                                    prepareToHydrateHostSuspenseInstance(workInProgress);\n                                    bubbleProperties(workInProgress);\n                                    {\n                                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                            var isTimedOutSuspense = nextState !== null;\n                                            if (isTimedOutSuspense) {\n                                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                                var primaryChildFragment = workInProgress.child;\n                                                if (primaryChildFragment !== null) {\n                                                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return null;\n                                } else {\n                                    // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n                                    // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n                                    resetHydrationState();\n                                    if ((workInProgress.flags & DidCapture) === NoFlags) {\n                                        // This boundary did not suspend so it's now hydrated and unsuspended.\n                                        workInProgress.memoizedState = null;\n                                    } // If nothing suspended, we need to schedule an effect to mark this boundary\n                                    // as having hydrated so events know that they're free to be invoked.\n                                    // It's also a signal to replay events and the suspense callback.\n                                    // If something suspended, schedule an effect to attach retry listeners.\n                                    // So we might as well always mark this.\n                                    workInProgress.flags |= Update;\n                                    bubbleProperties(workInProgress);\n                                    {\n                                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                            var _isTimedOutSuspense = nextState !== null;\n                                            if (_isTimedOutSuspense) {\n                                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                                var _primaryChildFragment = workInProgress.child;\n                                                if (_primaryChildFragment !== null) {\n                                                    // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    return null;\n                                }\n                            } // Successfully completed this tree. If this was a forced client render,\n                            // there may have been recoverable errors during first hydration\n                            // attempt. If so, add them to a queue so we can log them in the\n                            // commit phase.\n                            upgradeHydrationErrorsToRecoverable();\n                        }\n                        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n                            // Something suspended. Re-render with the fallback children.\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            } // Don't bubble properties in this case.\n                            return workInProgress;\n                        }\n                        var nextDidTimeout = nextState !== null;\n                        var prevDidTimeout = false;\n                        if (current === null) {\n                            popHydrationState(workInProgress);\n                        } else {\n                            var _prevState = current.memoizedState;\n                            prevDidTimeout = _prevState !== null;\n                        }\n                        // an effect to toggle the subtree's visibility. When we switch from\n                        // fallback -> primary, the inner Offscreen fiber schedules this effect\n                        // as part of its normal complete phase. But when we switch from\n                        // primary -> fallback, the inner Offscreen fiber does not have a complete\n                        // phase. So we need to schedule its effect here.\n                        //\n                        // We also use this flag to connect/disconnect the effects, but the same\n                        // logic applies: when re-connecting, the Offscreen fiber's complete\n                        // phase will handle scheduling the effect. It's only when the fallback\n                        // is active that we have to do anything special.\n                        if (nextDidTimeout && !prevDidTimeout) {\n                            var _offscreenFiber = workInProgress.child;\n                            _offscreenFiber.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n                            // in the concurrent tree already suspended during this render.\n                            // This is a known bug.\n                            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n                                // TODO: Move this back to throwException because this is too late\n                                // if this is a large tree which is common for initial loads. We\n                                // don't know if we should restart a render or not until we get\n                                // this marker, and this is too late.\n                                // If this render already had a ping or lower pri updates,\n                                // and this is the first time we know we're going to suspend we\n                                // should be able to immediately restart from within throwException.\n                                var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n                                if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                                    // If this was in an invisible tree or a new render, then showing\n                                    // this boundary is ok.\n                                    renderDidSuspend();\n                                } else {\n                                    // Otherwise, we're going to have to hide content so we should\n                                    // suspend for longer if possible.\n                                    renderDidSuspendDelayIfPossible();\n                                }\n                            }\n                        }\n                        var wakeables = workInProgress.updateQueue;\n                        if (wakeables !== null) {\n                            // Schedule an effect to attach a retry listener to the promise.\n                            // TODO: Move to passive phase\n                            workInProgress.flags |= Update;\n                        }\n                        bubbleProperties(workInProgress);\n                        {\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                if (nextDidTimeout) {\n                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                    var _primaryChildFragment2 = workInProgress.child;\n                                    if (_primaryChildFragment2 !== null) {\n                                        // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                                        workInProgress.treeBaseDuration -= _primaryChildFragment2.treeBaseDuration;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    updateHostContainer(current, workInProgress);\n                    if (current === null) {\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ContextProvider:\n                    // Pop provider fiber\n                    var context = workInProgress.type._context;\n                    popProvider(context, workInProgress);\n                    bubbleProperties(workInProgress);\n                    return null;\n                case IncompleteClassComponent:\n                    {\n                        // Same as class component case. I put it down here so that the tags are\n                        // sequential to ensure this switch is compiled to a jump table.\n                        var _Component = workInProgress.type;\n                        if (isContextProvider(_Component)) {\n                            popContext(workInProgress);\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState === null) {\n                            // We're running in the default, \"independent\" mode.\n                            // We don't do anything in this mode.\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n                        var renderedTail = renderState.rendering;\n                        if (renderedTail === null) {\n                            // We just rendered the head.\n                            if (!didSuspendAlready) {\n                                // This is the first pass. We need to figure out if anything is still\n                                // suspended in the rendered set.\n                                // If new content unsuspended, but there's still some content that\n                                // didn't. Then we need to do a second pass that forces everything\n                                // to keep showing their fallbacks.\n                                // We might be suspended if something in this render pass suspended, or\n                                // something in the previous committed pass suspended. Otherwise,\n                                // there's no chance so we can skip the expensive call to\n                                // findFirstSuspended.\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n                                if (!cannotBeSuspended) {\n                                    var row = workInProgress.child;\n                                    while(row !== null){\n                                        var suspended = findFirstSuspended(row);\n                                        if (suspended !== null) {\n                                            didSuspendAlready = true;\n                                            workInProgress.flags |= DidCapture;\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                                            // part of the second pass. In that case nothing will subscribe to\n                                            // its thenables. Instead, we'll transfer its thenables to the\n                                            // SuspenseList so that it can retry if they resolve.\n                                            // There might be multiple of these in the list but since we're\n                                            // going to wait for all of them anyway, it doesn't really matter\n                                            // which ones gets to ping. In theory we could get clever and keep\n                                            // track of how many dependencies remain but it gets tricky because\n                                            // in the meantime, we can add/remove/change items and dependencies.\n                                            // We might bail out of the loop before finding any but that\n                                            // doesn't matter since that means that the other boundaries that\n                                            // we did find already has their listeners attached.\n                                            var newThenables = suspended.updateQueue;\n                                            if (newThenables !== null) {\n                                                workInProgress.updateQueue = newThenables;\n                                                workInProgress.flags |= Update;\n                                            } // Rerender the whole list, but this time, we'll force fallbacks\n                                            // to stay in place.\n                                            // Reset the effect flags before doing the second pass since that's now invalid.\n                                            // Reset the child fibers to their original state.\n                                            workInProgress.subtreeFlags = NoFlags;\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                                            // rerender the children.\n                                            pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n                                            return workInProgress.child;\n                                        }\n                                        row = row.sibling;\n                                    }\n                                }\n                                if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n                                    // We have already passed our CPU deadline but we still have rows\n                                    // left in the tail. We'll just give up further attempts to render\n                                    // the main content and only render fallbacks.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            } else {\n                                cutOffTailIfNeeded(renderState, false);\n                            } // Next we're going to render the tail.\n                        } else {\n                            // Append the rendered row to the child list.\n                            if (!didSuspendAlready) {\n                                var _suspended = findFirstSuspended(renderedTail);\n                                if (_suspended !== null) {\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n                                    // get lost if this row ends up dropped during a second pass.\n                                    var _newThenables = _suspended.updateQueue;\n                                    if (_newThenables !== null) {\n                                        workInProgress.updateQueue = _newThenables;\n                                        workInProgress.flags |= Update;\n                                    }\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\n                                    if (renderState.tail === null && renderState.tailMode === \"hidden\" && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n                                    ) {\n                                        // We're done.\n                                        bubbleProperties(workInProgress);\n                                        return null;\n                                    }\n                                } else if (// time we have to render. So rendering one more row would likely\n                                // exceed it.\n                                now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n                                    // We have now passed our CPU deadline and we'll just give up further\n                                    // attempts to render the main content and only render fallbacks.\n                                    // The assumption is that this is usually faster.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            }\n                            if (renderState.isBackwards) {\n                                // The effect list of the backwards tail will have been added\n                                // to the end. This breaks the guarantee that life-cycles fire in\n                                // sibling order but that isn't a strong guarantee promised by React.\n                                // Especially since these might also just pop in during future commits.\n                                // Append to the beginning of the list.\n                                renderedTail.sibling = workInProgress.child;\n                                workInProgress.child = renderedTail;\n                            } else {\n                                var previousSibling = renderState.last;\n                                if (previousSibling !== null) {\n                                    previousSibling.sibling = renderedTail;\n                                } else {\n                                    workInProgress.child = renderedTail;\n                                }\n                                renderState.last = renderedTail;\n                            }\n                        }\n                        if (renderState.tail !== null) {\n                            // We still have tail rows to render.\n                            // Pop a row.\n                            var next = renderState.tail;\n                            renderState.rendering = next;\n                            renderState.tail = next.sibling;\n                            renderState.renderingStartTime = now$1();\n                            next.sibling = null; // Restore the context.\n                            // TODO: We can probably just avoid popping it instead and only\n                            // setting it the first time we go from not suspended to suspended.\n                            var suspenseContext = suspenseStackCursor.current;\n                            if (didSuspendAlready) {\n                                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                            } else {\n                                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n                            }\n                            pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n                            // Don't bubble properties in this case.\n                            return next;\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popRenderLanes(workInProgress);\n                        var _nextState = workInProgress.memoizedState;\n                        var nextIsHidden = _nextState !== null;\n                        if (current !== null) {\n                            var _prevState2 = current.memoizedState;\n                            var prevIsHidden = _prevState2 !== null;\n                            if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {\n                                workInProgress.flags |= Visibility;\n                            }\n                        }\n                        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n                            bubbleProperties(workInProgress);\n                        } else {\n                            // Don't bubble properties for hidden children unless we're rendering\n                            // at offscreen priority.\n                            if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n                                bubbleProperties(workInProgress);\n                                if (supportsMutation) {\n                                    // Check if there was an insertion or update in the hidden subtree.\n                                    // If so, we need to hide those nodes in the commit phase, so\n                                    // schedule a visibility effect.\n                                    if (workInProgress.subtreeFlags & (Placement | Update)) {\n                                        workInProgress.flags |= Visibility;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        return null;\n                    }\n                case TracingMarkerComponent:\n                    {\n                        return null;\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutModulePatternComponent;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutFunctionRefs;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n            didWarnAboutBadClass = {};\n            didWarnAboutModulePatternComponent = {};\n            didWarnAboutContextTypeOnFunctionComponent = {};\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\n            didWarnAboutFunctionRefs = {};\n            didWarnAboutReassigningProps = false;\n            didWarnAboutRevealOrder = {};\n            didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n            if (current === null) {\n                // If this is a fresh new component that hasn't been rendered yet, we\n                // won't update its child set by applying minimal side-effects. Instead,\n                // we will add them all to the child before it gets rendered. That means\n                // we can optimize this reconciliation pass by not tracking side-effects.\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                // If the current child is the same as the work in progress, it means that\n                // we haven't yet started any work on these children. Therefore, we use\n                // the clone algorithm to create a copy of all the current children.\n                // If we had any progressed work already, that is invalid at this point so\n                // let's throw it out.\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n            }\n        }\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n            // This function is fork of reconcileChildren. It's used in cases where we\n            // want to reconcile without matching against the existing set. This has the\n            // effect of all current children being unmounted; even if the type and key\n            // are the same, the old child is unmounted and a new child is created.\n            //\n            // To do this, we're going to go through the reconcile algorithm twice. In\n            // the first pass, we schedule a deletion for all the current children by\n            // passing null.\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n            // pass null in place of where we usually pass the current child set. This has\n            // the effect of remounting all children regardless of whether their\n            // identities match.\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n        }\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens after the first render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            var render = Component.render;\n            var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n                hasId = checkDidRenderIdHook();\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n                        hasId = checkDidRenderIdHook();\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            if (current === null) {\n                var type = Component.type;\n                if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n                Component.defaultProps === undefined) {\n                    var resolvedType = type;\n                    {\n                        resolvedType = resolveFunctionForHotReloading(type);\n                    }\n                    // and with only the default shallow comparison, we upgrade it\n                    // to a SimpleMemoComponent to allow fast path updates.\n                    workInProgress.tag = SimpleMemoComponent;\n                    workInProgress.type = resolvedType;\n                    {\n                        validateFunctionComponentInDev(workInProgress, type);\n                    }\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n                }\n                {\n                    var innerPropTypes = type.propTypes;\n                    if (innerPropTypes) {\n                        // Inner memo component props aren't currently validated in createElement.\n                        // We could move it there, but we'd still need this for lazy code path.\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(type));\n                    }\n                }\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n                child.ref = workInProgress.ref;\n                child.return = workInProgress;\n                workInProgress.child = child;\n                return child;\n            }\n            {\n                var _type = Component.type;\n                var _innerPropTypes = _type.propTypes;\n                if (_innerPropTypes) {\n                    // Inner memo component props aren't currently validated in createElement.\n                    // We could move it there, but we'd still need this for lazy code path.\n                    checkPropTypes(_innerPropTypes, nextProps, \"prop\", getComponentNameFromType(_type));\n                }\n            }\n            var currentChild = current.child; // This is always exactly one child\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n            if (!hasScheduledUpdateOrContext) {\n                // This will be the props with resolved defaultProps,\n                // unlike current.memoizedProps which will be the unresolved ones.\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n                var compare = Component.compare;\n                compare = compare !== null ? compare : shallowEqual;\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            var newChild = createWorkInProgress(currentChild, nextProps);\n            newChild.ref = workInProgress.ref;\n            newChild.return = workInProgress;\n            workInProgress.child = newChild;\n            return newChild;\n        }\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens when the inner render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var outerMemoType = workInProgress.elementType;\n                    if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n                        // We warn when you define propTypes on lazy()\n                        // so let's just skip over it to find memo() outer wrapper.\n                        // Inner props for memo are validated later.\n                        var lazyComponent = outerMemoType;\n                        var payload = lazyComponent._payload;\n                        var init = lazyComponent._init;\n                        try {\n                            outerMemoType = init(payload);\n                        } catch (x) {\n                            outerMemoType = null;\n                        } // Inner propTypes will be validated in the function component path.\n                        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n                        if (outerPropTypes) {\n                            checkPropTypes(outerPropTypes, nextProps, \"prop\", getComponentNameFromType(outerMemoType));\n                        }\n                    }\n                }\n            }\n            if (current !== null) {\n                var prevProps = current.memoizedProps;\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {\n                    didReceiveUpdate = false;\n                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n                        // The pending lanes were cleared at the beginning of beginWork. We're\n                        // about to bail out, but there might be other lanes that weren't\n                        // included in the current render. Usually, the priority level of the\n                        // remaining updates is accumulated during the evaluation of the\n                        // component (i.e. when processing the update queue). But since since\n                        // we're bailing out early *without* evaluating the component, we need\n                        // to account for it here, too. Reset to the value of the current fiber.\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n                        // because a MemoComponent fiber does not have hooks or an update queue;\n                        // rather, it wraps around an inner component, which may or may not\n                        // contains hooks.\n                        // TODO: Move the reset at in beginWork out of the common path so that\n                        // this is no longer necessary.\n                        workInProgress.lanes = current.lanes;\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    }\n                }\n            }\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n        }\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            var prevState = current !== null ? current.memoizedState : null;\n            if (nextProps.mode === \"hidden\" || enableLegacyHidden) {\n                // Rendering a hidden tree.\n                if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                    // In legacy sync mode, don't defer the subtree. Render it now.\n                    var nextState = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = nextState;\n                    pushRenderLanes(workInProgress, renderLanes);\n                } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n                    var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n                    // and resume this tree later.\n                    var nextBaseLanes;\n                    if (prevState !== null) {\n                        var prevBaseLanes = prevState.baseLanes;\n                        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n                    } else {\n                        nextBaseLanes = renderLanes;\n                    } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n                    var _nextState = {\n                        baseLanes: nextBaseLanes,\n                        cachePool: spawnedCachePool\n                    };\n                    workInProgress.memoizedState = _nextState;\n                    workInProgress.updateQueue = null;\n                    // to avoid a push/pop misalignment.\n                    pushRenderLanes(workInProgress, nextBaseLanes);\n                    return null;\n                } else {\n                    // This is the second render. The surrounding visible content has already\n                    // committed. Now we resume rendering the hidden tree.\n                    // Rendering at offscreen, so we can clear the base lanes.\n                    var _nextState2 = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\n                    var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n                    pushRenderLanes(workInProgress, subtreeRenderLanes);\n                }\n            } else {\n                // Rendering a visible tree.\n                var _subtreeRenderLanes;\n                if (prevState !== null) {\n                    // We're going from hidden -> visible.\n                    _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n                    workInProgress.memoizedState = null;\n                } else {\n                    // We weren't previously hidden, and we still aren't, so there's nothing\n                    // special to do. Need to push to the stack regardless, though, to avoid\n                    // a push/pop misalignment.\n                    _subtreeRenderLanes = renderLanes;\n                }\n                pushRenderLanes(workInProgress, _subtreeRenderLanes);\n            }\n            {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n                return workInProgress.child;\n            }\n        }\n        function updateFragment(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMode(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateProfiler(current, workInProgress, renderLanes) {\n            {\n                workInProgress.flags |= Update;\n                {\n                    // Reset effect durations for the next eventual effect phase.\n                    // These are reset during render to allow the DevTools commit hook a chance to read them,\n                    var stateNode = workInProgress.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                }\n            }\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markRef$1(current, workInProgress) {\n            var ref = workInProgress.ref;\n            if (current === null && ref !== null || current !== null && current.ref !== ref) {\n                // Schedule a Ref effect\n                workInProgress.flags |= Ref;\n                {\n                    workInProgress.flags |= RefStatic;\n                }\n            }\n        }\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            var context;\n            {\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n                context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                        hasId = checkDidRenderIdHook();\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                // This is used by DevTools to force a boundary to error.\n                switch(shouldError(workInProgress)){\n                    case false:\n                        {\n                            var _instance = workInProgress.stateNode;\n                            var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n                            // Is there a better way to do this?\n                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n                            var state = tempInstance.state;\n                            _instance.updater.enqueueSetState(_instance, state, null);\n                            break;\n                        }\n                    case true:\n                        {\n                            workInProgress.flags |= DidCapture;\n                            workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n                            var error$1 = new Error(\"Simulated error coming from DevTools\");\n                            var lane = pickArbitraryLane(renderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n                            var update = createClassErrorUpdate(workInProgress, createCapturedValue(error$1, workInProgress), lane);\n                            enqueueCapturedUpdate(workInProgress, update);\n                            break;\n                        }\n                }\n                if (workInProgress.type !== workInProgress.elementType) {\n                    // Lazy component props can't be validated in createElement\n                    // because they're only guaranteed to be resolved here.\n                    var innerPropTypes = Component.propTypes;\n                    if (innerPropTypes) {\n                        checkPropTypes(innerPropTypes, nextProps, \"prop\", getComponentNameFromType(Component));\n                    }\n                }\n            }\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider(Component)) {\n                hasContext = true;\n                pushContextProvider(workInProgress);\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var instance = workInProgress.stateNode;\n            var shouldUpdate;\n            if (instance === null) {\n                if (current !== null) {\n                    // A class component without an instance only mounts if it suspended\n                    // inside a non-concurrent tree, in an inconsistent state. We want to\n                    // treat it like a new mount, even though an empty version of it already\n                    // committed. Disconnect the alternate pointers.\n                    current.alternate = null;\n                    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                    workInProgress.flags |= Placement;\n                } // In the initial pass we might need to construct the instance.\n                constructClassInstance(workInProgress, Component, nextProps);\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n                shouldUpdate = true;\n            } else if (current === null) {\n                // In a resume, we'll already have an instance we can reuse.\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            } else {\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n            }\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n            {\n                var inst = workInProgress.stateNode;\n                if (shouldUpdate && inst.props !== nextProps) {\n                    if (!didWarnAboutReassigningProps) {\n                        error(\"It looks like %s is reassigning its own `this.props` while rendering. \" + \"This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\");\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            return nextUnitOfWork;\n        }\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n            // Refs should update even if shouldComponentUpdate returns false\n            markRef$1(current, workInProgress);\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n            if (!shouldUpdate && !didCaptureError) {\n                // Context providers should defer to sCU for rendering\n                if (hasContext) {\n                    invalidateContextProvider(workInProgress, Component, false);\n                }\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            var instance = workInProgress.stateNode; // Rerender\n            ReactCurrentOwner$1.current = workInProgress;\n            var nextChildren;\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== \"function\") {\n                // If we captured an error, but getDerivedStateFromError is not defined,\n                // unmount all the children. componentDidCatch will schedule an update to\n                // re-render a fallback. This is temporary until we migrate everyone to\n                // the new API.\n                // TODO: Warn in a future release.\n                nextChildren = null;\n                {\n                    stopProfilerTimerIfRunning();\n                }\n            } else {\n                {\n                    markComponentRenderStarted(workInProgress);\n                }\n                {\n                    setIsRendering(true);\n                    nextChildren = instance.render();\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            instance.render();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    setIsRendering(false);\n                }\n                {\n                    markComponentRenderStopped();\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            if (current !== null && didCaptureError) {\n                // If we're recovering from an error, reconcile without reusing any of\n                // the existing children. Conceptually, the normal children and the children\n                // that are shown on error are two different sets, so we shouldn't reuse\n                // normal children even if their identities match.\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            } // Memoize state using the values we just used to render.\n            // TODO: Restructure so we never read values from the instance.\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n            if (hasContext) {\n                invalidateContextProvider(workInProgress, Component, true);\n            }\n            return workInProgress.child;\n        }\n        function pushHostRootContext(workInProgress) {\n            var root = workInProgress.stateNode;\n            if (root.pendingContext) {\n                pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n            } else if (root.context) {\n                // Should always be set\n                pushTopLevelContextObject(workInProgress, root.context, false);\n            }\n            pushHostContainer(workInProgress, root.containerInfo);\n        }\n        function updateHostRoot(current, workInProgress, renderLanes) {\n            pushHostRootContext(workInProgress);\n            if (current === null) {\n                throw new Error(\"Should have a current fiber. This is a bug in React.\");\n            }\n            var nextProps = workInProgress.pendingProps;\n            var prevState = workInProgress.memoizedState;\n            var prevChildren = prevState.element;\n            cloneUpdateQueue(current, workInProgress);\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n            var nextState = workInProgress.memoizedState;\n            var root = workInProgress.stateNode;\n            // being called \"element\".\n            var nextChildren = nextState.element;\n            if (supportsHydration && prevState.isDehydrated) {\n                // This is a hydration root whose shell has not yet hydrated. We should\n                // attempt to hydrate.\n                // Flip isDehydrated to false to indicate that when this render\n                // finishes, the root will no longer be dehydrated.\n                var overrideState = {\n                    element: nextChildren,\n                    isDehydrated: false,\n                    cache: nextState.cache,\n                    transitions: nextState.transitions\n                };\n                var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n                // have reducer functions so it doesn't need rebasing.\n                updateQueue.baseState = overrideState;\n                workInProgress.memoizedState = overrideState;\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during a previous attempt to hydrate the shell, so we\n                    // forced a client render.\n                    var recoverableError = new Error(\"There was an error while hydrating. Because the error happened outside \" + \"of a Suspense boundary, the entire root will switch to \" + \"client rendering.\");\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n                } else if (nextChildren !== prevChildren) {\n                    var _recoverableError = new Error(\"This root received an early update, before anything was able \" + \"hydrate. Switched the entire root to client rendering.\");\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);\n                } else {\n                    // The outermost shell has not hydrated yet. Start hydrating.\n                    enterHydrationState(workInProgress);\n                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n                    workInProgress.child = child;\n                    var node = child;\n                    while(node){\n                        // Mark each child as hydrating. This is a fast path to know whether this\n                        // tree is part of a hydrating tree. This is used to determine if a child\n                        // node has fully mounted yet, and for scheduling event replaying.\n                        // Conceptually this is similar to Placement in that a new subtree is\n                        // inserted into the React tree here. It just happens to not need DOM\n                        // mutations because it already exists.\n                        node.flags = node.flags & ~Placement | Hydrating;\n                        node = node.sibling;\n                    }\n                }\n            } else {\n                // Root is not dehydrated. Either this is a client-only root, or it\n                // already hydrated.\n                resetHydrationState();\n                if (nextChildren === prevChildren) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n            // Revert to client rendering.\n            resetHydrationState();\n            queueHydrationError(recoverableError);\n            workInProgress.flags |= ForceClientRender;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostComponent$1(current, workInProgress, renderLanes) {\n            pushHostContext(workInProgress);\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            }\n            var type = workInProgress.type;\n            var nextProps = workInProgress.pendingProps;\n            var prevProps = current !== null ? current.memoizedProps : null;\n            var nextChildren = nextProps.children;\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\n            if (isDirectTextChild) {\n                // We special case a direct text child of a host node. This is a common\n                // case. We won't handle it as a reified child. We will instead handle\n                // this in the host environment that also has access to this prop. That\n                // avoids allocating another HostText fiber and traversing it.\n                nextChildren = null;\n            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n                // If we're switching from a direct text child to a normal child, or to\n                // empty, we need to schedule the text content to be reset.\n                workInProgress.flags |= ContentReset;\n            }\n            markRef$1(current, workInProgress);\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostText$1(current, workInProgress) {\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            } // Nothing to do here. This is terminal. We'll do the completion step\n            // immediately after.\n            return null;\n        }\n        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n            if (_current !== null) {\n                // A lazy component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            }\n            var props = workInProgress.pendingProps;\n            var lazyComponent = elementType;\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload); // Store the unwrapped component in the type.\n            workInProgress.type = Component;\n            var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n            var resolvedProps = resolveDefaultProps(Component, props);\n            var child;\n            switch(resolvedTag){\n                case FunctionComponent:\n                    {\n                        {\n                            validateFunctionComponentInDev(workInProgress, Component);\n                            workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n                        }\n                        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case ClassComponent:\n                    {\n                        {\n                            workInProgress.type = Component = resolveClassForHotReloading(Component);\n                        }\n                        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case ForwardRef:\n                    {\n                        {\n                            workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n                        }\n                        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n                        return child;\n                    }\n                case MemoComponent:\n                    {\n                        {\n                            if (workInProgress.type !== workInProgress.elementType) {\n                                var outerPropTypes = Component.propTypes;\n                                if (outerPropTypes) {\n                                    checkPropTypes(outerPropTypes, resolvedProps, \"prop\", getComponentNameFromType(Component));\n                                }\n                            }\n                        }\n                        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes);\n                        return child;\n                    }\n            }\n            var hint = \"\";\n            {\n                if (Component !== null && typeof Component === \"object\" && Component.$$typeof === REACT_LAZY_TYPE) {\n                    hint = \" Did you wrap a component in React.lazy() more than once?\";\n                }\n            }\n            // because the fact that it's a separate type of work is an\n            // implementation detail.\n            throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n            if (_current !== null) {\n                // An incomplete component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            } // Promote the fiber to a class and try rendering again.\n            workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n            // Push context providers early to prevent context stack mismatches.\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider(Component)) {\n                hasContext = true;\n                pushContextProvider(workInProgress);\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            constructClassInstance(workInProgress, Component, nextProps);\n            mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n        }\n        function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n            if (_current !== null) {\n                // An indeterminate component only mounts if it suspended inside a non-\n                // concurrent tree, in an inconsistent state. We want to treat it like\n                // a new mount, even though an empty version of it already committed.\n                // Disconnect the alternate pointers.\n                _current.alternate = null;\n                workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n                workInProgress.flags |= Placement;\n            }\n            var props = workInProgress.pendingProps;\n            var context;\n            {\n                var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n                context = getMaskedContext(workInProgress, unmaskedContext);\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var value;\n            var hasId;\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                if (Component.prototype && typeof Component.prototype.render === \"function\") {\n                    var componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + \"This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n                }\n                setIsRendering(true);\n                ReactCurrentOwner$1.current = workInProgress;\n                value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            {\n                // Support for module components is deprecated and is removed behind a flag.\n                // Whether or not it would crash later, we want to show a good message in DEV first.\n                if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                    var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                        didWarnAboutModulePatternComponent[_componentName] = true;\n                    }\n                }\n            }\n            if (// Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === undefined) {\n                {\n                    var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                        error(\"The <%s /> component appears to be a function component that returns a class instance. \" + \"Change %s to a class that extends React.Component instead. \" + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + \"cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                        didWarnAboutModulePatternComponent[_componentName2] = true;\n                    }\n                }\n                workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n                // During mounting we don't know the child context yet as the instance doesn't exist.\n                // We will invalidate the child context in finishClassComponent() right after rendering.\n                var hasContext = false;\n                if (isContextProvider(Component)) {\n                    hasContext = true;\n                    pushContextProvider(workInProgress);\n                } else {\n                    hasContext = false;\n                }\n                workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n                initializeUpdateQueue(workInProgress);\n                adoptClassInstance(workInProgress, value);\n                mountClassInstance(workInProgress, Component, props, renderLanes);\n                return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n            } else {\n                // Proceed under the assumption that this is a function component\n                workInProgress.tag = FunctionComponent;\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n                            hasId = checkDidRenderIdHook();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                }\n                if (getIsHydrating() && hasId) {\n                    pushMaterializedTreeId(workInProgress);\n                }\n                reconcileChildren(null, workInProgress, value, renderLanes);\n                {\n                    validateFunctionComponentInDev(workInProgress, Component);\n                }\n                return workInProgress.child;\n            }\n        }\n        function validateFunctionComponentInDev(workInProgress, Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n                    }\n                }\n                if (workInProgress.ref !== null) {\n                    var info = \"\";\n                    var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n                    if (ownerName) {\n                        info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                    }\n                    var warningKey = ownerName || \"\";\n                    var debugSource = workInProgress._debugSource;\n                    if (debugSource) {\n                        warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n                    }\n                    if (!didWarnAboutFunctionRefs[warningKey]) {\n                        didWarnAboutFunctionRefs[warningKey] = true;\n                        error(\"Function components cannot be given refs. \" + \"Attempts to access this ref will fail. \" + \"Did you mean to use React.forwardRef()?%s\", info);\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === \"function\") {\n                    var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                        error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n                if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n                    var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                        error(\"%s: Function components do not support contextType.\", _componentName4);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n                    }\n                }\n            }\n        }\n        var SUSPENDED_MARKER = {\n            dehydrated: null,\n            treeContext: null,\n            retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes) {\n            return {\n                baseLanes: renderLanes,\n                cachePool: getSuspendedCache()\n            };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n            var cachePool = null;\n            return {\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n                cachePool: cachePool\n            };\n        } // TODO: Probably should inline this back\n        function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n            // If we're already showing a fallback, there are cases where we need to\n            // remain on that fallback regardless of whether the content has resolved.\n            // For example, SuspenseList coordinates when nested content appears.\n            if (current !== null) {\n                var suspenseState = current.memoizedState;\n                if (suspenseState === null) {\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\n                    // no fallback to remain on.\n                    return false;\n                }\n            } // Not currently showing content. Consult the Suspense context.\n            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current, renderLanes) {\n            // TODO: Should not remove render lanes that were pinged during this render\n            return removeLanes(current.childLanes, renderLanes);\n        }\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n            {\n                if (shouldSuspend(workInProgress)) {\n                    workInProgress.flags |= DidCapture;\n                }\n            }\n            var suspenseContext = suspenseStackCursor.current;\n            var showFallback = false;\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n            if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\n                // Something in this boundary's subtree already suspended. Switch to\n                // rendering the fallback children.\n                showFallback = true;\n                workInProgress.flags &= ~DidCapture;\n            } else {\n                // Attempting the main content\n                if (current === null || current.memoizedState !== null) {\n                    // This is a new mount or this boundary is already showing a fallback state.\n                    // Mark this subtree context as having at least one invisible parent that could\n                    // handle the fallback state.\n                    // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n                    {\n                        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n                    }\n                }\n            }\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n            pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n            // boundary's children. This involves some custom reconciliation logic. Two\n            // main reasons this is so complicated.\n            //\n            // First, Legacy Mode has different semantics for backwards compatibility. The\n            // primary tree will commit in an inconsistent state, so when we do the\n            // second pass to render the fallback, we do some exceedingly, uh, clever\n            // hacks to make that not totally break. Like transferring effects and\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n            // because we bailout on the primary tree completely and leave it in its old\n            // state, no effects. Same as what we do for Offscreen (except that\n            // Offscreen doesn't have the first render pass).\n            //\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\n            // different layout, where the child points to a dehydrated fragment, which\n            // contains the DOM rendered by the server.\n            //\n            // Third, even if you set all that aside, Suspense is like error boundaries in\n            // that we first we try to render one tree, and if that fails, we render again\n            // and switch to a different tree. Like a try/catch block. So we have to track\n            // which branch we're currently rendering. Ideally we would model this using\n            // a stack.\n            if (current === null) {\n                // Initial mount\n                // If we're currently hydrating, try to hydrate this boundary.\n                tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n                {\n                    var suspenseState = workInProgress.memoizedState;\n                    if (suspenseState !== null) {\n                        var dehydrated = suspenseState.dehydrated;\n                        if (dehydrated !== null) {\n                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n                        }\n                    }\n                }\n                var nextPrimaryChildren = nextProps.children;\n                var nextFallbackChildren = nextProps.fallback;\n                if (showFallback) {\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var primaryChildFragment = workInProgress.child;\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackFragment;\n                } else {\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n                }\n            } else {\n                // This is an update.\n                // If the current fiber has a SuspenseState, that means it's already showing\n                // a fallback.\n                var prevState = current.memoizedState;\n                if (prevState !== null) {\n                    // The current tree is already showing a fallback\n                    // Special path for hydration\n                    {\n                        var _dehydrated = prevState.dehydrated;\n                        if (_dehydrated !== null) {\n                            if (!didSuspend) {\n                                return updateDehydratedSuspenseComponent(current, workInProgress, _dehydrated, prevState, renderLanes);\n                            } else if (workInProgress.flags & ForceClientRender) {\n                                // Something errored during hydration. Try again without hydrating.\n                                workInProgress.flags &= ~ForceClientRender;\n                                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error(\"There was an error while hydrating this Suspense boundary. \" + \"Switched to client rendering.\"));\n                            } else if (workInProgress.memoizedState !== null) {\n                                // Something suspended and we should still be in dehydrated mode.\n                                // Leave the existing child in place.\n                                workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n                                // but the normal suspense pass doesn't.\n                                workInProgress.flags |= DidCapture;\n                                return null;\n                            } else {\n                                // Suspended but we should no longer be in dehydrated mode.\n                                // Therefore we now have to render the fallback.\n                                var _nextPrimaryChildren = nextProps.children;\n                                var _nextFallbackChildren = nextProps.fallback;\n                                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n                                var _primaryChildFragment2 = workInProgress.child;\n                                _primaryChildFragment2.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                                workInProgress.memoizedState = SUSPENDED_MARKER;\n                                return fallbackChildFragment;\n                            }\n                        }\n                    }\n                    if (showFallback) {\n                        var _nextFallbackChildren2 = nextProps.fallback;\n                        var _nextPrimaryChildren2 = nextProps.children;\n                        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);\n                        var _primaryChildFragment3 = workInProgress.child;\n                        var prevOffscreenState = current.child.memoizedState;\n                        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n                        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\n                        return _fallbackChildFragment;\n                    } else {\n                        var _nextPrimaryChildren3 = nextProps.children;\n                        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);\n                        workInProgress.memoizedState = null;\n                        return _primaryChildFragment4;\n                    }\n                } else {\n                    // The current tree is not already showing a fallback.\n                    if (showFallback) {\n                        // Timed out.\n                        var _nextFallbackChildren3 = nextProps.fallback;\n                        var _nextPrimaryChildren4 = nextProps.children;\n                        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);\n                        var _primaryChildFragment5 = workInProgress.child;\n                        var _prevOffscreenState = current.child.memoizedState;\n                        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);\n                        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the\n                        // fallback children.\n                        workInProgress.memoizedState = SUSPENDED_MARKER;\n                        return _fallbackChildFragment2;\n                    } else {\n                        // Still haven't timed out. Continue rendering the children, like we\n                        // normally do.\n                        var _nextPrimaryChildren5 = nextProps.children;\n                        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);\n                        workInProgress.memoizedState = null;\n                        return _primaryChildFragment6;\n                    }\n                }\n            }\n        }\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: \"visible\",\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            primaryChildFragment.return = workInProgress;\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var progressedPrimaryFragment = workInProgress.child;\n            var primaryChildProps = {\n                mode: \"hidden\",\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            var fallbackChildFragment;\n            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n                // In legacy mode, we commit the primary tree as if it successfully\n                // completed, even though it's in an inconsistent state.\n                primaryChildFragment = progressedPrimaryFragment;\n                primaryChildFragment.childLanes = NoLanes;\n                primaryChildFragment.pendingProps = primaryChildProps;\n                if (workInProgress.mode & ProfileMode) {\n                    // Reset the durations from the first pass so they aren't included in the\n                    // final amounts. This seems counterintuitive, since we're intentionally\n                    // not measuring part of the render phase, but this makes it match what we\n                    // do in Concurrent Mode.\n                    primaryChildFragment.actualDuration = 0;\n                    primaryChildFragment.actualStartTime = -1;\n                    primaryChildFragment.selfBaseDuration = 0;\n                    primaryChildFragment.treeBaseDuration = 0;\n                }\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            } else {\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            }\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n            // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n            // this wrapper function to constrain it.\n            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\n            // wrapper function to constrain it.\n            return createWorkInProgress(current, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n                mode: \"visible\",\n                children: primaryChildren\n            });\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                primaryChildFragment.lanes = renderLanes;\n            }\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = null;\n            if (currentFallbackChildFragment !== null) {\n                // Delete the fallback child fragment\n                var deletions = workInProgress.deletions;\n                if (deletions === null) {\n                    workInProgress.deletions = [\n                        currentFallbackChildFragment\n                    ];\n                    workInProgress.flags |= ChildDeletion;\n                } else {\n                    deletions.push(currentFallbackChildFragment);\n                }\n            }\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildProps = {\n                mode: \"hidden\",\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            if (// completed, even though it's in an inconsistent state.\n            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n            // already cloned. In legacy mode, the only case where this isn't true is\n            // when DevTools forces us to display a fallback; we skip the first render\n            // pass entirely and go straight to rendering the fallback. (In Concurrent\n            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n            // only codepath.)\n            workInProgress.child !== currentPrimaryChildFragment) {\n                var progressedPrimaryFragment = workInProgress.child;\n                primaryChildFragment = progressedPrimaryFragment;\n                primaryChildFragment.childLanes = NoLanes;\n                primaryChildFragment.pendingProps = primaryChildProps;\n                if (workInProgress.mode & ProfileMode) {\n                    // Reset the durations from the first pass so they aren't included in the\n                    // final amounts. This seems counterintuitive, since we're intentionally\n                    // not measuring part of the render phase, but this makes it match what we\n                    // do in Concurrent Mode.\n                    primaryChildFragment.actualDuration = 0;\n                    primaryChildFragment.actualStartTime = -1;\n                    primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n                    primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n                }\n                // However, since we're going to remain on the fallback, we no longer want\n                // to delete it.\n                workInProgress.deletions = null;\n            } else {\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n                // (We don't do this in legacy mode, because in legacy mode we don't re-use\n                // the current tree; see previous branch.)\n                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n            }\n            var fallbackChildFragment;\n            if (currentFallbackChildFragment !== null) {\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n            } else {\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n                // mounted but this is a new fiber.\n                fallbackChildFragment.flags |= Placement;\n            }\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n            // Falling back to client rendering. Because this has performance\n            // implications, it's considered a recoverable error, even though the user\n            // likely won't observe anything wrong with the UI.\n            //\n            // The error is passed in as an argument to enforce that every caller provide\n            // a custom message, or explicitly opt out (currently the only path that opts\n            // out is legacy mode; every concurrent path provides an error).\n            if (recoverableError !== null) {\n                queueHydrationError(recoverableError);\n            } // This will add the old fiber to the deletion list\n            reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n            var nextProps = workInProgress.pendingProps;\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n            // mounted but this is a new fiber.\n            primaryChildFragment.flags |= Placement;\n            workInProgress.memoizedState = null;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var fiberMode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: \"visible\",\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n            // boundary) already mounted but this is a new fiber.\n            fallbackChildFragment.flags |= Placement;\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n                // We will have dropped the effect list which contains the\n                // deletion. We need to reconcile to delete the current child.\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n            }\n            return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n            // During the first pass, we'll bail out and not drill into the children.\n            // Instead, we'll leave the content in place and try to hydrate it later.\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                {\n                    error(\"Cannot hydrate Suspense in legacy mode. Switch from \" + \"ReactDOM.hydrate(element, container) to \" + \"ReactDOMClient.hydrateRoot(container, <App />)\" + \".render(element) or remove the Suspense components from \" + \"the server rendered components.\");\n                }\n                workInProgress.lanes = laneToLanes(SyncLane);\n            } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This is a client-only boundary. Since we won't get any content from the server\n                // for this, we need to schedule that at a higher priority based on when it would\n                // have timed out. In theory we could render it in this pass but it would have the\n                // wrong priority associated with it and will prevent hydration of parent path.\n                // Instead, we'll leave work left on it to render it in a separate commit.\n                // TODO This time should be the time at which the server rendered response that is\n                // a parent to this boundary was displayed. However, since we currently don't have\n                // a protocol to transfer that time, we'll just estimate it by using the current\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\n                // they should be.\n                // Schedule a normal pri update to render this content.\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n            } else {\n                // We'll continue hydrating the rest at offscreen priority since we'll already\n                // be showing the right content coming from the server, it is no rush.\n                workInProgress.lanes = laneToLanes(OffscreenLane);\n            }\n            return null;\n        }\n        function updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderLanes) {\n            // We should never be hydrating at this point because it is the first pass,\n            // but after we've already committed once.\n            warnIfHydrating();\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // required — every concurrent mode path that causes hydration to\n                // de-opt to client rendering should have an error message.\n                null);\n            }\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This boundary is in a permanent fallback state. In this case, we'll never\n                // get an update and we'll never be able to hydrate the final content. Let's just try the\n                // client side render instead.\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // here on the client. Or, in production, a hash/id that corresponds to\n                // the error.\n                new Error(\"The server could not finish this Suspense boundary, likely \" + \"due to an error during server rendering. Switched to \" + \"client rendering.\"));\n            }\n            // any context has changed, we need to treat is as if the input might have changed.\n            var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n            if (didReceiveUpdate || hasContextChanged) {\n                // This boundary has changed since the first render. This means that we are now unable to\n                // hydrate it. We might still be able to hydrate it using a higher priority lane.\n                var root = getWorkInProgressRoot();\n                if (root !== null) {\n                    var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n                    if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                        // Intentionally mutating since this render will get interrupted. This\n                        // is one of the very rare times where we mutate the current tree\n                        // during the render phase.\n                        suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n                        var eventTime = NoTimestamp;\n                        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\n                    }\n                } // If we have scheduled higher pri work above, this will probably just abort the render\n                // since we now have higher priority work, but in case it doesn't, we need to prepare to\n                // render something, if we time out. Even if that requires us to delete everything and\n                // skip hydration.\n                // Delay having to do this as long as the suspense timeout allows us.\n                renderDidSuspendDelayIfPossible();\n                return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error(\"This Suspense boundary received an update before it finished \" + \"hydrating. This caused the boundary to switch to client rendering. \" + \"The usual way to fix this is to wrap the original update \" + \"in startTransition.\"));\n            } else if (isSuspenseInstancePending(suspenseInstance)) {\n                // This component is still pending more data from the server, so we can't hydrate its\n                // content. We treat it as if this component suspended itself. It might seem as if\n                // we could just try to render it client-side instead. However, this will perform a\n                // lot of unnecessary work and is unlikely to complete since it often will suspend\n                // on missing data anyway. Additionally, the server might be able to render more\n                // than we can on the client yet. In that case we'd end up with more fallback states\n                // on the client than if we just leave it alone. If the server times out or errors\n                // these should update this boundary to the permanent Fallback state instead.\n                // Mark it as having captured (i.e. suspended).\n                workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n                workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n                var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n                registerSuspenseInstanceRetry(suspenseInstance, retry);\n                return null;\n            } else {\n                // This is the first attempt.\n                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n                var nextProps = workInProgress.pendingProps;\n                var primaryChildren = nextProps.children;\n                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n                // tree is part of a hydrating tree. This is used to determine if a child\n                // node has fully mounted yet, and for scheduling event replaying.\n                // Conceptually this is similar to Placement in that a new subtree is\n                // inserted into the React tree here. It just happens to not need DOM\n                // mutations because it already exists.\n                primaryChildFragment.flags |= Hydrating;\n                return primaryChildFragment;\n            }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n            }\n            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n            // Mark any Suspense boundaries with fallbacks as having work to do.\n            // If they were previously forced into fallbacks, they may now be able\n            // to unblock.\n            var node = firstChild;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                    }\n                } else if (node.tag === SuspenseListComponent) {\n                    // If the tail is hidden there might not be an Suspense boundaries\n                    // to schedule work on. In this case we have to schedule it on the\n                    // list itself.\n                    // We don't have to traverse to the children of the list since\n                    // the list will propagate the change when it rerenders.\n                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === workInProgress) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === workInProgress) {\n                        return;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function findLastContentRow(firstChild) {\n            // This is going to find the last row among these children that is already\n            // showing content on the screen, as opposed to being in fallback state or\n            // new. If a row has multiple Suspense boundaries, any of them being in the\n            // fallback state, counts as the whole row being in a fallback state.\n            // Note that the \"rows\" will be workInProgress, but any nested children\n            // will still be current since we haven't rendered them yet. The mounted\n            // order may not be the same as the new order. We use the new order.\n            var row = firstChild;\n            var lastContentRow = null;\n            while(row !== null){\n                var currentRow = row.alternate; // New rows can't be content rows.\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    lastContentRow = row;\n                }\n                row = row.sibling;\n            }\n            return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n            {\n                if (revealOrder !== undefined && revealOrder !== \"forwards\" && revealOrder !== \"backwards\" && revealOrder !== \"together\" && !didWarnAboutRevealOrder[revealOrder]) {\n                    didWarnAboutRevealOrder[revealOrder] = true;\n                    if (typeof revealOrder === \"string\") {\n                        switch(revealOrder.toLowerCase()){\n                            case \"together\":\n                            case \"forwards\":\n                            case \"backwards\":\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            case \"forward\":\n                            case \"backward\":\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            default:\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                                break;\n                        }\n                    } else {\n                        error(\"%s is not a supported value for revealOrder on <SuspenseList />. \" + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    }\n                }\n            }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n            {\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n                    if (tailMode !== \"collapsed\" && tailMode !== \"hidden\") {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n                    } else if (revealOrder !== \"forwards\" && revealOrder !== \"backwards\") {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n                    }\n                }\n            }\n        }\n        function validateSuspenseListNestedChild(childSlot, index) {\n            {\n                var isAnArray = isArray(childSlot);\n                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === \"function\";\n                if (isAnArray || isIterable) {\n                    var type = isAnArray ? \"array\" : \"iterable\";\n                    error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in \" + \"an additional SuspenseList to configure its revealOrder: \" + \"<SuspenseList revealOrder=...> ... \" + \"<SuspenseList revealOrder=...>{%s}</SuspenseList> ... \" + \"</SuspenseList>\", type, index, type);\n                    return false;\n                }\n            }\n            return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n            {\n                if ((revealOrder === \"forwards\" || revealOrder === \"backwards\") && children !== undefined && children !== null && children !== false) {\n                    if (isArray(children)) {\n                        for(var i = 0; i < children.length; i++){\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\n                                return;\n                            }\n                        }\n                    } else {\n                        var iteratorFn = getIteratorFn(children);\n                        if (typeof iteratorFn === \"function\") {\n                            var childrenIterator = iteratorFn.call(children);\n                            if (childrenIterator) {\n                                var step = childrenIterator.next();\n                                var _i = 0;\n                                for(; !step.done; step = childrenIterator.next()){\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                                        return;\n                                    }\n                                    _i++;\n                                }\n                            }\n                        } else {\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + \"This is not useful since it needs multiple rows. \" + \"Did you mean to pass multiple children or an array?\", revealOrder);\n                        }\n                    }\n                }\n            }\n        }\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n            var renderState = workInProgress.memoizedState;\n            if (renderState === null) {\n                workInProgress.memoizedState = {\n                    isBackwards: isBackwards,\n                    rendering: null,\n                    renderingStartTime: 0,\n                    last: lastContentRow,\n                    tail: tail,\n                    tailMode: tailMode\n                };\n            } else {\n                // We can reuse the existing object from previous renders.\n                renderState.isBackwards = isBackwards;\n                renderState.rendering = null;\n                renderState.renderingStartTime = 0;\n                renderState.last = lastContentRow;\n                renderState.tail = tail;\n                renderState.tailMode = tailMode;\n            }\n        } // This can end up rendering this component multiple passes.\n        // The first pass splits the children fibers into two sets. A head and tail.\n        // We first render the head. If anything is in fallback state, we do another\n        // pass through beginWork to rerender all children (including the tail) with\n        // the force suspend context. If the first render didn't have anything in\n        // in fallback state. Then we render each row in the tail one-by-one.\n        // That happens in the completeWork phase without going back to beginWork.\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var revealOrder = nextProps.revealOrder;\n            var tailMode = nextProps.tail;\n            var newChildren = nextProps.children;\n            validateRevealOrder(revealOrder);\n            validateTailOptions(tailMode, revealOrder);\n            validateSuspenseListChildren(newChildren, revealOrder);\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            var suspenseContext = suspenseStackCursor.current;\n            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n            if (shouldForceFallback) {\n                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                workInProgress.flags |= DidCapture;\n            } else {\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n                if (didSuspendBefore) {\n                    // If we previously forced a fallback, we need to schedule work\n                    // on any nested boundaries to let them know to try to render\n                    // again. This is the same as context updating.\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n                }\n                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n            }\n            pushSuspenseContext(workInProgress, suspenseContext);\n            if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n                // In legacy mode, SuspenseList doesn't work so we just\n                // use make it a noop by treating it as the default revealOrder.\n                workInProgress.memoizedState = null;\n            } else {\n                switch(revealOrder){\n                    case \"forwards\":\n                        {\n                            var lastContentRow = findLastContentRow(workInProgress.child);\n                            var tail;\n                            if (lastContentRow === null) {\n                                // The whole list is part of the tail.\n                                // TODO: We could fast path by just rendering the tail now.\n                                tail = workInProgress.child;\n                                workInProgress.child = null;\n                            } else {\n                                // Disconnect the tail rows after the content row.\n                                // We're going to render them separately later.\n                                tail = lastContentRow.sibling;\n                                lastContentRow.sibling = null;\n                            }\n                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);\n                            break;\n                        }\n                    case \"backwards\":\n                        {\n                            // We're going to find the first row that has existing content.\n                            // At the same time we're going to reverse the list of everything\n                            // we pass in the meantime. That's going to be our tail in reverse\n                            // order.\n                            var _tail = null;\n                            var row = workInProgress.child;\n                            workInProgress.child = null;\n                            while(row !== null){\n                                var currentRow = row.alternate; // New rows can't be content rows.\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                                    // This is the beginning of the main content.\n                                    workInProgress.child = row;\n                                    break;\n                                }\n                                var nextRow = row.sibling;\n                                row.sibling = _tail;\n                                _tail = row;\n                                row = nextRow;\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);\n                            break;\n                        }\n                    case \"together\":\n                        {\n                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);\n                            break;\n                        }\n                    default:\n                        {\n                            // The default reveal order is the same as not having\n                            // a boundary.\n                            workInProgress.memoizedState = null;\n                        }\n                }\n            }\n            return workInProgress.child;\n        }\n        function updatePortalComponent(current, workInProgress, renderLanes) {\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            var nextChildren = workInProgress.pendingProps;\n            if (current === null) {\n                // Portals are special because we don't append the children during mount\n                // but at commit. Therefore we need to track insertions which the normal\n                // flow doesn't do during mount. This doesn't happen at the root because\n                // the root always starts with a \"current\" with a null child.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current, workInProgress, renderLanes) {\n            var providerType = workInProgress.type;\n            var context = providerType._context;\n            var newProps = workInProgress.pendingProps;\n            var oldProps = workInProgress.memoizedProps;\n            var newValue = newProps.value;\n            {\n                if (!(\"value\" in newProps)) {\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                        error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\");\n                    }\n                }\n                var providerPropTypes = workInProgress.type.propTypes;\n                if (providerPropTypes) {\n                    checkPropTypes(providerPropTypes, newProps, \"prop\", \"Context.Provider\");\n                }\n            }\n            pushProvider(workInProgress, context, newValue);\n            {\n                if (oldProps !== null) {\n                    var oldValue = oldProps.value;\n                    if (objectIs(oldValue, newValue)) {\n                        // No change. Bailout early if children are the same.\n                        if (oldProps.children === newProps.children && !hasContextChanged()) {\n                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                        }\n                    } else {\n                        // The context value changed. Search for matching consumers and schedule\n                        // them to update.\n                        propagateContextChange(workInProgress, context, renderLanes);\n                    }\n                }\n            }\n            var newChildren = newProps.children;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingContextAsConsumer = false;\n        function updateContextConsumer(current, workInProgress, renderLanes) {\n            var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n            // DEV mode, we create a separate object for Context.Consumer that acts\n            // like a proxy to Context. This proxy object adds unnecessary code in PROD\n            // so we use the old behaviour (Context.Consumer references Context) to\n            // reduce size and overhead. The separate object references context via\n            // a property called \"_context\", which also gives us the ability to check\n            // in DEV mode if this property exists or not and warn if it does not.\n            {\n                if (context._context === undefined) {\n                    // This may be because it's a Context (rather than a Consumer).\n                    // Or it may be because it's older React where they're the same thing.\n                    // We only want to warn if we're sure it's a new React.\n                    if (context !== context.Consumer) {\n                        if (!hasWarnedAboutUsingContextAsConsumer) {\n                            hasWarnedAboutUsingContextAsConsumer = true;\n                            error(\"Rendering <Context> directly is not supported and will be removed in \" + \"a future major release. Did you mean to render <Context.Consumer> instead?\");\n                        }\n                    }\n                } else {\n                    context = context._context;\n                }\n            }\n            var newProps = workInProgress.pendingProps;\n            var render = newProps.children;\n            {\n                if (typeof render !== \"function\") {\n                    error(\"A context consumer was rendered with multiple children, or a child \" + \"that isn't a function. A context consumer expects a single child \" + \"that is a function. If you did pass a function, make sure there \" + \"is no trailing or leading whitespace around it.\");\n                }\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var newValue = readContext(context);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var newChildren;\n            {\n                ReactCurrentOwner$1.current = workInProgress;\n                setIsRendering(true);\n                newChildren = render(newValue);\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n            didReceiveUpdate = true;\n        }\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n            if (current !== null) {\n                // Reuse previous dependencies\n                workInProgress.dependencies = current.dependencies;\n            }\n            {\n                // Don't update \"base\" render times for bailouts.\n                stopProfilerTimerIfRunning();\n            }\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n                // The children don't have any work either. We can skip them.\n                // TODO: Once we add back resuming, we should check if the children are\n                // a work-in-progress set. If so, we need to transfer their effects.\n                {\n                    return null;\n                }\n            } // This fiber doesn't have work, but its subtree does. Clone the child\n            // fibers and continue.\n            cloneChildFibers(current, workInProgress);\n            return workInProgress.child;\n        }\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n            {\n                var returnFiber = oldWorkInProgress.return;\n                if (returnFiber === null) {\n                    // eslint-disable-next-line react-internal/prod-error-codes\n                    throw new Error(\"Cannot swap the root fiber.\");\n                } // Disconnect from the old current.\n                // It will get deleted.\n                current.alternate = null;\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\n                newWorkInProgress.index = oldWorkInProgress.index;\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\n                newWorkInProgress.return = oldWorkInProgress.return;\n                newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n                if (oldWorkInProgress === returnFiber.child) {\n                    returnFiber.child = newWorkInProgress;\n                } else {\n                    var prevSibling = returnFiber.child;\n                    if (prevSibling === null) {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error(\"Expected parent to have a child.\");\n                    }\n                    while(prevSibling.sibling !== oldWorkInProgress){\n                        prevSibling = prevSibling.sibling;\n                        if (prevSibling === null) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error(\"Expected to find the previous sibling.\");\n                        }\n                    }\n                    prevSibling.sibling = newWorkInProgress;\n                } // Delete the old fiber and place the new one.\n                // Since the old fiber is disconnected, we have to schedule it manually.\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        current\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(current);\n                }\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n                return newWorkInProgress;\n            }\n        }\n        function checkScheduledUpdateOrContext(current, renderLanes) {\n            // Before performing an early bailout, we must check if there are pending\n            // updates or context.\n            var updateLanes = current.lanes;\n            if (includesSomeLane(updateLanes, renderLanes)) {\n                return true;\n            } // No pending update, but because context is propagated lazily, we need\n            return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n            // This fiber does not have any pending work. Bailout without entering\n            // the begin phase. There's still some bookkeeping we that needs to be done\n            // in this optimized path, mostly pushing stuff onto the stack.\n            switch(workInProgress.tag){\n                case HostRoot:\n                    pushHostRootContext(workInProgress);\n                    var root = workInProgress.stateNode;\n                    resetHydrationState();\n                    break;\n                case HostComponent:\n                    pushHostContext(workInProgress);\n                    break;\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            pushContextProvider(workInProgress);\n                        }\n                        break;\n                    }\n                case HostPortal:\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    break;\n                case ContextProvider:\n                    {\n                        var newValue = workInProgress.memoizedProps.value;\n                        var context = workInProgress.type._context;\n                        pushProvider(workInProgress, context, newValue);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        // Profiler should only call onRender when one of its descendants actually rendered.\n                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (hasChildWork) {\n                            workInProgress.flags |= Update;\n                        }\n                        {\n                            // Reset effect durations for the next eventual effect phase.\n                            // These are reset during render to allow the DevTools commit hook a chance to read them,\n                            var stateNode = workInProgress.stateNode;\n                            stateNode.effectDuration = 0;\n                            stateNode.passiveEffectDuration = 0;\n                        }\n                    }\n                    break;\n                case SuspenseComponent:\n                    {\n                        var state = workInProgress.memoizedState;\n                        if (state !== null) {\n                            {\n                                if (state.dehydrated !== null) {\n                                    pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n                                    // been unsuspended it has committed as a resolved Suspense component.\n                                    // If it needs to be retried, it should have work scheduled on it.\n                                    workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n                                    // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                                    return null;\n                                }\n                            }\n                            // whether to retry the primary children, or to skip over it and\n                            // go straight to the fallback. Check the priority of the primary\n                            // child fragment.\n                            var primaryChildFragment = workInProgress.child;\n                            var primaryChildLanes = primaryChildFragment.childLanes;\n                            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n                                // The primary children have pending work. Use the normal path\n                                // to attempt to render the primary children again.\n                                return updateSuspenseComponent(current, workInProgress, renderLanes);\n                            } else {\n                                // The primary child fragment does not have pending work marked\n                                // on it\n                                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n                                // priority. Bailout.\n                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                                if (child !== null) {\n                                    // The fallback children have pending work. Skip over the\n                                    // primary children and work on the fallback.\n                                    return child.sibling;\n                                } else {\n                                    // Note: We can return `null` here because we already checked\n                                    // whether there were nested context consumers, via the call to\n                                    // `bailoutOnAlreadyFinishedWork` above.\n                                    return null;\n                                }\n                            }\n                        } else {\n                            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                        }\n                        break;\n                    }\n                case SuspenseListComponent:\n                    {\n                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (didSuspendBefore) {\n                            if (_hasChildWork) {\n                                // If something was in fallback state last time, and we have all the\n                                // same children then we're still in progressive loading state.\n                                // Something might get unblocked by state updates or retries in the\n                                // tree which will affect the tail. So we need to use the normal\n                                // path to compute the correct tail.\n                                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                            } // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            workInProgress.flags |= DidCapture;\n                        } // If nothing suspended before and we're rendering the same children,\n                        // then the tail doesn't matter. Anything new that suspends will work\n                        // in the \"together\" mode, so we can continue from the state we had.\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState !== null) {\n                            // Reset to the \"together\" mode in case we've started a different\n                            // update in the past but didn't complete it.\n                            renderState.rendering = null;\n                            renderState.tail = null;\n                            renderState.lastEffect = null;\n                        }\n                        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n                        if (_hasChildWork) {\n                            break;\n                        } else {\n                            // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            return null;\n                        }\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        // Need to check if the tree still needs to be deferred. This is\n                        // almost identical to the logic used in the normal update path,\n                        // so we'll just enter that. The only difference is we'll bail out\n                        // at the next level instead of this one, because the child props\n                        // have not changed. Which is fine.\n                        // TODO: Probably should refactor `beginWork` to split the bailout\n                        // path from the normal path. I'm tempted to do a labeled break here\n                        // but I won't :)\n                        workInProgress.lanes = NoLanes;\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n            }\n            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        function beginWork(current, workInProgress, renderLanes) {\n            {\n                if (workInProgress._debugNeedsRemount && current !== null) {\n                    // This will restart the begin phase with a new fiber.\n                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n                }\n            }\n            if (current !== null) {\n                var oldProps = current.memoizedProps;\n                var newProps = workInProgress.pendingProps;\n                if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {\n                    // If props or context changed, mark the fiber as having performed work.\n                    // This may be unset if the props are determined to be equal later (memo).\n                    didReceiveUpdate = true;\n                } else {\n                    // Neither props nor legacy context changes. Check if there's a pending\n                    // update or context change.\n                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n                    if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n                    // may not be work scheduled on `current`, so we check for this flag.\n                    (workInProgress.flags & DidCapture) === NoFlags) {\n                        // No pending updates or context. Bail out now.\n                        didReceiveUpdate = false;\n                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n                    }\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    } else {\n                        // An update was scheduled on this fiber, but there are no new props\n                        // nor legacy context. Set this to false. If an update queue or context\n                        // consumer produces a changed value, it will set this to true. Otherwise,\n                        // the component will assume the children have not changed and bail out.\n                        didReceiveUpdate = false;\n                    }\n                }\n            } else {\n                didReceiveUpdate = false;\n                if (getIsHydrating() && isForkedChild(workInProgress)) {\n                    // Check if this child belongs to a list of muliple children in\n                    // its parent.\n                    //\n                    // In a true multi-threaded implementation, we would render children on\n                    // parallel threads. This would represent the beginning of a new render\n                    // thread for this subtree.\n                    //\n                    // We only use this for id generation during hydration, which is why the\n                    // logic is located in this special branch.\n                    var slotIndex = workInProgress.index;\n                    var numberOfForks = getForksAtLevel();\n                    pushTreeId(workInProgress, numberOfForks, slotIndex);\n                }\n            } // Before entering the begin phase, clear pending update priority.\n            // TODO: This assumes that we're about to evaluate the component and process\n            // the update queue. However, there's an exception: SimpleMemoComponent\n            // sometimes bails out later in the begin phase. This indicates that we should\n            // move this assignment out of the common path and into each branch.\n            workInProgress.lanes = NoLanes;\n            switch(workInProgress.tag){\n                case IndeterminateComponent:\n                    {\n                        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n                    }\n                case LazyComponent:\n                    {\n                        var elementType = workInProgress.elementType;\n                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n                    }\n                case FunctionComponent:\n                    {\n                        var Component = workInProgress.type;\n                        var unresolvedProps = workInProgress.pendingProps;\n                        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n                    }\n                case ClassComponent:\n                    {\n                        var _Component = workInProgress.type;\n                        var _unresolvedProps = workInProgress.pendingProps;\n                        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);\n                    }\n                case HostRoot:\n                    return updateHostRoot(current, workInProgress, renderLanes);\n                case HostComponent:\n                    return updateHostComponent$1(current, workInProgress, renderLanes);\n                case HostText:\n                    return updateHostText$1(current, workInProgress);\n                case SuspenseComponent:\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\n                case HostPortal:\n                    return updatePortalComponent(current, workInProgress, renderLanes);\n                case ForwardRef:\n                    {\n                        var type = workInProgress.type;\n                        var _unresolvedProps2 = workInProgress.pendingProps;\n                        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\n                    }\n                case Fragment:\n                    return updateFragment(current, workInProgress, renderLanes);\n                case Mode:\n                    return updateMode(current, workInProgress, renderLanes);\n                case Profiler:\n                    return updateProfiler(current, workInProgress, renderLanes);\n                case ContextProvider:\n                    return updateContextProvider(current, workInProgress, renderLanes);\n                case ContextConsumer:\n                    return updateContextConsumer(current, workInProgress, renderLanes);\n                case MemoComponent:\n                    {\n                        var _type2 = workInProgress.type;\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n                        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n                        {\n                            if (workInProgress.type !== workInProgress.elementType) {\n                                var outerPropTypes = _type2.propTypes;\n                                if (outerPropTypes) {\n                                    checkPropTypes(outerPropTypes, _resolvedProps3, \"prop\", getComponentNameFromType(_type2));\n                                }\n                            }\n                        }\n                        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n                        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);\n                    }\n                case SimpleMemoComponent:\n                    {\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n                    }\n                case IncompleteClassComponent:\n                    {\n                        var _Component2 = workInProgress.type;\n                        var _unresolvedProps4 = workInProgress.pendingProps;\n                        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n                        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);\n                    }\n                case SuspenseListComponent:\n                    {\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + \"React. Please file an issue.\");\n        }\n        function unwindWork(current, workInProgress, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case ClassComponent:\n                    {\n                        var Component = workInProgress.type;\n                        if (isContextProvider(Component)) {\n                            popContext(workInProgress);\n                        }\n                        var flags = workInProgress.flags;\n                        if (flags & ShouldCapture) {\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        popHostContainer(workInProgress);\n                        popTopLevelContextObject(workInProgress);\n                        resetWorkInProgressVersions();\n                        var _flags = workInProgress.flags;\n                        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n                            // There was an error during render that wasn't captured by a suspense\n                            // boundary. Do a second pass on the root to unmount the children.\n                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n                            return workInProgress;\n                        } // We unwound to the root without completing it. Exit.\n                        return null;\n                    }\n                case HostComponent:\n                    {\n                        // TODO: popHydrationState\n                        popHostContext(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseContext(workInProgress);\n                        {\n                            var suspenseState = workInProgress.memoizedState;\n                            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                                if (workInProgress.alternate === null) {\n                                    throw new Error(\"Threw in newly mounted dehydrated component. This is likely a bug in \" + \"React. Please file an issue.\");\n                                }\n                                resetHydrationState();\n                            }\n                        }\n                        var _flags2 = workInProgress.flags;\n                        if (_flags2 & ShouldCapture) {\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n                        // caught by a nested boundary. If not, it should bubble through.\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    return null;\n                case ContextProvider:\n                    var context = workInProgress.type._context;\n                    popProvider(context, workInProgress);\n                    return null;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popRenderLanes(workInProgress);\n                    return null;\n                case CacheComponent:\n                    return null;\n                default:\n                    return null;\n            }\n        }\n        function unwindInterruptedWork(current, interruptedWork, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(interruptedWork);\n            switch(interruptedWork.tag){\n                case ClassComponent:\n                    {\n                        var childContextTypes = interruptedWork.type.childContextTypes;\n                        if (childContextTypes !== null && childContextTypes !== undefined) {\n                            popContext(interruptedWork);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        popHostContainer(interruptedWork);\n                        popTopLevelContextObject(interruptedWork);\n                        resetWorkInProgressVersions();\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(interruptedWork);\n                        break;\n                    }\n                case HostPortal:\n                    popHostContainer(interruptedWork);\n                    break;\n                case SuspenseComponent:\n                    popSuspenseContext(interruptedWork);\n                    break;\n                case SuspenseListComponent:\n                    popSuspenseContext(interruptedWork);\n                    break;\n                case ContextProvider:\n                    var context = interruptedWork.type._context;\n                    popProvider(context, interruptedWork);\n                    break;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popRenderLanes(interruptedWork);\n                    break;\n            }\n        }\n        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n            var funcArgs = Array.prototype.slice.call(arguments, 3);\n            try {\n                func.apply(context, funcArgs);\n            } catch (error) {\n                this.onError(error);\n            }\n        }\n        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n        {\n            // In DEV mode, we swap out invokeGuardedCallback for a special version\n            // that plays more nicely with the browser's DevTools. The idea is to preserve\n            // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n            // functions in invokeGuardedCallback, and the production version of\n            // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n            // like caught exceptions, and the DevTools won't pause unless the developer\n            // takes the extra step of enabling pause on caught exceptions. This is\n            // unintuitive, though, because even though React has caught the error, from\n            // the developer's perspective, the error is uncaught.\n            //\n            // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n            // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n            // DOM node, and call the user-provided callback from inside an event handler\n            // for that fake event. If the callback throws, the error is \"captured\" using\n            // a global event handler. But because the error happens in a different\n            // event loop context, it does not interrupt the normal program flow.\n            // Effectively, this gives us try-catch behavior without actually using\n            // try-catch. Neat!\n            // Check that the browser supports the APIs we need to implement our special\n            // DEV version of invokeGuardedCallback\n            if (false) { var fakeNode; }\n        }\n        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n        var hasError = false;\n        var caughtError = null; // Used by event system to capture/rethrow the first error.\n        var reporter = {\n            onError: function(error) {\n                hasError = true;\n                caughtError = error;\n            }\n        };\n        /**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */ function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n            hasError = false;\n            caughtError = null;\n            invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n        }\n        function hasCaughtError() {\n            return hasError;\n        }\n        function clearCaughtError() {\n            if (hasError) {\n                var error = caughtError;\n                hasError = false;\n                caughtError = null;\n                return error;\n            } else {\n                throw new Error(\"clearCaughtError was called but no error was captured. This error \" + \"is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n        }\n        // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n        // Only used when enableSuspenseLayoutEffectSemantics is enabled.\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false;\n        var PossiblyWeakSet = typeof WeakSet === \"function\" ? WeakSet : Set;\n        var nextEffect = null; // Used for Profiling builds to track updaters.\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function reportUncaughtErrorInDEV(error) {\n            // Wrapping each small part of the commit phase into a guarded\n            // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n            // But we rely on it to surface errors to DEV tools like overlays\n            // (https://github.com/facebook/react/issues/21712).\n            // As a compromise, rethrow only caught errors in a guard.\n            {\n                invokeGuardedCallback(null, function() {\n                    throw error;\n                });\n                clearCaughtError();\n            }\n        }\n        var callComponentWillUnmountWithTimer = function(current, instance) {\n            instance.props = current.memoizedProps;\n            instance.state = current.memoizedState;\n            if (current.mode & ProfileMode) {\n                try {\n                    startLayoutEffectTimer();\n                    instance.componentWillUnmount();\n                } finally{\n                    recordLayoutEffectDuration(current);\n                }\n            } else {\n                instance.componentWillUnmount();\n            }\n        }; // Capture errors so they don't interrupt mounting.\n        function safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n            try {\n                commitHookEffectListMount(Layout, current);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt unmounting.\n        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n            try {\n                callComponentWillUnmountWithTimer(current, instance);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyAttachRef(current, nearestMountedAncestor) {\n            try {\n                commitAttachRef(current);\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        function safelyDetachRef(current, nearestMountedAncestor) {\n            var ref = current.ref;\n            if (ref !== null) {\n                if (typeof ref === \"function\") {\n                    var retVal;\n                    try {\n                        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                retVal = ref(null);\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            retVal = ref(null);\n                        }\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    }\n                    {\n                        if (typeof retVal === \"function\") {\n                            error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(current));\n                        }\n                    }\n                } else {\n                    ref.current = null;\n                }\n            }\n        }\n        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                reportUncaughtErrorInDEV(error);\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        var focusedInstanceHandle = null;\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root, firstChild) {\n            focusedInstanceHandle = prepareForCommit(root.containerInfo);\n            nextEffect = firstChild;\n            commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n            var shouldFire = shouldFireAfterActiveInstanceBlur;\n            shouldFireAfterActiveInstanceBlur = false;\n            focusedInstanceHandle = null;\n            return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitBeforeMutationEffects_complete();\n                }\n            }\n        }\n        function commitBeforeMutationEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentFiber(fiber);\n                try {\n                    commitBeforeMutationEffectsOnFiber(fiber);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags;\n            if ((flags & Snapshot) !== NoFlags) {\n                setCurrentFiber(finishedWork);\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            if (current !== null) {\n                                var prevProps = current.memoizedProps;\n                                var prevState = current.memoizedState;\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                {\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error(\"Expected %s props to match memoized props before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error(\"Expected %s state to match memoized state before \" + \"getSnapshotBeforeUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                    }\n                                }\n                                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n                                {\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                                        didWarnSet.add(finishedWork.type);\n                                        error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) \" + \"must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n                                    }\n                                }\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                            }\n                            break;\n                        }\n                    case HostRoot:\n                        {\n                            if (supportsMutation) {\n                                var root = finishedWork.stateNode;\n                                clearContainer(root.containerInfo);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                    case HostText:\n                    case HostPortal:\n                    case IncompleteClassComponent:\n                        break;\n                    default:\n                        {\n                            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n                        }\n                }\n                resetCurrentFiber();\n            }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        // Unmount\n                        var destroy = effect.destroy;\n                        effect.destroy = undefined;\n                        if (destroy !== undefined) {\n                            {\n                                if ((flags & Passive$1) !== NoFlags$1) {\n                                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                                } else if ((flags & Layout) !== NoFlags$1) {\n                                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                                }\n                            }\n                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                            {\n                                if ((flags & Passive$1) !== NoFlags$1) {\n                                    markComponentPassiveEffectUnmountStopped();\n                                } else if ((flags & Layout) !== NoFlags$1) {\n                                    markComponentLayoutEffectUnmountStopped();\n                                }\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        {\n                            if ((flags & Passive$1) !== NoFlags$1) {\n                                markComponentPassiveEffectMountStarted(finishedWork);\n                            } else if ((flags & Layout) !== NoFlags$1) {\n                                markComponentLayoutEffectMountStarted(finishedWork);\n                            }\n                        }\n                        var create = effect.create;\n                        effect.destroy = create();\n                        {\n                            if ((flags & Passive$1) !== NoFlags$1) {\n                                markComponentPassiveEffectMountStopped();\n                            } else if ((flags & Layout) !== NoFlags$1) {\n                                markComponentLayoutEffectMountStopped();\n                            }\n                        }\n                        {\n                            var destroy = effect.destroy;\n                            if (destroy !== undefined && typeof destroy !== \"function\") {\n                                var hookName = void 0;\n                                if ((effect.tag & Layout) !== NoFlags) {\n                                    hookName = \"useLayoutEffect\";\n                                } else if ((effect.tag & Insertion) !== NoFlags) {\n                                    hookName = \"useInsertionEffect\";\n                                } else {\n                                    hookName = \"useEffect\";\n                                }\n                                var addendum = void 0;\n                                if (destroy === null) {\n                                    addendum = \" You returned null. If your effect does not require clean \" + \"up, return undefined (or nothing).\";\n                                } else if (typeof destroy.then === \"function\") {\n                                    addendum = \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. \" + \"Instead, write the async function inside your effect \" + \"and call it immediately:\\n\\n\" + hookName + \"(() => {\\n\" + \"  async function fetchData() {\\n\" + \"    // You can await here\\n\" + \"    const response = await MyAPI.getData(someId);\\n\" + \"    // ...\\n\" + \"  }\\n\" + \"  fetchData();\\n\" + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + \"Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching\";\n                                } else {\n                                    addendum = \" You returned: \" + destroy;\n                                }\n                                error(\"%s must not return anything besides a function, \" + \"which is used for clean-up.%s\", hookName, addendum);\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n            {\n                // Only Profilers with work in their subtree will have an Update effect scheduled.\n                if ((finishedWork.flags & Update) !== NoFlags) {\n                    switch(finishedWork.tag){\n                        case Profiler:\n                            {\n                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n                                // It does not get reset until the start of the next commit phase.\n                                var commitTime = getCommitTime();\n                                var phase = finishedWork.alternate === null ? \"mount\" : \"update\";\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = \"nested-update\";\n                                    }\n                                }\n                                if (typeof onPostCommit === \"function\") {\n                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);\n                                } // Bubble times to the next nearest ancestor Profiler.\n                                // After we process that Profiler, we'll bubble further up.\n                                var parentFiber = finishedWork.return;\n                                outer: while(parentFiber !== null){\n                                    switch(parentFiber.tag){\n                                        case HostRoot:\n                                            var root = parentFiber.stateNode;\n                                            root.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                        case Profiler:\n                                            var parentStateNode = parentFiber.stateNode;\n                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                    }\n                                    parentFiber = parentFiber.return;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n            if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            if (!offscreenSubtreeWasHidden) {\n                                // At this point layout effects have already been destroyed (during mutation phase).\n                                // This is done to prevent sibling component effects from interfering with each other,\n                                // e.g. a destroy function in one component should never override a ref set\n                                // by a create function in another component during the same commit.\n                                if (finishedWork.mode & ProfileMode) {\n                                    try {\n                                        startLayoutEffectTimer();\n                                        commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                                    } finally{\n                                        recordLayoutEffectDuration(finishedWork);\n                                    }\n                                } else {\n                                    commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                                }\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = finishedWork.stateNode;\n                            if (finishedWork.flags & Update) {\n                                if (!offscreenSubtreeWasHidden) {\n                                    if (current === null) {\n                                        // We could update instance props and state here,\n                                        // but instead we rely on them being set during last render.\n                                        // TODO: revisit this when we implement resuming.\n                                        {\n                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                                if (instance.props !== finishedWork.memoizedProps) {\n                                                    error(\"Expected %s props to match memoized props before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                                if (instance.state !== finishedWork.memoizedState) {\n                                                    error(\"Expected %s state to match memoized state before \" + \"componentDidMount. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                            }\n                                        }\n                                        if (finishedWork.mode & ProfileMode) {\n                                            try {\n                                                startLayoutEffectTimer();\n                                                instance.componentDidMount();\n                                            } finally{\n                                                recordLayoutEffectDuration(finishedWork);\n                                            }\n                                        } else {\n                                            instance.componentDidMount();\n                                        }\n                                    } else {\n                                        var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                                        var prevState = current.memoizedState; // We could update instance props and state here,\n                                        // but instead we rely on them being set during last render.\n                                        // TODO: revisit this when we implement resuming.\n                                        {\n                                            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                                if (instance.props !== finishedWork.memoizedProps) {\n                                                    error(\"Expected %s props to match memoized props before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                                if (instance.state !== finishedWork.memoizedState) {\n                                                    error(\"Expected %s state to match memoized state before \" + \"componentDidUpdate. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                                }\n                                            }\n                                        }\n                                        if (finishedWork.mode & ProfileMode) {\n                                            try {\n                                                startLayoutEffectTimer();\n                                                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                                            } finally{\n                                                recordLayoutEffectDuration(finishedWork);\n                                            }\n                                        } else {\n                                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                                        }\n                                    }\n                                }\n                            } // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                {\n                                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error(\"Expected %s props to match memoized props before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.props`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error(\"Expected %s state to match memoized state before \" + \"processing the update queue. \" + \"This might either be because of a bug in React, or because \" + \"a component reassigns its own `this.state`. \" + \"Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                                        }\n                                    }\n                                }\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                commitUpdateQueue(finishedWork, updateQueue, instance);\n                            }\n                            break;\n                        }\n                    case HostRoot:\n                        {\n                            // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var _updateQueue = finishedWork.updateQueue;\n                            if (_updateQueue !== null) {\n                                var _instance = null;\n                                if (finishedWork.child !== null) {\n                                    switch(finishedWork.child.tag){\n                                        case HostComponent:\n                                            _instance = getPublicInstance(finishedWork.child.stateNode);\n                                            break;\n                                        case ClassComponent:\n                                            _instance = finishedWork.child.stateNode;\n                                            break;\n                                    }\n                                }\n                                commitUpdateQueue(finishedWork, _updateQueue, _instance);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n                            // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                            // These effects should only be committed when components are first mounted,\n                            // aka when there is no current/alternate.\n                            if (current === null && finishedWork.flags & Update) {\n                                var type = finishedWork.type;\n                                var props = finishedWork.memoizedProps;\n                                commitMount(_instance2, type, props, finishedWork);\n                            }\n                            break;\n                        }\n                    case HostText:\n                        {\n                            break;\n                        }\n                    case HostPortal:\n                        {\n                            break;\n                        }\n                    case Profiler:\n                        {\n                            {\n                                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                                var effectDuration = finishedWork.stateNode.effectDuration;\n                                var commitTime = getCommitTime();\n                                var phase = current === null ? \"mount\" : \"update\";\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = \"nested-update\";\n                                    }\n                                }\n                                if (typeof onRender === \"function\") {\n                                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n                                }\n                                {\n                                    if (typeof onCommit === \"function\") {\n                                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n                                    } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n                                    // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n                                    // because the effect is also where times bubble to parent Profilers.\n                                    enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n                                    // Do not reset these values until the next render so DevTools has a chance to read them first.\n                                    var parentFiber = finishedWork.return;\n                                    outer: while(parentFiber !== null){\n                                        switch(parentFiber.tag){\n                                            case HostRoot:\n                                                var root = parentFiber.stateNode;\n                                                root.effectDuration += effectDuration;\n                                                break outer;\n                                            case Profiler:\n                                                var parentStateNode = parentFiber.stateNode;\n                                                parentStateNode.effectDuration += effectDuration;\n                                                break outer;\n                                        }\n                                        parentFiber = parentFiber.return;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case SuspenseComponent:\n                        {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                            break;\n                        }\n                    case SuspenseListComponent:\n                    case IncompleteClassComponent:\n                    case ScopeComponent:\n                    case OffscreenComponent:\n                    case LegacyHiddenComponent:\n                        {\n                            break;\n                        }\n                    default:\n                        throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n                }\n            }\n            if (!offscreenSubtreeWasHidden) {\n                {\n                    if (finishedWork.flags & Ref) {\n                        commitAttachRef(finishedWork);\n                    }\n                }\n            }\n        }\n        function reappearLayoutEffectsOnFiber(node) {\n            // Turn on layout effects in a tree that previously disappeared.\n            // TODO (Offscreen) Check: flags & LayoutStatic\n            switch(node.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (node.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                            } finally{\n                                recordLayoutEffectDuration(node);\n                            }\n                        } else {\n                            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                        }\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        var instance = node.stateNode;\n                        if (typeof instance.componentDidMount === \"function\") {\n                            safelyCallComponentDidMount(node, node.return, instance);\n                        }\n                        safelyAttachRef(node, node.return);\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        safelyAttachRef(node, node.return);\n                        break;\n                    }\n            }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n            // Only hide or unhide the top-most host nodes.\n            var hostSubtreeRoot = null;\n            if (supportsMutation) {\n                // We only have the top Fiber that was inserted but we need to recurse down its\n                // children to find all the terminal nodes.\n                var node = finishedWork;\n                while(true){\n                    if (node.tag === HostComponent) {\n                        if (hostSubtreeRoot === null) {\n                            hostSubtreeRoot = node;\n                            var instance = node.stateNode;\n                            if (isHidden) {\n                                hideInstance(instance);\n                            } else {\n                                unhideInstance(node.stateNode, node.memoizedProps);\n                            }\n                        }\n                    } else if (node.tag === HostText) {\n                        if (hostSubtreeRoot === null) {\n                            var _instance3 = node.stateNode;\n                            if (isHidden) {\n                                hideTextInstance(_instance3);\n                            } else {\n                                unhideTextInstance(_instance3, node.memoizedProps);\n                            }\n                        }\n                    } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === finishedWork) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === finishedWork) {\n                            return;\n                        }\n                        if (hostSubtreeRoot === node) {\n                            hostSubtreeRoot = null;\n                        }\n                        node = node.return;\n                    }\n                    if (hostSubtreeRoot === node) {\n                        hostSubtreeRoot = null;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function commitAttachRef(finishedWork) {\n            var ref = finishedWork.ref;\n            if (ref !== null) {\n                var instance = finishedWork.stateNode;\n                var instanceToUse;\n                switch(finishedWork.tag){\n                    case HostComponent:\n                        instanceToUse = getPublicInstance(instance);\n                        break;\n                    default:\n                        instanceToUse = instance;\n                } // Moved outside to ensure DCE works with this flag\n                if (typeof ref === \"function\") {\n                    var retVal;\n                    if (finishedWork.mode & ProfileMode) {\n                        try {\n                            startLayoutEffectTimer();\n                            retVal = ref(instanceToUse);\n                        } finally{\n                            recordLayoutEffectDuration(finishedWork);\n                        }\n                    } else {\n                        retVal = ref(instanceToUse);\n                    }\n                    {\n                        if (typeof retVal === \"function\") {\n                            error(\"Unexpected return value from a callback ref in %s. \" + \"A callback ref should not return a function.\", getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                } else {\n                    {\n                        if (!ref.hasOwnProperty(\"current\")) {\n                            error(\"Unexpected ref object provided for %s. \" + \"Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                    ref.current = instanceToUse;\n                }\n            }\n        }\n        function commitDetachRef(current) {\n            var currentRef = current.ref;\n            if (currentRef !== null) {\n                if (typeof currentRef === \"function\") {\n                    if (current.mode & ProfileMode) {\n                        try {\n                            startLayoutEffectTimer();\n                            currentRef(null);\n                        } finally{\n                            recordLayoutEffectDuration(current);\n                        }\n                    } else {\n                        currentRef(null);\n                    }\n                } else {\n                    currentRef.current = null;\n                }\n            }\n        } // User-originating errors (lifecycles and refs) should not interrupt\n        // deletion, so don't let them throw. Host-originating errors should\n        // interrupt deletion, so it's okay\n        function commitUnmount(finishedRoot, current, nearestMountedAncestor) {\n            onCommitUnmount(current);\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        var updateQueue = current.updateQueue;\n                        if (updateQueue !== null) {\n                            var lastEffect = updateQueue.lastEffect;\n                            if (lastEffect !== null) {\n                                var firstEffect = lastEffect.next;\n                                var effect = firstEffect;\n                                do {\n                                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;\n                                    if (destroy !== undefined) {\n                                        if ((tag & Insertion) !== NoFlags$1) {\n                                            safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                        } else if ((tag & Layout) !== NoFlags$1) {\n                                            {\n                                                markComponentLayoutEffectUnmountStarted(current);\n                                            }\n                                            if (current.mode & ProfileMode) {\n                                                startLayoutEffectTimer();\n                                                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                                recordLayoutEffectDuration(current);\n                                            } else {\n                                                safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                                            }\n                                            {\n                                                markComponentLayoutEffectUnmountStopped();\n                                            }\n                                        }\n                                    }\n                                    effect = effect.next;\n                                }while (effect !== firstEffect);\n                            }\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        safelyDetachRef(current, nearestMountedAncestor);\n                        var instance = current.stateNode;\n                        if (typeof instance.componentWillUnmount === \"function\") {\n                            safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance);\n                        }\n                        return;\n                    }\n                case HostComponent:\n                    {\n                        safelyDetachRef(current, nearestMountedAncestor);\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        // TODO: this is recursive.\n                        // We are also not using this parent because\n                        // the portal will get pushed immediately.\n                        if (supportsMutation) {\n                            unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n                        } else if (supportsPersistence) {\n                            emptyPortalContainer(current);\n                        }\n                        return;\n                    }\n                case DehydratedFragment:\n                    {\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        return;\n                    }\n            }\n        }\n        function commitNestedUnmounts(finishedRoot, root, nearestMountedAncestor) {\n            // While we're inside a removed host node we don't want to call\n            // removeChild on the inner nodes because they're removed by the top\n            // call anyway. We also want to call componentWillUnmount on all\n            // composites before this host node is removed from the tree. Therefore\n            // we do an inner loop while we're still inside the host node.\n            var node = root;\n            while(true){\n                commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because they may contain more composite or host nodes.\n                // Skip portals because commitUnmount() currently visits them recursively.\n                if (node.child !== null && // If we don't use mutation we drill down into portals here instead.\n                (!supportsMutation || node.tag !== HostPortal)) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === root) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === root) {\n                        return;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function detachFiberMutation(fiber) {\n            // Cut off the return pointer to disconnect it from the tree.\n            // This enables us to detect and warn against state updates on an unmounted component.\n            // It also prevents events from bubbling from within disconnected components.\n            //\n            // Ideally, we should also clear the child pointer of the parent alternate to let this\n            // get GC:ed but we don't know which for sure which parent is the current\n            // one so we'll settle for GC:ing the subtree of this child.\n            // This child itself will be GC:ed when the parent updates the next time.\n            //\n            // Note that we can't clear child or sibling pointers yet.\n            // They're needed for passive effects and for findDOMNode.\n            // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n            //\n            // Don't reset the alternate yet, either. We need that so we can detach the\n            // alternate's fields in the passive phase. Clearing the return pointer is\n            // sufficient for findDOMNode semantics.\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.return = null;\n            }\n            fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                fiber.alternate = null;\n                detachFiberAfterEffects(alternate);\n            } // Note: Defensively using negation instead of < in case\n            // `deletedTreeCleanUpLevel` is undefined.\n            {\n                // Clear cyclical Fiber fields. This level alone is designed to roughly\n                // approximate the planned Fiber refactor. In that world, `setState` will be\n                // bound to a special \"instance\" object instead of a Fiber. The Instance\n                // object will not have any of these fields. It will only be connected to\n                // the fiber tree via a single link at the root. So if this level alone is\n                // sufficient to fix memory issues, that bodes well for our plans.\n                fiber.child = null;\n                fiber.deletions = null;\n                fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n                // tree, which has its own pointers to children, parents, and siblings.\n                // The other host nodes also point back to fibers, so we should detach that\n                // one, too.\n                if (fiber.tag === HostComponent) {\n                    var hostInstance = fiber.stateNode;\n                    if (hostInstance !== null) {\n                        detachDeletedInstance(hostInstance);\n                    }\n                }\n                fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n                // already disconnect the `return` pointer at the root of the deleted\n                // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n                // cyclical — it's only cyclical when combined with `child`, `sibling`, and\n                // `alternate`. But we'll clear it in the next level anyway, just in case.\n                {\n                    fiber._debugOwner = null;\n                }\n                {\n                    // Theoretically, nothing in here should be necessary, because we already\n                    // disconnected the fiber from the tree. So even if something leaks this\n                    // particular fiber, it won't leak anything else\n                    //\n                    // The purpose of this branch is to be super aggressive so we can measure\n                    // if there's any difference in memory impact. If there is, that could\n                    // indicate a React leak we don't know about.\n                    fiber.return = null;\n                    fiber.dependencies = null;\n                    fiber.memoizedProps = null;\n                    fiber.memoizedState = null;\n                    fiber.pendingProps = null;\n                    fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n                    fiber.updateQueue = null;\n                }\n            }\n        }\n        function emptyPortalContainer(current) {\n            if (!supportsPersistence) {\n                return;\n            }\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet(containerInfo);\n            replaceContainerChildren(containerInfo, emptyChildSet);\n        }\n        function commitContainer(finishedWork) {\n            if (!supportsPersistence) {\n                return;\n            }\n            switch(finishedWork.tag){\n                case ClassComponent:\n                case HostComponent:\n                case HostText:\n                    {\n                        return;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var portalOrRoot = finishedWork.stateNode;\n                        var containerInfo = portalOrRoot.containerInfo, pendingChildren = portalOrRoot.pendingChildren;\n                        replaceContainerChildren(containerInfo, pendingChildren);\n                        return;\n                    }\n            }\n            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n        }\n        function getHostParentFiber(fiber) {\n            var parent = fiber.return;\n            while(parent !== null){\n                if (isHostParent(parent)) {\n                    return parent;\n                }\n                parent = parent.return;\n            }\n            throw new Error(\"Expected to find a host parent. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n        }\n        function isHostParent(fiber) {\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n            // We're going to search forward into the tree until we find a sibling host\n            // node. Unfortunately, if multiple insertions are done in a row we have to\n            // search past them. This leads to exponential search for the next sibling.\n            // TODO: Find a more efficient way to do this.\n            var node = fiber;\n            siblings: while(true){\n                // If we didn't find anything, let's try the next sibling.\n                while(node.sibling === null){\n                    if (node.return === null || isHostParent(node.return)) {\n                        // If we pop out of the root or hit the parent the fiber we are the\n                        // last sibling.\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n                while(node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment){\n                    // If it is not host node and, we might have a host node inside it.\n                    // Try to search down until we find one.\n                    if (node.flags & Placement) {\n                        continue siblings;\n                    } // If we don't have a child, try the siblings instead.\n                    // We also skip portals because they are not part of this host tree.\n                    if (node.child === null || node.tag === HostPortal) {\n                        continue siblings;\n                    } else {\n                        node.child.return = node;\n                        node = node.child;\n                    }\n                } // Check if this host node is stable or about to be placed.\n                if (!(node.flags & Placement)) {\n                    // Found it!\n                    return node.stateNode;\n                }\n            }\n        }\n        function commitPlacement(finishedWork) {\n            if (!supportsMutation) {\n                return;\n            } // Recursively insert all host nodes into the parent.\n            var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n            switch(parentFiber.tag){\n                case HostComponent:\n                    {\n                        var parent = parentFiber.stateNode;\n                        if (parentFiber.flags & ContentReset) {\n                            // Reset the text content of the parent before doing any insertions\n                            resetTextContent(parent); // Clear ContentReset from the effect tag\n                            parentFiber.flags &= ~ContentReset;\n                        }\n                        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                        // children to find all the terminal nodes.\n                        insertOrAppendPlacementNode(finishedWork, before, parent);\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var _parent = parentFiber.stateNode.containerInfo;\n                        var _before = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n                        break;\n                    }\n                // eslint-disable-next-line-no-fallthrough\n                default:\n                    throw new Error(\"Invalid host parent fiber. This error is likely caused by a bug \" + \"in React. Please file an issue.\");\n            }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertInContainerBefore(parent, stateNode, before);\n                } else {\n                    appendChildToContainer(parent, stateNode);\n                }\n            } else if (tag === HostPortal) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertBefore(parent, stateNode, before);\n                } else {\n                    appendChild(parent, stateNode);\n                }\n            } else if (tag === HostPortal) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNode(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNode(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function unmountHostComponents(finishedRoot, current, nearestMountedAncestor) {\n            // We only have the top Fiber that was deleted but we need to recurse down its\n            // children to find all the terminal nodes.\n            var node = current; // Each iteration, currentParent is populated with node's host parent if not\n            // currentParentIsValid.\n            var currentParentIsValid = false; // Note: these two variables *must* always be updated together.\n            var currentParent;\n            var currentParentIsContainer;\n            while(true){\n                if (!currentParentIsValid) {\n                    var parent = node.return;\n                    findParent: while(true){\n                        if (parent === null) {\n                            throw new Error(\"Expected to find a host parent. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n                        }\n                        var parentStateNode = parent.stateNode;\n                        switch(parent.tag){\n                            case HostComponent:\n                                currentParent = parentStateNode;\n                                currentParentIsContainer = false;\n                                break findParent;\n                            case HostRoot:\n                                currentParent = parentStateNode.containerInfo;\n                                currentParentIsContainer = true;\n                                break findParent;\n                            case HostPortal:\n                                currentParent = parentStateNode.containerInfo;\n                                currentParentIsContainer = true;\n                                break findParent;\n                        }\n                        parent = parent.return;\n                    }\n                    currentParentIsValid = true;\n                }\n                if (node.tag === HostComponent || node.tag === HostText) {\n                    commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor); // After all the children have unmounted, it is now safe to remove the\n                    // node from the tree.\n                    if (currentParentIsContainer) {\n                        removeChildFromContainer(currentParent, node.stateNode);\n                    } else {\n                        removeChild(currentParent, node.stateNode);\n                    } // Don't visit children because we already visited them.\n                } else if (node.tag === DehydratedFragment) {\n                    if (currentParentIsContainer) {\n                        clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);\n                    } else {\n                        clearSuspenseBoundary(currentParent, node.stateNode);\n                    }\n                } else if (node.tag === HostPortal) {\n                    if (node.child !== null) {\n                        // When we go into a portal, it becomes the parent to remove from.\n                        // We will reassign it back when we pop the portal on the way up.\n                        currentParent = node.stateNode.containerInfo;\n                        currentParentIsContainer = true; // Visit children because portals might contain host components.\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                } else {\n                    commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because we may find more host components below.\n                    if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                }\n                if (node === current) {\n                    return;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === current) {\n                        return;\n                    }\n                    node = node.return;\n                    if (node.tag === HostPortal) {\n                        // When we go out of the portal, we need to restore the parent.\n                        // Since we don't keep a stack of them, we will search for it.\n                        currentParentIsValid = false;\n                    }\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function commitDeletion(finishedRoot, current, nearestMountedAncestor) {\n            if (supportsMutation) {\n                // Recursively delete all host nodes from the parent.\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n            } else {\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                commitNestedUnmounts(finishedRoot, current, nearestMountedAncestor);\n            }\n            detachFiberMutation(current);\n        }\n        function commitWork(current, finishedWork) {\n            if (!supportsMutation) {\n                switch(finishedWork.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                            commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n                            // destroy functions for all fibers are called before any create functions.\n                            // This prevents sibling component effects from interfering with each other,\n                            // e.g. a destroy function in one component should never override a ref set\n                            // by a create function in another component during the same commit.\n                            // TODO: Check if we're inside an Offscreen subtree that disappeared\n                            // during this commit. If so, we would have already unmounted its\n                            // layout hooks. (However, since we null out the `destroy` function\n                            // right before calling it, the behavior is already correct, so this\n                            // would mostly be for modeling purposes.)\n                            if (finishedWork.mode & ProfileMode) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } finally{\n                                    recordLayoutEffectDuration(finishedWork);\n                                }\n                            } else {\n                                commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                            }\n                            return;\n                        }\n                    case Profiler:\n                        {\n                            return;\n                        }\n                    case SuspenseComponent:\n                        {\n                            commitSuspenseCallback(finishedWork);\n                            attachSuspenseRetryListeners(finishedWork);\n                            return;\n                        }\n                    case SuspenseListComponent:\n                        {\n                            attachSuspenseRetryListeners(finishedWork);\n                            return;\n                        }\n                    case HostRoot:\n                        {\n                            if (supportsHydration) {\n                                if (current !== null) {\n                                    var prevRootState = current.memoizedState;\n                                    if (prevRootState.isDehydrated) {\n                                        var root = finishedWork.stateNode;\n                                        commitHydratedContainer(root.containerInfo);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case OffscreenComponent:\n                    case LegacyHiddenComponent:\n                        {\n                            return;\n                        }\n                }\n                commitContainer(finishedWork);\n                return;\n            }\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                        commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n                        // destroy functions for all fibers are called before any create functions.\n                        // This prevents sibling component effects from interfering with each other,\n                        // e.g. a destroy function in one component should never override a ref set\n                        // by a create function in another component during the same commit.\n                        if (finishedWork.mode & ProfileMode) {\n                            try {\n                                startLayoutEffectTimer();\n                                commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                            } finally{\n                                recordLayoutEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        return;\n                    }\n                case HostComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        if (instance != null) {\n                            // Commit the work prepared earlier.\n                            var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                            // as the newProps. The updatePayload will contain the real change in\n                            // this case.\n                            var oldProps = current !== null ? current.memoizedProps : newProps;\n                            var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n                            var updatePayload = finishedWork.updateQueue;\n                            finishedWork.updateQueue = null;\n                            if (updatePayload !== null) {\n                                commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                            }\n                        }\n                        return;\n                    }\n                case HostText:\n                    {\n                        if (finishedWork.stateNode === null) {\n                            throw new Error(\"This should have a text node initialized. This error is likely \" + \"caused by a bug in React. Please file an issue.\");\n                        }\n                        var textInstance = finishedWork.stateNode;\n                        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                        // as the newProps. The updatePayload will contain the real change in\n                        // this case.\n                        var oldText = current !== null ? current.memoizedProps : newText;\n                        commitTextUpdate(textInstance, oldText, newText);\n                        return;\n                    }\n                case HostRoot:\n                    {\n                        if (supportsHydration) {\n                            if (current !== null) {\n                                var _prevRootState = current.memoizedState;\n                                if (_prevRootState.isDehydrated) {\n                                    var _root = finishedWork.stateNode;\n                                    commitHydratedContainer(_root.containerInfo);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case Profiler:\n                    {\n                        return;\n                    }\n                case SuspenseComponent:\n                    {\n                        commitSuspenseCallback(finishedWork);\n                        attachSuspenseRetryListeners(finishedWork);\n                        return;\n                    }\n                case SuspenseListComponent:\n                    {\n                        attachSuspenseRetryListeners(finishedWork);\n                        return;\n                    }\n                case IncompleteClassComponent:\n                    {\n                        return;\n                    }\n            }\n            throw new Error(\"This unit of work tag should not have side-effects. This error is \" + \"likely caused by a bug in React. Please file an issue.\");\n        }\n        function commitSuspenseCallback(finishedWork) {\n            // TODO: Move this to passive phase\n            var newState = finishedWork.memoizedState;\n        }\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n            if (!supportsHydration) {\n                return;\n            }\n            var newState = finishedWork.memoizedState;\n            if (newState === null) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        var suspenseInstance = prevState.dehydrated;\n                        if (suspenseInstance !== null) {\n                            commitHydratedSuspenseInstance(suspenseInstance);\n                        }\n                    }\n                }\n            }\n        }\n        function attachSuspenseRetryListeners(finishedWork) {\n            // If this boundary just timed out, then it will have a set of wakeables.\n            // For each wakeable, attach a listener so that when it resolves, React\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\n            var wakeables = finishedWork.updateQueue;\n            if (wakeables !== null) {\n                finishedWork.updateQueue = null;\n                var retryCache = finishedWork.stateNode;\n                if (retryCache === null) {\n                    retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n                }\n                wakeables.forEach(function(wakeable) {\n                    // Memoize using the boundary fiber to prevent redundant listeners.\n                    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                    if (!retryCache.has(wakeable)) {\n                        retryCache.add(wakeable);\n                        {\n                            if (isDevToolsPresent) {\n                                if (inProgressLanes !== null && inProgressRoot !== null) {\n                                    // If we have pending work still, associate the original updaters with it.\n                                    restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                                } else {\n                                    throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                                }\n                            }\n                        }\n                        wakeable.then(retry, retry);\n                    }\n                });\n            }\n        } // This function detects when a Suspense boundary goes from visible to hidden.\n        function commitResetTextContent(current) {\n            if (!supportsMutation) {\n                return;\n            }\n            resetTextContent(current.stateNode);\n        }\n        function commitMutationEffects(root, firstChild, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            nextEffect = firstChild;\n            commitMutationEffects_begin(root, committedLanes);\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function commitMutationEffects_begin(root, lanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // TODO: Should wrap this in flags check, too, as optimization\n                var deletions = fiber.deletions;\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i];\n                        try {\n                            commitDeletion(root, childToDelete, fiber);\n                        } catch (error) {\n                            reportUncaughtErrorInDEV(error);\n                            captureCommitPhaseError(childToDelete, fiber, error);\n                        }\n                    }\n                }\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitMutationEffects_complete(root, lanes);\n                }\n            }\n        }\n        function commitMutationEffects_complete(root, lanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentFiber(fiber);\n                try {\n                    commitMutationEffectsOnFiber(fiber, root, lanes);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n            // TODO: The factoring of this phase could probably be improved. Consider\n            // switching on the type of work before checking the flags. That's what\n            // we do in all the other phases. I think this one is only different\n            // because of the shared reconciliation logic below.\n            var flags = finishedWork.flags;\n            if (flags & ContentReset) {\n                commitResetTextContent(finishedWork);\n            }\n            if (flags & Ref) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    commitDetachRef(current);\n                }\n            }\n            if (flags & Visibility) {\n                switch(finishedWork.tag){\n                    case SuspenseComponent:\n                        {\n                            var newState = finishedWork.memoizedState;\n                            var isHidden = newState !== null;\n                            if (isHidden) {\n                                var _current = finishedWork.alternate;\n                                var wasHidden = _current !== null && _current.memoizedState !== null;\n                                if (!wasHidden) {\n                                    // TODO: Move to passive phase\n                                    markCommitTimeOfFallback();\n                                }\n                            }\n                            break;\n                        }\n                    case OffscreenComponent:\n                        {\n                            var _newState = finishedWork.memoizedState;\n                            var _isHidden = _newState !== null;\n                            var _current2 = finishedWork.alternate;\n                            var _wasHidden = _current2 !== null && _current2.memoizedState !== null;\n                            var offscreenBoundary = finishedWork;\n                            if (supportsMutation) {\n                                // TODO: This needs to run whenever there's an insertion or update\n                                // inside a hidden Offscreen tree.\n                                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n                            }\n                            {\n                                if (_isHidden) {\n                                    if (!_wasHidden) {\n                                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                                            nextEffect = offscreenBoundary;\n                                            var offscreenChild = offscreenBoundary.child;\n                                            while(offscreenChild !== null){\n                                                nextEffect = offscreenChild;\n                                                disappearLayoutEffects_begin(offscreenChild);\n                                                offscreenChild = offscreenChild.sibling;\n                                            }\n                                        }\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                }\n            } // The following switch statement is only concerned about placement,\n            // updates, and deletions. To avoid needing to add a case for every possible\n            // bitmap value, we remove the secondary effects from the effect tag and\n            // switch on that value.\n            var primaryFlags = flags & (Placement | Update | Hydrating);\n            switch(primaryFlags){\n                case Placement:\n                    {\n                        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n                        // inserted, before any life-cycles like componentDidMount gets called.\n                        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n                        // and isMounted is deprecated anyway so we should be able to kill this.\n                        finishedWork.flags &= ~Placement;\n                        break;\n                    }\n                case PlacementAndUpdate:\n                    {\n                        // Placement\n                        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n                        // inserted, before any life-cycles like componentDidMount gets called.\n                        finishedWork.flags &= ~Placement; // Update\n                        var _current3 = finishedWork.alternate;\n                        commitWork(_current3, finishedWork);\n                        break;\n                    }\n                case Hydrating:\n                    {\n                        finishedWork.flags &= ~Hydrating;\n                        break;\n                    }\n                case HydratingAndUpdate:\n                    {\n                        finishedWork.flags &= ~Hydrating; // Update\n                        var _current4 = finishedWork.alternate;\n                        commitWork(_current4, finishedWork);\n                        break;\n                    }\n                case Update:\n                    {\n                        var _current5 = finishedWork.alternate;\n                        commitWork(_current5, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitLayoutEffects(finishedWork, root, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            nextEffect = finishedWork;\n            commitLayoutEffects_begin(finishedWork, root, committedLanes);\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n            // Suspense layout effects semantics don't change for legacy roots.\n            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if (fiber.tag === OffscreenComponent && isModernRoot) {\n                    // Keep track of the current Offscreen stack's state.\n                    var isHidden = fiber.memoizedState !== null;\n                    var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n                    if (newOffscreenSubtreeIsHidden) {\n                        // The Offscreen tree is hidden. Skip over its layout effects.\n                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                        continue;\n                    } else {\n                        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n                        var current = fiber.alternate;\n                        var wasHidden = current !== null && current.memoizedState !== null;\n                        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n                        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                            // This is the root of a reappearing boundary. Turn its layout effects\n                            // back on.\n                            nextEffect = fiber;\n                            reappearLayoutEffects_begin(fiber);\n                        }\n                        var child = firstChild;\n                        while(child !== null){\n                            nextEffect = child;\n                            commitLayoutEffects_begin(child, root, committedLanes);\n                            child = child.sibling;\n                        } // Restore Offscreen state and resume in our-progress traversal.\n                        nextEffect = fiber;\n                        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                        continue;\n                    }\n                }\n                if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n                    ensureCorrectReturnPointer(firstChild, fiber);\n                    nextEffect = firstChild;\n                } else {\n                    commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n                }\n            }\n        }\n        function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & LayoutMask) !== NoFlags) {\n                    var current = fiber.alternate;\n                    setCurrentFiber(fiber);\n                    try {\n                        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(fiber, fiber.return, error);\n                    }\n                    resetCurrentFiber();\n                }\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function disappearLayoutEffects_begin(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if (fiber.mode & ProfileMode) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                                } finally{\n                                    recordLayoutEffectDuration(fiber);\n                                }\n                            } else {\n                                commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            // TODO (Offscreen) Check: flags & RefStatic\n                            safelyDetachRef(fiber, fiber.return);\n                            var instance = fiber.stateNode;\n                            if (typeof instance.componentWillUnmount === \"function\") {\n                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                            }\n                            break;\n                        }\n                    case HostComponent:\n                        {\n                            safelyDetachRef(fiber, fiber.return);\n                            break;\n                        }\n                    case OffscreenComponent:\n                        {\n                            // Check if this is a\n                            var isHidden = fiber.memoizedState !== null;\n                            if (isHidden) {\n                                // Nested Offscreen tree is already hidden. Don't disappear\n                                // its effects.\n                                disappearLayoutEffects_complete(subtreeRoot);\n                                continue;\n                            }\n                            break;\n                        }\n                } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n                if (firstChild !== null) {\n                    firstChild.return = fiber;\n                    nextEffect = firstChild;\n                } else {\n                    disappearLayoutEffects_complete(subtreeRoot);\n                }\n            }\n        }\n        function disappearLayoutEffects_complete(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function reappearLayoutEffects_begin(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if (fiber.tag === OffscreenComponent) {\n                    var isHidden = fiber.memoizedState !== null;\n                    if (isHidden) {\n                        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n                        reappearLayoutEffects_complete(subtreeRoot);\n                        continue;\n                    }\n                } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n                if (firstChild !== null) {\n                    // This node may have been reused from a previous render, so we can't\n                    // assume its return pointer is correct.\n                    firstChild.return = fiber;\n                    nextEffect = firstChild;\n                } else {\n                    reappearLayoutEffects_complete(subtreeRoot);\n                }\n            }\n        }\n        function reappearLayoutEffects_complete(subtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n                setCurrentFiber(fiber);\n                try {\n                    reappearLayoutEffectsOnFiber(fiber);\n                } catch (error) {\n                    reportUncaughtErrorInDEV(error);\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentFiber();\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    // This node may have been reused from a previous render, so we can't\n                    // assume its return pointer is correct.\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveMountEffects(root, finishedWork) {\n            nextEffect = finishedWork;\n            commitPassiveMountEffects_begin(finishedWork, root);\n        }\n        function commitPassiveMountEffects_begin(subtreeRoot, root) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var firstChild = fiber.child;\n                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n                    ensureCorrectReturnPointer(firstChild, fiber);\n                    nextEffect = firstChild;\n                } else {\n                    commitPassiveMountEffects_complete(subtreeRoot, root);\n                }\n            }\n        }\n        function commitPassiveMountEffects_complete(subtreeRoot, root) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & Passive) !== NoFlags) {\n                    setCurrentFiber(fiber);\n                    try {\n                        commitPassiveMountOnFiber(root, fiber);\n                    } catch (error) {\n                        reportUncaughtErrorInDEV(error);\n                        captureCommitPhaseError(fiber, fiber.return, error);\n                    }\n                    resetCurrentFiber();\n                }\n                if (fiber === subtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (finishedWork.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            try {\n                                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                            } finally{\n                                recordPassiveEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                        }\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffects(firstChild) {\n            nextEffect = firstChild;\n            commitPassiveUnmountEffects_begin();\n        }\n        function commitPassiveUnmountEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var child = fiber.child;\n                if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n                    var deletions = fiber.deletions;\n                    if (deletions !== null) {\n                        for(var i = 0; i < deletions.length; i++){\n                            var fiberToDelete = deletions[i];\n                            nextEffect = fiberToDelete;\n                            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n                        }\n                        {\n                            // A fiber was deleted from this parent fiber, but it's still part of\n                            // the previous (alternate) parent fiber's list of children. Because\n                            // children are a linked list, an earlier sibling that's still alive\n                            // will be connected to the deleted fiber via its `alternate`:\n                            //\n                            //   live fiber\n                            //   --alternate--> previous live fiber\n                            //   --sibling--> deleted fiber\n                            //\n                            // We can't disconnect `alternate` on nodes that haven't been deleted\n                            // yet, but we can disconnect the `sibling` and `child` pointers.\n                            var previousFiber = fiber.alternate;\n                            if (previousFiber !== null) {\n                                var detachedChild = previousFiber.child;\n                                if (detachedChild !== null) {\n                                    previousFiber.child = null;\n                                    do {\n                                        var detachedSibling = detachedChild.sibling;\n                                        detachedChild.sibling = null;\n                                        detachedChild = detachedSibling;\n                                    }while (detachedChild !== null);\n                                }\n                            }\n                        }\n                        nextEffect = fiber;\n                    }\n                }\n                if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffects_complete();\n                }\n            }\n        }\n        function commitPassiveUnmountEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                if ((fiber.flags & Passive) !== NoFlags) {\n                    setCurrentFiber(fiber);\n                    commitPassiveUnmountOnFiber(fiber);\n                    resetCurrentFiber();\n                }\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, fiber.return);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (finishedWork.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                            recordPassiveEffectDuration(finishedWork);\n                        } else {\n                            commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // Deletion effects fire in parent -> child order\n                // TODO: Check if fiber has a PassiveStatic flag\n                setCurrentFiber(fiber);\n                commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n                resetCurrentFiber();\n                var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n                // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n                if (child !== null) {\n                    ensureCorrectReturnPointer(child, fiber);\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n                }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var sibling = fiber.sibling;\n                var returnFiber = fiber.return;\n                {\n                    // Recursively traverse the entire deleted tree and clean up fiber fields.\n                    // This is more aggressive than ideal, and the long term goal is to only\n                    // have to detach the deleted tree at the root.\n                    detachFiberAfterEffects(fiber);\n                    if (fiber === deletedSubtreeRoot) {\n                        nextEffect = null;\n                        return;\n                    }\n                }\n                if (sibling !== null) {\n                    ensureCorrectReturnPointer(sibling, returnFiber);\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        if (current.mode & ProfileMode) {\n                            startPassiveEffectTimer();\n                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n                            recordPassiveEffectDuration(current);\n                        } else {\n                            commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n                        }\n                        break;\n                    }\n            }\n        }\n        var didWarnWrongReturnPointer = false;\n        function ensureCorrectReturnPointer(fiber, expectedReturnFiber) {\n            {\n                if (!didWarnWrongReturnPointer && fiber.return !== expectedReturnFiber) {\n                    didWarnWrongReturnPointer = true;\n                    error(\"Internal React error: Return pointer is inconsistent \" + \"with parent.\");\n                }\n            }\n            // anything, by checking the warning logs for the above invariant\n            fiber.return = expectedReturnFiber;\n        } // TODO: Reuse reappearLayoutEffects traversal here?\n        function invokeLayoutEffectMountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListMount(Layout | HasEffect, fiber);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = fiber.stateNode;\n                            try {\n                                instance.componentDidMount();\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokePassiveEffectMountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokeLayoutEffectUnmountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                            break;\n                        }\n                    case ClassComponent:\n                        {\n                            var instance = fiber.stateNode;\n                            if (typeof instance.componentWillUnmount === \"function\") {\n                                safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                            }\n                            break;\n                        }\n                }\n            }\n        }\n        function invokePassiveEffectUnmountInDEV(fiber) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                switch(fiber.tag){\n                    case FunctionComponent:\n                    case ForwardRef:\n                    case SimpleMemoComponent:\n                        {\n                            try {\n                                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n                            } catch (error) {\n                                reportUncaughtErrorInDEV(error);\n                                captureCommitPhaseError(fiber, fiber.return, error);\n                            }\n                        }\n                }\n            }\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === \"function\" && Symbol.for) {\n            var symbolFor = Symbol.for;\n            COMPONENT_TYPE = symbolFor(\"selector.component\");\n            HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n            ROLE_TYPE = symbolFor(\"selector.role\");\n            TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n            TEXT_TYPE = symbolFor(\"selector.text\");\n        }\n        function createComponentSelector(component) {\n            return {\n                $$typeof: COMPONENT_TYPE,\n                value: component\n            };\n        }\n        function createHasPseudoClassSelector(selectors) {\n            return {\n                $$typeof: HAS_PSEUDO_CLASS_TYPE,\n                value: selectors\n            };\n        }\n        function createRoleSelector(role) {\n            return {\n                $$typeof: ROLE_TYPE,\n                value: role\n            };\n        }\n        function createTextSelector(text) {\n            return {\n                $$typeof: TEXT_TYPE,\n                value: text\n            };\n        }\n        function createTestNameSelector(id) {\n            return {\n                $$typeof: TEST_NAME_TYPE,\n                value: id\n            };\n        }\n        function findFiberRootForHostRoot(hostRoot) {\n            var maybeFiber = getInstanceFromNode(hostRoot);\n            if (maybeFiber != null) {\n                if (typeof maybeFiber.memoizedProps[\"data-testname\"] !== \"string\") {\n                    throw new Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n                }\n                return maybeFiber;\n            } else {\n                var fiberRoot = findFiberRoot(hostRoot);\n                if (fiberRoot === null) {\n                    throw new Error(\"Could not find React container within specified host subtree.\");\n                } // The Flow type for FiberRoot is a little funky.\n                // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n                return fiberRoot.stateNode.current;\n            }\n        }\n        function matchSelector(fiber, selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    if (fiber.type === selector.value) {\n                        return true;\n                    }\n                    break;\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return hasMatchingPaths(fiber, selector.value);\n                case ROLE_TYPE:\n                    if (fiber.tag === HostComponent) {\n                        var node = fiber.stateNode;\n                        if (matchAccessibilityRole(node, selector.value)) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEXT_TYPE:\n                    if (fiber.tag === HostComponent || fiber.tag === HostText) {\n                        var textContent = getTextContent(fiber);\n                        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEST_NAME_TYPE:\n                    if (fiber.tag === HostComponent) {\n                        var dataTestID = fiber.memoizedProps[\"data-testname\"];\n                        if (typeof dataTestID === \"string\" && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n                            return true;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error(\"Invalid selector type specified.\");\n            }\n            return false;\n        }\n        function selectorToString(selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    var displayName = getComponentNameFromType(selector.value) || \"Unknown\";\n                    return \"<\" + displayName + \">\";\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n                case ROLE_TYPE:\n                    return '[role=\"' + selector.value + '\"]';\n                case TEXT_TYPE:\n                    return '\"' + selector.value + '\"';\n                case TEST_NAME_TYPE:\n                    return '[data-testname=\"' + selector.value + '\"]';\n                default:\n                    throw new Error(\"Invalid selector type specified.\");\n            }\n        }\n        function findPaths(root, selectors) {\n            var matchingFibers = [];\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    matchingFibers.push(fiber);\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return matchingFibers;\n        } // Same as findPaths but with eager bailout on first match\n        function hasMatchingPaths(root, selectors) {\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    return true;\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return false;\n        }\n        function findAllNodes(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var instanceRoots = [];\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var node = stack[index++];\n                if (node.tag === HostComponent) {\n                    if (isHiddenSubtree(node)) {\n                        continue;\n                    }\n                    instanceRoots.push(node.stateNode);\n                } else {\n                    var child = node.child;\n                    while(child !== null){\n                        stack.push(child);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return instanceRoots;\n        }\n        function getFindAllNodesFailureDescription(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var maxSelectorIndex = 0;\n            var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n                    continue;\n                } else if (matchSelector(fiber, selector)) {\n                    matchedNames.push(selectorToString(selector));\n                    selectorIndex++;\n                    if (selectorIndex > maxSelectorIndex) {\n                        maxSelectorIndex = selectorIndex;\n                    }\n                }\n                if (selectorIndex < selectors.length) {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            if (maxSelectorIndex < selectors.length) {\n                var unmatchedNames = [];\n                for(var i = maxSelectorIndex; i < selectors.length; i++){\n                    unmatchedNames.push(selectorToString(selectors[i]));\n                }\n                return \"findAllNodes was able to match part of the selector:\\n\" + (\"  \" + matchedNames.join(\" > \") + \"\\n\\n\") + \"No matching component was found for:\\n\" + (\"  \" + unmatchedNames.join(\" > \"));\n            }\n            return null;\n        }\n        function findBoundingRects(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var boundingRects = [];\n            for(var i = 0; i < instanceRoots.length; i++){\n                boundingRects.push(getBoundingRect(instanceRoots[i]));\n            }\n            for(var _i = boundingRects.length - 1; _i > 0; _i--){\n                var targetRect = boundingRects[_i];\n                var targetLeft = targetRect.x;\n                var targetRight = targetLeft + targetRect.width;\n                var targetTop = targetRect.y;\n                var targetBottom = targetTop + targetRect.height;\n                for(var j = _i - 1; j >= 0; j--){\n                    if (_i !== j) {\n                        var otherRect = boundingRects[j];\n                        var otherLeft = otherRect.x;\n                        var otherRight = otherLeft + otherRect.width;\n                        var otherTop = otherRect.y;\n                        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n                        // but we can handle the most common cases:\n                        // 1. completely overlapping rects\n                        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n                        //\n                        // Even given the above constraints,\n                        // we still won't end up with the fewest possible rects without doing multiple passes,\n                        // but it's good enough for this purpose.\n                        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                            // Complete overlapping rects; remove the inner one.\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n                            // Adjacent vertical rects; merge them.\n                            if (otherTop > targetTop) {\n                                otherRect.height += otherTop - targetTop;\n                                otherRect.y = targetTop;\n                            }\n                            if (otherBottom < targetBottom) {\n                                otherRect.height = targetBottom - otherTop;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n                            // Adjacent horizontal rects; merge them.\n                            if (otherLeft > targetLeft) {\n                                otherRect.width += otherLeft - targetLeft;\n                                otherRect.x = targetLeft;\n                            }\n                            if (otherRight < targetRight) {\n                                otherRect.width = targetRight - otherLeft;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            return boundingRects;\n        }\n        function focusWithin(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                if (isHiddenSubtree(fiber)) {\n                    continue;\n                }\n                if (fiber.tag === HostComponent) {\n                    var node = fiber.stateNode;\n                    if (setFocusIfFocusable(node)) {\n                        return true;\n                    }\n                }\n                var child = fiber.child;\n                while(child !== null){\n                    stack.push(child);\n                    child = child.sibling;\n                }\n            }\n            return false;\n        }\n        var commitHooks = [];\n        function onCommitRoot$1() {\n            if (supportsTestSelectors) {\n                commitHooks.forEach(function(commitHook) {\n                    return commitHook();\n                });\n            }\n        }\n        function observeVisibleRects(hostRoot, selectors, callback, options) {\n            if (!supportsTestSelectors) {\n                throw new Error(\"Test selector API is not supported by this renderer.\");\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n            var commitHook = function() {\n                var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n                instanceRoots.forEach(function(target) {\n                    if (nextInstanceRoots.indexOf(target) < 0) {\n                        unobserve(target);\n                    }\n                });\n                nextInstanceRoots.forEach(function(target) {\n                    if (instanceRoots.indexOf(target) < 0) {\n                        observe(target);\n                    }\n                });\n            };\n            commitHooks.push(commitHook);\n            return {\n                disconnect: function() {\n                    // Stop listening for React mutations:\n                    var index = commitHooks.indexOf(commitHook);\n                    if (index >= 0) {\n                        commitHooks.splice(index, 1);\n                    } // Disconnect the host observer:\n                    disconnect();\n                }\n            };\n        }\n        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\n        function isLegacyActEnvironment(fiber) {\n            {\n                // Legacy mode. We preserve the behavior of React 17's act. It assumes an\n                // act environment whenever `jest` is defined, but you can still turn off\n                // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n                // to false.\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest\n                var jestIsDefined = typeof jest !== \"undefined\";\n                return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;\n            }\n        }\n        function isConcurrentActEnvironment() {\n            {\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : undefined;\n                if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n                    // TODO: Include link to relevant documentation page.\n                    error(\"The current testing environment is not configured to support \" + \"act(...)\");\n                }\n                return isReactActEnvironmentGlobal;\n            }\n        }\n        var ceil = Math.ceil;\n        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\n        var NoContext = /*             */ 0;\n        var BatchedContext = /*               */ 1;\n        var RenderContext = /*                */ 2;\n        var CommitContext = /*                */ 4;\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6; // Describes where we are in the React execution stack\n        var executionContext = NoContext; // The root we're working on\n        var workInProgressRoot = null; // The fiber we're working on\n        var workInProgress = null; // The lanes we're rendering\n        var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n        // This is a superset of the lanes we started working on at the root. The only\n        // case where it's different from `workInProgressRootRenderLanes` is when we\n        // enter a subtree that is hidden and needs to be unhidden: Suspense and\n        // Offscreen component.\n        //\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\n        // Most things in begin/complete phases should deal with subtreeRenderLanes.\n        var subtreeRenderLanes = NoLanes;\n        var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n        var workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n        var workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n        // slightly different than `renderLanes` because `renderLanes` can change as you\n        // enter and exit an Offscreen tree. This value is the combination of all render\n        // lanes for the entire render phase.\n        var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n        // includes unprocessed updates, not work in bailed out children.\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n        var workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n        var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n        // We will log them once the tree commits.\n        var workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n        // model where we don't commit new loading states in too quick succession.\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n        // more and prefer CPU suspense heuristics instead.\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n        // suspense heuristics and opt out of rendering more content.\n        var RENDER_TIMEOUT_MS = 500;\n        function resetRenderTimer() {\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n            return workInProgressRootRenderTargetTime;\n        }\n        var hasUncaughtError = false;\n        var firstUncaughtError = null;\n        var legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0; // If two updates are scheduled within the same event, we should treat their\n        // event times as simultaneous, even if the actual clock time has advanced\n        // between the first and second call.\n        var currentEventTime = NoTimestamp;\n        var currentEventTransitionLane = NoLanes;\n        function getWorkInProgressRoot() {\n            return workInProgressRoot;\n        }\n        function requestEventTime() {\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                // We're inside React, so it's fine to read the actual time.\n                return now$1();\n            } // We're not inside React, so we may be in the middle of a browser event.\n            if (currentEventTime !== NoTimestamp) {\n                // Use the same start time for all updates until we enter React again.\n                return currentEventTime;\n            } // This is the first update since React yielded. Compute a new start time.\n            currentEventTime = now$1();\n            return currentEventTime;\n        }\n        function requestUpdateLane(fiber) {\n            // Special cases\n            var mode = fiber.mode;\n            if ((mode & ConcurrentMode) === NoMode) {\n                return SyncLane;\n            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n                // This is a render phase update. These are not officially supported. The\n                // old behavior is to give this the same \"thread\" (lanes) as\n                // whatever is currently rendering. So if you call `setState` on a component\n                // that happens later in the same render, it will flush. Ideally, we want to\n                // remove the special case and treat them as if they came from an\n                // interleaved event. Regardless, this pattern is not officially supported.\n                // This behavior is only a fallback. The flag only exists until we can roll\n                // out the setState warning, since existing code might accidentally rely on\n                // the current behavior.\n                return pickArbitraryLane(workInProgressRootRenderLanes);\n            }\n            var isTransition = requestCurrentTransition() !== NoTransition;\n            if (isTransition) {\n                if (ReactCurrentBatchConfig$2.transition !== null) {\n                    var transition = ReactCurrentBatchConfig$2.transition;\n                    if (!transition._updatedFibers) {\n                        transition._updatedFibers = new Set();\n                    }\n                    transition._updatedFibers.add(fiber);\n                } // The algorithm for assigning an update to a lane should be stable for all\n                // updates at the same priority within the same event. To do this, the\n                // inputs to the algorithm must be the same.\n                //\n                // The trick we use is to cache the first of each of these inputs within an\n                // event. Then reset the cached values once we can be sure the event is\n                // over. Our heuristic for that is whenever we enter a concurrent work loop.\n                if (currentEventTransitionLane === NoLane) {\n                    // All transitions within the same event are assigned the same lane.\n                    currentEventTransitionLane = claimNextTransitionLane();\n                }\n                return currentEventTransitionLane;\n            } // Updates originating inside certain React methods, like flushSync, have\n            // their priority set by tracking it with a context variable.\n            //\n            // The opaque type returned by the host config is internally a lane, so we can\n            // use that directly.\n            // TODO: Move this type conversion to the event priority module.\n            var updateLane = getCurrentUpdatePriority();\n            if (updateLane !== NoLane) {\n                return updateLane;\n            } // This update originated outside React. Ask the host environment for an\n            // appropriate priority, based on the type of event.\n            //\n            // The opaque type returned by the host config is internally a lane, so we can\n            // use that directly.\n            // TODO: Move this type conversion to the event priority module.\n            var eventLane = getCurrentEventPriority();\n            return eventLane;\n        }\n        function requestRetryLane(fiber) {\n            // This is a fork of `requestUpdateLane` designed specifically for Suspense\n            // \"retries\" — a special update that attempts to flip a Suspense boundary\n            // from its placeholder state to its primary/resolved state.\n            // Special cases\n            var mode = fiber.mode;\n            if ((mode & ConcurrentMode) === NoMode) {\n                return SyncLane;\n            }\n            return claimNextRetryLane();\n        }\n        function scheduleUpdateOnFiber(fiber, lane, eventTime) {\n            checkForNestedUpdates();\n            var root = markUpdateLaneFromFiberToRoot(fiber, lane);\n            if (root === null) {\n                return null;\n            } // Mark that the root has a pending update.\n            markRootUpdated(root, lane, eventTime);\n            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n                // This update was dispatched during the render phase. This is a mistake\n                // if the update originates from user space (with the exception of local\n                // hook updates, which are handled differently and don't reach this\n                // function), but there are some internal React features that use this as\n                // an implementation detail, like selective hydration.\n                warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n            } else {\n                // This is a normal update, scheduled from outside the render phase. For\n                // example, during an input event.\n                {\n                    if (isDevToolsPresent) {\n                        addFiberToLanesMap(root, fiber, lane);\n                    }\n                }\n                warnIfUpdatesNotWrappedWithActDEV(fiber);\n                if (root === workInProgressRoot) {\n                    // TODO: Consolidate with `isInterleavedUpdate` check\n                    // Received an update to a tree that's in the middle of rendering. Mark\n                    // that there was an interleaved update work on this root. Unless the\n                    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n                    // phase update. In that case, we don't treat render phase updates as if\n                    // they were interleaved, for backwards compat reasons.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n                    }\n                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                        // The root already suspended with a delay, which means this render\n                        // definitely won't finish. Since we have a new update, let's mark it as\n                        // suspended now, right before marking the incoming update. This has the\n                        // effect of interrupting the current render and switching to the update.\n                        // TODO: Make sure this doesn't override pings that happen while we've\n                        // already started rendering.\n                        markRootSuspended$1(root, workInProgressRootRenderLanes);\n                    }\n                }\n                ensureRootIsScheduled(root, eventTime);\n                if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n                !ReactCurrentActQueue$1.isBatchingLegacy) {\n                    // Flush the synchronous work now, unless we're already working or inside\n                    // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                    // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                    // without immediately flushing it. We only do this for user-initiated\n                    // updates, to preserve historical behavior of legacy mode.\n                    resetRenderTimer();\n                    flushSyncCallbacksOnlyInLegacyMode();\n                }\n            }\n            return root;\n        }\n        function scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n            // This is a special fork of scheduleUpdateOnFiber that is only used to\n            // schedule the initial hydration of a root that has just been created. Most\n            // of the stuff in scheduleUpdateOnFiber can be skipped.\n            //\n            // The main reason for this separate path, though, is to distinguish the\n            // initial children from subsequent updates. In fully client-rendered roots\n            // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n            // updates, but hydration roots are special because the initial render must\n            // match what was rendered on the server.\n            var current = root.current;\n            current.lanes = lane;\n            markRootUpdated(root, lane, eventTime);\n            ensureRootIsScheduled(root, eventTime);\n        } // This is split into a separate function so we can mark a fiber with pending\n        // work without treating it as a typical update that originates from an event;\n        // e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n        // on a fiber.\n        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n            // Update the source fiber's lanes\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n            var alternate = sourceFiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            }\n            {\n                if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n            }\n            var node = sourceFiber;\n            var parent = sourceFiber.return;\n            while(parent !== null){\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\n                alternate = parent.alternate;\n                if (alternate !== null) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n                } else {\n                    {\n                        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n                            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                        }\n                    }\n                }\n                node = parent;\n                parent = parent.return;\n            }\n            if (node.tag === HostRoot) {\n                var root = node.stateNode;\n                return root;\n            } else {\n                return null;\n            }\n        }\n        function isInterleavedUpdate(fiber, lane) {\n            return(// Requires some refactoring. Not a big deal though since it's rare for\n            // concurrent apps to have more than a single root.\n            workInProgressRoot !== null && (fiber.mode & ConcurrentMode) !== NoMode && // then don't treat this as an interleaved update. This pattern is\n            // accompanied by a warning but we haven't fully deprecated it yet. We can\n            // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n            (executionContext & RenderContext) === NoContext);\n        } // Use this function to schedule a task for a root. There's only one task per\n        // root; if a task was already scheduled, we'll check to make sure the priority\n        // of the existing task is the same as the priority of the next level that the\n        // root has work on. This function is called on every update, and right before\n        // exiting a task.\n        function ensureRootIsScheduled(root, currentTime) {\n            var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n            // expired so we know to work on those next.\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (nextLanes === NoLanes) {\n                // Special case: There's nothing to work on.\n                if (existingCallbackNode !== null) {\n                    cancelCallback$1(existingCallbackNode);\n                }\n                root.callbackNode = null;\n                root.callbackPriority = NoLane;\n                return;\n            } // We use the highest priority lane to represent the priority of the callback.\n            var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n            var existingCallbackPriority = root.callbackPriority;\n            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n            // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n            // on the `act` queue.\n            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n                {\n                    // If we're going to re-use an existing task, it needs to exist.\n                    // Assume that discrete update microtasks are non-cancellable and null.\n                    // TODO: Temporary until we confirm this warning is not fired.\n                    if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n                        error(\"Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.\");\n                    }\n                }\n                return;\n            }\n            if (existingCallbackNode != null) {\n                // Cancel the existing callback. We'll schedule a new one below.\n                cancelCallback$1(existingCallbackNode);\n            } // Schedule a new callback.\n            var newCallbackNode;\n            if (newCallbackPriority === SyncLane) {\n                // Special case: Sync React callbacks are scheduled on a special\n                // internal queue\n                if (root.tag === LegacyRoot) {\n                    if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n                        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n                    }\n                    scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n                } else {\n                    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n                }\n                if (supportsMicrotasks) {\n                    // Flush the queue in a microtask.\n                    if (ReactCurrentActQueue$1.current !== null) {\n                        // Inside `act`, use our internal `act` queue so that these get flushed\n                        // at the end of the current scope even when using the sync version\n                        // of `act`.\n                        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n                    } else {\n                        scheduleMicrotask(function() {\n                            // In Safari, appending an iframe forces microtasks to run.\n                            // https://github.com/facebook/react/issues/22459\n                            // We don't support running callbacks in the middle of render\n                            // or commit so we need to check against that.\n                            if (executionContext === NoContext) {\n                                // It's only safe to do this conditionally because we always\n                                // check for pending work before we exit the task.\n                                flushSyncCallbacks();\n                            }\n                        });\n                    }\n                } else {\n                    // Flush the queue in an Immediate task.\n                    scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);\n                }\n                newCallbackNode = null;\n            } else {\n                var schedulerPriorityLevel;\n                switch(lanesToEventPriority(nextLanes)){\n                    case DiscreteEventPriority:\n                        schedulerPriorityLevel = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriorityLevel = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriorityLevel = NormalPriority;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriorityLevel = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriorityLevel = NormalPriority;\n                        break;\n                }\n                newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n            }\n            root.callbackPriority = newCallbackPriority;\n            root.callbackNode = newCallbackNode;\n        } // This is the entry point for every concurrent task, i.e. anything that\n        // goes through Scheduler.\n        function performConcurrentWorkOnRoot(root, didTimeout) {\n            {\n                resetNestedUpdateFlag();\n            }\n            // event time. The next update will compute a new event time.\n            currentEventTime = NoTimestamp;\n            currentEventTransitionLane = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            } // Flush any pending passive effects before deciding which lanes to work on,\n            // in case they schedule additional work.\n            var originalCallbackNode = root.callbackNode;\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // Something in the passive effect phase may have canceled the current task.\n                // Check if the task node for this root was changed.\n                if (root.callbackNode !== originalCallbackNode) {\n                    // The current task was canceled. Exit. We don't need to call\n                    // `ensureRootIsScheduled` because the check above implies either that\n                    // there's a new task, or that there's no remaining work on this root.\n                    return null;\n                }\n            } // Determine the next lanes to work on, using the fields stored\n            // on the root.\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (lanes === NoLanes) {\n                // Defensive coding. This is never expected to happen.\n                return null;\n            } // We disable time-slicing in some cases: if the work has been CPU-bound\n            // for too long (\"expired\" work, to prevent starvation), or we're in\n            // sync-updates-by-default mode.\n            // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n            // bug we're still investigating. Once the bug in Scheduler is fixed,\n            // we can remove this, since we track expiration ourselves.\n            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;\n            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n            if (exitStatus !== RootInProgress) {\n                if (exitStatus === RootErrored) {\n                    // If something threw an error, try rendering one more time. We'll\n                    // render synchronously to block concurrent data mutations, and we'll\n                    // includes all pending updates are included. If it still fails after\n                    // the second attempt, we'll give up and commit the resulting tree.\n                    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                    if (errorRetryLanes !== NoLanes) {\n                        lanes = errorRetryLanes;\n                        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    var fatalError = workInProgressRootFatalError;\n                    prepareFreshStack(root, NoLanes);\n                    markRootSuspended$1(root, lanes);\n                    ensureRootIsScheduled(root, now$1());\n                    throw fatalError;\n                }\n                if (exitStatus === RootDidNotComplete) {\n                    // The render unwound without completing the tree. This happens in special\n                    // cases where need to exit the current render without producing a\n                    // consistent tree or committing.\n                    //\n                    // This should only happen during a concurrent render, not a discrete or\n                    // synchronous update. We should have already checked for this when we\n                    // unwound the stack.\n                    markRootSuspended$1(root, lanes);\n                } else {\n                    // The render completed.\n                    // Check if this render may have yielded to a concurrent event, and if so,\n                    // confirm that any newly rendered stores are consistent.\n                    // TODO: It's possible that even a concurrent render may never have yielded\n                    // to the main thread, if it was fast enough, or if it expired. We could\n                    // skip the consistency check in that case, too.\n                    var renderWasConcurrent = !includesBlockingLane(root, lanes);\n                    var finishedWork = root.current.alternate;\n                    if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                        // A store was mutated in an interleaved event. Render again,\n                        // synchronously, to block further mutations.\n                        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n                        if (exitStatus === RootErrored) {\n                            var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                            if (_errorRetryLanes !== NoLanes) {\n                                lanes = _errorRetryLanes;\n                                exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n                            // concurrent events.\n                            }\n                        }\n                        if (exitStatus === RootFatalErrored) {\n                            var _fatalError = workInProgressRootFatalError;\n                            prepareFreshStack(root, NoLanes);\n                            markRootSuspended$1(root, lanes);\n                            ensureRootIsScheduled(root, now$1());\n                            throw _fatalError;\n                        }\n                    } // We now have a consistent tree. The next step is either to commit it,\n                    // or, if something suspended, wait to commit it after a timeout.\n                    root.finishedWork = finishedWork;\n                    root.finishedLanes = lanes;\n                    finishConcurrentRender(root, exitStatus, lanes);\n                }\n            }\n            ensureRootIsScheduled(root, now$1());\n            if (root.callbackNode === originalCallbackNode) {\n                // The task node scheduled for this root is the same one that's\n                // currently executed. Need to return a continuation.\n                return performConcurrentWorkOnRoot.bind(null, root);\n            }\n            return null;\n        }\n        function recoverFromConcurrentError(root, errorRetryLanes) {\n            // If an error occurred during hydration, discard server response and fall\n            // back to client side render.\n            // Before rendering again, save the errors from the previous attempt.\n            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n            if (isRootDehydrated(root)) {\n                // The shell failed to hydrate. Set a flag to force a client rendering\n                // during the next attempt. To do this, we call prepareFreshStack now\n                // to create the root work-in-progress fiber. This is a bit weird in terms\n                // of factoring, because it relies on renderRootSync not calling\n                // prepareFreshStack again in the call below, which happens because the\n                // root and lanes haven't changed.\n                //\n                // TODO: I think what we should do is set ForceClientRender inside\n                // throwException, like we do for nested Suspense boundaries. The reason\n                // it's here instead is so we can switch to the synchronous work loop, too.\n                // Something to consider for a future refactor.\n                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n                rootWorkInProgress.flags |= ForceClientRender;\n                {\n                    errorHydratingContainer(root.containerInfo);\n                }\n            }\n            var exitStatus = renderRootSync(root, errorRetryLanes);\n            if (exitStatus !== RootErrored) {\n                // Successfully finished rendering on retry\n                // The errors from the failed first attempt have been recovered. Add\n                // them to the collection of recoverable errors. We'll log them in the\n                // commit phase.\n                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n                workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n                // from the first attempt, to preserve the causal sequence.\n                if (errorsFromSecondAttempt !== null) {\n                    queueRecoverableErrors(errorsFromSecondAttempt);\n                }\n            }\n            return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n            if (workInProgressRootRecoverableErrors === null) {\n                workInProgressRootRecoverableErrors = errors;\n            } else {\n                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n            }\n        }\n        function finishConcurrentRender(root, exitStatus, lanes) {\n            switch(exitStatus){\n                case RootInProgress:\n                case RootFatalErrored:\n                    {\n                        throw new Error(\"Root did not complete. This is a bug in React.\");\n                    }\n                // Flow knows about invariant, so it complains if I add a break\n                // statement, but eslint doesn't know about invariant, so it complains\n                // if I do. eslint-disable-next-line no-fallthrough\n                case RootErrored:\n                    {\n                        // We should have already attempted to retry this tree. If we reached\n                        // this point, it errored again. Commit it.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootSuspended:\n                    {\n                        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\n                        // should immediately commit it or wait a bit.\n                        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n                        !shouldForceFlushFallbacksInDEV()) {\n                            // This render only included retries, no updates. Throttle committing\n                            // retries so that we don't show too many loading states too quickly.\n                            var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n                            if (msUntilTimeout > 10) {\n                                var nextLanes = getNextLanes(root, NoLanes);\n                                if (nextLanes !== NoLanes) {\n                                    break;\n                                }\n                                var suspendedLanes = root.suspendedLanes;\n                                if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n                                    // We should prefer to render the fallback of at the last\n                                    // suspended level. Ping the last suspended level to try\n                                    // rendering it again.\n                                    // FIXME: What if the suspended lanes are Idle? Should not restart.\n                                    var eventTime = requestEventTime();\n                                    markRootPinged(root, suspendedLanes);\n                                    break;\n                                } // The render is suspended, it hasn't timed out, and there's no\n                                // lower priority work to do. Instead of committing the fallback\n                                // immediately, wait for more data to arrive.\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), msUntilTimeout);\n                                break;\n                            }\n                        } // The work expired. Commit immediately.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootSuspendedWithDelay:\n                    {\n                        markRootSuspended$1(root, lanes);\n                        if (includesOnlyTransitions(lanes)) {\n                            break;\n                        }\n                        if (!shouldForceFlushFallbacksInDEV()) {\n                            // This is not a transition, but we did trigger an avoided state.\n                            // Schedule a placeholder to display after a short delay, using the Just\n                            // Noticeable Difference.\n                            // TODO: Is the JND optimization worth the added complexity? If this is\n                            // the only reason we track the event time, then probably not.\n                            // Consider removing.\n                            var mostRecentEventTime = getMostRecentEventTime(root, lanes);\n                            var eventTimeMs = mostRecentEventTime;\n                            var timeElapsedMs = now$1() - eventTimeMs;\n                            var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n                            if (_msUntilTimeout > 10) {\n                                // Instead of committing the fallback immediately, wait for more data\n                                // to arrive.\n                                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), _msUntilTimeout);\n                                break;\n                            }\n                        } // Commit the placeholder.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                case RootCompleted:\n                    {\n                        // The work completed. Ready to commit.\n                        commitRoot(root, workInProgressRootRecoverableErrors);\n                        break;\n                    }\n                default:\n                    {\n                        throw new Error(\"Unknown root exit status.\");\n                    }\n            }\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n            // Search the rendered tree for external store reads, and check whether the\n            // stores were mutated in a concurrent event. Intentionally using an iterative\n            // loop instead of recursion so we can exit early.\n            var node = finishedWork;\n            while(true){\n                if (node.flags & StoreConsistency) {\n                    var updateQueue = node.updateQueue;\n                    if (updateQueue !== null) {\n                        var checks = updateQueue.stores;\n                        if (checks !== null) {\n                            for(var i = 0; i < checks.length; i++){\n                                var check = checks[i];\n                                var getSnapshot = check.getSnapshot;\n                                var renderedValue = check.value;\n                                try {\n                                    if (!objectIs(getSnapshot(), renderedValue)) {\n                                        // Found an inconsistent store.\n                                        return false;\n                                    }\n                                } catch (error) {\n                                    // If `getSnapshot` throws, return `false`. This will schedule\n                                    // a re-render, and the error will be rethrown during render.\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                var child = node.child;\n                if (node.subtreeFlags & StoreConsistency && child !== null) {\n                    child.return = node;\n                    node = child;\n                    continue;\n                }\n                if (node === finishedWork) {\n                    return true;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === finishedWork) {\n                        return true;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            } // Flow doesn't know this is unreachable, but eslint does\n            // eslint-disable-next-line no-unreachable\n            return true;\n        }\n        function markRootSuspended$1(root, suspendedLanes) {\n            // When suspending, we should always exclude lanes that were pinged or (more\n            // rarely, since we try to avoid it) updated during the render phase.\n            // TODO: Lol maybe there's a better way to factor this besides this\n            // obnoxiously named function :)\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n            markRootSuspended(root, suspendedLanes);\n        } // This is the entry point for synchronous tasks that don't go\n        // through Scheduler\n        function performSyncWorkOnRoot(root) {\n            {\n                syncNestedUpdateFlag();\n            }\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            }\n            flushPassiveEffects();\n            var lanes = getNextLanes(root, NoLanes);\n            if (!includesSomeLane(lanes, SyncLane)) {\n                // There's no remaining sync work left.\n                ensureRootIsScheduled(root, now$1());\n                return null;\n            }\n            var exitStatus = renderRootSync(root, lanes);\n            if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n                // If something threw an error, try rendering one more time. We'll render\n                // synchronously to block concurrent data mutations, and we'll includes\n                // all pending updates are included. If it still fails after the second\n                // attempt, we'll give up and commit the resulting tree.\n                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n                if (errorRetryLanes !== NoLanes) {\n                    lanes = errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n                }\n            }\n            if (exitStatus === RootFatalErrored) {\n                var fatalError = workInProgressRootFatalError;\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended$1(root, lanes);\n                ensureRootIsScheduled(root, now$1());\n                throw fatalError;\n            }\n            if (exitStatus === RootDidNotComplete) {\n                throw new Error(\"Root did not complete. This is a bug in React.\");\n            } // We now have a consistent tree. Because this is a sync render, we\n            // will commit it even if something suspended.\n            var finishedWork = root.current.alternate;\n            root.finishedWork = finishedWork;\n            root.finishedLanes = lanes;\n            commitRoot(root, workInProgressRootRecoverableErrors); // Before exiting, make sure there's a callback scheduled for the next\n            // pending level.\n            ensureRootIsScheduled(root, now$1());\n            return null;\n        }\n        function flushRoot(root, lanes) {\n            if (lanes !== NoLanes) {\n                markRootEntangled(root, mergeLanes(lanes, SyncLane));\n                ensureRootIsScheduled(root, now$1());\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    resetRenderTimer();\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function deferredUpdates(fn) {\n            var previousPriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DefaultEventPriority);\n                return fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n            }\n        }\n        function batchedUpdates(fn, a) {\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            try {\n                return fn(a);\n            } finally{\n                executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n                // most batchedUpdates-like method.\n                if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n                !ReactCurrentActQueue$1.isBatchingLegacy) {\n                    resetRenderTimer();\n                    flushSyncCallbacksOnlyInLegacyMode();\n                }\n            }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n            var previousPriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                return fn(a, b, c, d);\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                if (executionContext === NoContext) {\n                    resetRenderTimer();\n                }\n            }\n        } // Overload the definition to the two valid signatures.\n        // Warning, this opts-out of checking the function body.\n        // eslint-disable-next-line no-redeclare\n        function flushSync(fn) {\n            // In legacy mode, we flush pending passive effects at the beginning of the\n            // next event, not at the end of the previous one.\n            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushPassiveEffects();\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                if (fn) {\n                    return fn();\n                } else {\n                    return undefined;\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n                // Note that this will happen even if batchedUpdates is higher up\n                // the stack.\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function isAlreadyRendering() {\n            // Used by the renderer to print a warning if certain APIs are called from\n            // the wrong context.\n            return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        function flushControlled(fn) {\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                executionContext = prevExecutionContext;\n                if (executionContext === NoContext) {\n                    // Flush the immediate callbacks that were scheduled during this batch\n                    resetRenderTimer();\n                    flushSyncCallbacks();\n                }\n            }\n        }\n        function pushRenderLanes(fiber, lanes) {\n            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n        }\n        function popRenderLanes(fiber) {\n            subtreeRenderLanes = subtreeRenderLanesCursor.current;\n            pop(subtreeRenderLanesCursor, fiber);\n        }\n        function prepareFreshStack(root, lanes) {\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            var timeoutHandle = root.timeoutHandle;\n            if (timeoutHandle !== noTimeout) {\n                // The root previous suspended and scheduled a timeout to commit a fallback\n                // state. Now that we have additional work, cancel the timeout.\n                root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n                cancelTimeout(timeoutHandle);\n            }\n            if (workInProgress !== null) {\n                var interruptedWork = workInProgress.return;\n                while(interruptedWork !== null){\n                    var current = interruptedWork.alternate;\n                    unwindInterruptedWork(current, interruptedWork);\n                    interruptedWork = interruptedWork.return;\n                }\n            }\n            workInProgressRoot = root;\n            var rootWorkInProgress = createWorkInProgress(root.current, null);\n            workInProgress = rootWorkInProgress;\n            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n            workInProgressRootExitStatus = RootInProgress;\n            workInProgressRootFatalError = null;\n            workInProgressRootSkippedLanes = NoLanes;\n            workInProgressRootInterleavedUpdatedLanes = NoLanes;\n            workInProgressRootPingedLanes = NoLanes;\n            workInProgressRootConcurrentErrors = null;\n            workInProgressRootRecoverableErrors = null;\n            enqueueInterleavedUpdates();\n            {\n                ReactStrictModeWarnings.discardPendingWarnings();\n            }\n            return rootWorkInProgress;\n        }\n        function handleError(root, thrownValue) {\n            do {\n                var erroredWork = workInProgress;\n                try {\n                    // Reset module-level state that was set during the render phase.\n                    resetContextDependencies();\n                    resetHooksAfterThrow();\n                    resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\n                    // separate issue. Write a regression test using string refs.\n                    ReactCurrentOwner$2.current = null;\n                    if (erroredWork === null || erroredWork.return === null) {\n                        // Expected to be working on a non-root fiber. This is a fatal error\n                        // because there's no ancestor that can handle it; the root is\n                        // supposed to capture all errors that weren't caught by an error\n                        // boundary.\n                        workInProgressRootExitStatus = RootFatalErrored;\n                        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n                        // sibling, or the parent if there are no siblings. But since the root\n                        // has no siblings nor a parent, we set it to null. Usually this is\n                        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n                        // intentionally not calling those, we need set it here.\n                        // TODO: Consider calling `unwindWork` to pop the contexts.\n                        workInProgress = null;\n                        return;\n                    }\n                    if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n                        // Record the time spent rendering before an error was thrown. This\n                        // avoids inaccurate Profiler durations in the case of a\n                        // suspended render.\n                        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n                    }\n                    if (enableSchedulingProfiler) {\n                        markComponentRenderStopped();\n                        if (thrownValue !== null && typeof thrownValue === \"object\" && typeof thrownValue.then === \"function\") {\n                            var wakeable = thrownValue;\n                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                        } else {\n                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                        }\n                    }\n                    throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n                    completeUnitOfWork(erroredWork);\n                } catch (yetAnotherThrownValue) {\n                    // Something in the return path also threw.\n                    thrownValue = yetAnotherThrownValue;\n                    if (workInProgress === erroredWork && erroredWork !== null) {\n                        // If this boundary has already errored, then we had trouble processing\n                        // the error. Bubble it to the next boundary.\n                        erroredWork = erroredWork.return;\n                        workInProgress = erroredWork;\n                    } else {\n                        erroredWork = workInProgress;\n                    }\n                    continue;\n                } // Return to the normal work loop.\n                return;\n            }while (true);\n        }\n        function pushDispatcher() {\n            var prevDispatcher = ReactCurrentDispatcher$2.current;\n            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n            if (prevDispatcher === null) {\n                // The React isomorphic package does not include a default dispatcher.\n                // Instead the first renderer will lazily attach one, in order to give\n                // nicer error messages.\n                return ContextOnlyDispatcher;\n            } else {\n                return prevDispatcher;\n            }\n        }\n        function popDispatcher(prevDispatcher) {\n            ReactCurrentDispatcher$2.current = prevDispatcher;\n        }\n        function markCommitTimeOfFallback() {\n            globalMostRecentFallbackTime = now$1();\n        }\n        function markSkippedUpdateLanes(lane) {\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootSuspended;\n            }\n        }\n        function renderDidSuspendDelayIfPossible() {\n            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n                workInProgressRootExitStatus = RootSuspendedWithDelay;\n            } // Check if there are updates that we skipped tree that might have unblocked\n            // this render.\n            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n                // Mark the current render as suspended so that we switch to working on\n                // the updates that were skipped. Usually we only suspend at the end of\n                // the render phase.\n                // TODO: We should probably always mark the root as suspended immediately\n                // (inside this function), since by suspending at the end of the render\n                // phase introduces a potential mistake where we suspend lanes that were\n                // pinged or updated while we were rendering.\n                markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n            }\n        }\n        function renderDidError(error) {\n            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n                workInProgressRootExitStatus = RootErrored;\n            }\n            if (workInProgressRootConcurrentErrors === null) {\n                workInProgressRootConcurrentErrors = [\n                    error\n                ];\n            } else {\n                workInProgressRootConcurrentErrors.push(error);\n            }\n        } // Called during render to determine if anything has suspended.\n        // Returns false if we're not sure.\n        function renderHasNotSuspendedYet() {\n            // If something errored or completed, we can't really be sure,\n            // so those are false.\n            return workInProgressRootExitStatus === RootInProgress;\n        }\n        function renderRootSync(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            do {\n                try {\n                    workLoopSync();\n                    break;\n                } catch (thrownValue) {\n                    handleError(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            executionContext = prevExecutionContext;\n            popDispatcher(prevDispatcher);\n            if (workInProgress !== null) {\n                // This is a sync render, so we should have finished the whole tree.\n                throw new Error(\"Cannot commit an incomplete root. This error is likely caused by a \" + \"bug in React. Please file an issue.\");\n            }\n            {\n                markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes;\n            return workInProgressRootExitStatus;\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\n        /** @noinline */ function workLoopSync() {\n            // Already timed out, so perform work without checking if we need to yield.\n            while(workInProgress !== null){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function renderRootConcurrent(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                resetRenderTimer();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            do {\n                try {\n                    workLoopConcurrent();\n                    break;\n                } catch (thrownValue) {\n                    handleError(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            popDispatcher(prevDispatcher);\n            executionContext = prevExecutionContext;\n            if (workInProgress !== null) {\n                // Still work remaining.\n                {\n                    markRenderYielded();\n                }\n                return RootInProgress;\n            } else {\n                // Completed the tree.\n                {\n                    markRenderStopped();\n                }\n                workInProgressRoot = null;\n                workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n                return workInProgressRootExitStatus;\n            }\n        }\n        /** @noinline */ function workLoopConcurrent() {\n            // Perform work until Scheduler asks us to yield\n            while(workInProgress !== null && !shouldYield()){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function performUnitOfWork(unitOfWork) {\n            // The current, flushed, state of this fiber is the alternate. Ideally\n            // nothing should rely on this, but relying on it here means that we don't\n            // need an additional field on the work in progress.\n            var current = unitOfWork.alternate;\n            setCurrentFiber(unitOfWork);\n            var next;\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                startProfilerTimer(unitOfWork);\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } else {\n                next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n            }\n            resetCurrentFiber();\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n            ReactCurrentOwner$2.current = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n            // Attempt to complete the current unit of work, then move to the next\n            // sibling. If there are no more siblings, return to the parent fiber.\n            var completedWork = unitOfWork;\n            do {\n                // The current, flushed, state of this fiber is the alternate. Ideally\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = completedWork.alternate;\n                var returnFiber = completedWork.return; // Check if the work completed or if something threw.\n                if ((completedWork.flags & Incomplete) === NoFlags) {\n                    setCurrentFiber(completedWork);\n                    var next = void 0;\n                    if ((completedWork.mode & ProfileMode) === NoMode) {\n                        next = completeWork(current, completedWork, subtreeRenderLanes);\n                    } else {\n                        startProfilerTimer(completedWork);\n                        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                    }\n                    resetCurrentFiber();\n                    if (next !== null) {\n                        // Completing this fiber spawned new work. Work on that next.\n                        workInProgress = next;\n                        return;\n                    }\n                } else {\n                    // This fiber did not complete because something threw. Pop values off\n                    // the stack without entering the complete phase. If this is a boundary,\n                    // capture values if possible.\n                    var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.\n                    if (_next !== null) {\n                        // If completing this work spawned new work, do that next. We'll come\n                        // back here again.\n                        // Since we're restarting, remove anything that is not a host effect\n                        // from the effect tag.\n                        _next.flags &= HostEffectMask;\n                        workInProgress = _next;\n                        return;\n                    }\n                    if ((completedWork.mode & ProfileMode) !== NoMode) {\n                        // Record the render duration for the fiber that errored.\n                        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n                        var actualDuration = completedWork.actualDuration;\n                        var child = completedWork.child;\n                        while(child !== null){\n                            actualDuration += child.actualDuration;\n                            child = child.sibling;\n                        }\n                        completedWork.actualDuration = actualDuration;\n                    }\n                    if (returnFiber !== null) {\n                        // Mark the parent fiber as incomplete and clear its subtree flags.\n                        returnFiber.flags |= Incomplete;\n                        returnFiber.subtreeFlags = NoFlags;\n                        returnFiber.deletions = null;\n                    } else {\n                        // We've unwound all the way to the root.\n                        workInProgressRootExitStatus = RootDidNotComplete;\n                        workInProgress = null;\n                        return;\n                    }\n                }\n                var siblingFiber = completedWork.sibling;\n                if (siblingFiber !== null) {\n                    // If there is more work to do in this returnFiber, do that next.\n                    workInProgress = siblingFiber;\n                    return;\n                } // Otherwise, return to the parent\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = completedWork;\n            }while (completedWork !== null); // We've reached the root.\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootCompleted;\n            }\n        }\n        function commitRoot(root, recoverableErrors) {\n            // TODO: This no longer makes any sense. We already wrap the mutation and\n            // layout phases. Should be able to remove.\n            var previousUpdateLanePriority = getCurrentUpdatePriority();\n            var prevTransition = ReactCurrentBatchConfig$2.transition;\n            try {\n                ReactCurrentBatchConfig$2.transition = null;\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                commitRootImpl(root, recoverableErrors, previousUpdateLanePriority);\n            } finally{\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n                setCurrentUpdatePriority(previousUpdateLanePriority);\n            }\n            return null;\n        }\n        function commitRootImpl(root, recoverableErrors, renderPriorityLevel) {\n            do {\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n                // means `flushPassiveEffects` will sometimes result in additional\n                // passive effects. So we need to keep flushing in a loop until there are\n                // no more pending effects.\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\n                // flush synchronous work at the end, to avoid factoring hazards like this.\n                flushPassiveEffects();\n            }while (rootWithPendingPassiveEffects !== null);\n            flushRenderPhaseStrictModeWarningsInDEV();\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Should not already be working.\");\n            }\n            var finishedWork = root.finishedWork;\n            var lanes = root.finishedLanes;\n            {\n                markCommitStarted(lanes);\n            }\n            if (finishedWork === null) {\n                {\n                    markCommitStopped();\n                }\n                return null;\n            } else {\n                {\n                    if (lanes === NoLanes) {\n                        error(\"root.finishedLanes should not be empty during a commit. This is a \" + \"bug in React.\");\n                    }\n                }\n            }\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            if (finishedWork === root.current) {\n                throw new Error(\"Cannot commit the same tree as before. This error is likely caused by \" + \"a bug in React. Please file an issue.\");\n            } // commitRoot never returns a continuation; it always finishes synchronously.\n            // So we can clear these now to allow a new callback to be scheduled.\n            root.callbackNode = null;\n            root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n            // pending time is whatever is left on the root fiber.\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n            markRootFinished(root, remainingLanes);\n            if (root === workInProgressRoot) {\n                // We can reset these now that they are finished.\n                workInProgressRoot = null;\n                workInProgress = null;\n                workInProgressRootRenderLanes = NoLanes;\n            } // If there are pending passive effects, schedule a callback to process them.\n            // Do this as early as possible, so it is queued before anything else that\n            // might get scheduled in the commit phase. (See #16714.)\n            // TODO: Delete all other places that schedule the passive effect callback\n            // They're redundant.\n            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback$1(NormalPriority, function() {\n                        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n                        // *after* passive effects fire to avoid freeing a cache pool that may\n                        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n                        return null;\n                    });\n                }\n            } // Check if there are any effects in the whole tree.\n            // TODO: This is left over from the effect list implementation, where we had\n            // to check for the existence of `firstEffect` to satisfy Flow. I think the\n            // only other reason this optimization exists is because it affects profiling.\n            // Reconsider whether this is necessary.\n            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n            if (subtreeHasEffects || rootHasEffect) {\n                var prevTransition = ReactCurrentBatchConfig$2.transition;\n                ReactCurrentBatchConfig$2.transition = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext; // Reset this to null before calling lifecycles\n                ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n                // of the effect list for each phase: all mutation effects come before all\n                // layout effects, and so on.\n                // The first phase a \"before mutation\" phase. We use this phase to read the\n                // state of the host tree right before we mutate it. This is where\n                // getSnapshotBeforeUpdate is called.\n                var shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n                {\n                    // Mark the current commit time to be shared by all Profilers in this\n                    // batch. This enables them to be grouped later.\n                    recordCommitTime();\n                }\n                commitMutationEffects(root, finishedWork, lanes);\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n                // the mutation phase, so that the previous tree is still current during\n                // componentWillUnmount, but before the layout phase, so that the finished\n                // work is current during componentDidMount/Update.\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n                {\n                    markLayoutEffectsStarted(lanes);\n                }\n                commitLayoutEffects(finishedWork, root, lanes);\n                {\n                    markLayoutEffectsStopped();\n                }\n                // opportunity to paint.\n                requestPaint();\n                executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n                setCurrentUpdatePriority(previousPriority);\n                ReactCurrentBatchConfig$2.transition = prevTransition;\n            } else {\n                // No effects.\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n                // no effects.\n                // TODO: Maybe there's a better way to report this.\n                {\n                    recordCommitTime();\n                }\n            }\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n            if (rootDoesHavePassiveEffects) {\n                // This commit has passive effects. Stash a reference to them. But don't\n                // schedule a callback until after flushing layout work.\n                rootDoesHavePassiveEffects = false;\n                rootWithPendingPassiveEffects = root;\n                pendingPassiveEffectsLanes = lanes;\n            } // Read this again, since an effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n            // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n            // is to detect whether something might have called setState inside\n            // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n            // inside `componentDidCatch` is itself flawed — that's why we recommend\n            // `getDerivedStateFromError` instead. However, it could be improved by\n            // checking if remainingLanes includes Sync work, instead of whether there's\n            // any work remaining at all (which would also include stuff like Suspense\n            // retries or transitions). It's been like this for a while, though, so fixing\n            // it probably isn't that urgent.\n            if (remainingLanes === NoLanes) {\n                // If there's no remaining work, we can clear the set of already failed\n                // error boundaries.\n                legacyErrorBoundariesThatAlreadyFailed = null;\n            }\n            {\n                if (!rootDidHavePassiveEffects) {\n                    commitDoubleInvokeEffectsInDEV(root.current, false);\n                }\n            }\n            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n            {\n                if (isDevToolsPresent) {\n                    root.memoizedUpdaters.clear();\n                }\n            }\n            {\n                onCommitRoot$1();\n            }\n            // additional work on this root is scheduled.\n            ensureRootIsScheduled(root, now$1());\n            if (recoverableErrors !== null) {\n                // There were errors during this render, but recovered from them without\n                // needing to surface it to the UI. We log them here.\n                var onRecoverableError = root.onRecoverableError;\n                for(var i = 0; i < recoverableErrors.length; i++){\n                    var recoverableError = recoverableErrors[i];\n                    onRecoverableError(recoverableError);\n                }\n            }\n            if (hasUncaughtError) {\n                hasUncaughtError = false;\n                var error$1 = firstUncaughtError;\n                firstUncaughtError = null;\n                throw error$1;\n            } // If the passive effects are the result of a discrete render, flush them\n            // synchronously at the end of the current task so that the result is\n            // immediately observable. Otherwise, we assume that they are not\n            // order-dependent and do not need to be observed by external systems, so we\n            // can wait until after paint.\n            // TODO: We can optimize this by not scheduling the callback earlier. Since we\n            // currently schedule the callback in multiple places, will wait until those\n            // are consolidated.\n            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n                flushPassiveEffects();\n            } // Read this again, since a passive effect might have updated it\n            remainingLanes = root.pendingLanes;\n            if (includesSomeLane(remainingLanes, SyncLane)) {\n                {\n                    markNestedUpdateScheduled();\n                }\n                // finishing. If there are too many, it indicates an infinite update loop.\n                if (root === rootWithNestedUpdates) {\n                    nestedUpdateCount++;\n                } else {\n                    nestedUpdateCount = 0;\n                    rootWithNestedUpdates = root;\n                }\n            } else {\n                nestedUpdateCount = 0;\n            } // If layout work was scheduled, flush it now.\n            flushSyncCallbacks();\n            {\n                markCommitStopped();\n            }\n            return null;\n        }\n        function flushPassiveEffects() {\n            // Returns whether passive effects were flushed.\n            // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n            // probably just combine the two functions. I believe they were only separate\n            // in the first place because we used to wrap it with\n            // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n            // priority within React itself, so we can mutate the variable directly.\n            if (rootWithPendingPassiveEffects !== null) {\n                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n                var prevTransition = ReactCurrentBatchConfig$2.transition;\n                var previousPriority = getCurrentUpdatePriority();\n                try {\n                    ReactCurrentBatchConfig$2.transition = null;\n                    setCurrentUpdatePriority(priority);\n                    return flushPassiveEffectsImpl();\n                } finally{\n                    setCurrentUpdatePriority(previousPriority);\n                    ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n                }\n            }\n            return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n            {\n                pendingPassiveProfilerEffects.push(fiber);\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback$1(NormalPriority, function() {\n                        flushPassiveEffects();\n                        return null;\n                    });\n                }\n            }\n        }\n        function flushPassiveEffectsImpl() {\n            if (rootWithPendingPassiveEffects === null) {\n                return false;\n            }\n            var root = rootWithPendingPassiveEffects;\n            var lanes = pendingPassiveEffectsLanes;\n            rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n            // Figure out why and fix it. It's not causing any known issues (probably\n            // because it's only used for profiling), but it's a refactor hazard.\n            pendingPassiveEffectsLanes = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error(\"Cannot flush passive effects while already rendering.\");\n            }\n            {\n                markPassiveEffectsStarted(lanes);\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            commitPassiveUnmountEffects(root.current);\n            commitPassiveMountEffects(root, root.current); // TODO: Move to commitPassiveMountEffects\n            {\n                var profilerEffects = pendingPassiveProfilerEffects;\n                pendingPassiveProfilerEffects = [];\n                for(var i = 0; i < profilerEffects.length; i++){\n                    var _fiber = profilerEffects[i];\n                    commitPassiveEffectDurations(root, _fiber);\n                }\n            }\n            {\n                markPassiveEffectsStopped();\n            }\n            {\n                commitDoubleInvokeEffectsInDEV(root.current, true);\n            }\n            executionContext = prevExecutionContext;\n            flushSyncCallbacks(); // If additional passive effects were scheduled, increment a counter. If this\n            // exceeds the limit, we'll fire a warning.\n            nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1; // TODO: Move to commitPassiveMountEffects\n            onPostCommitRoot(root);\n            {\n                var stateNode = root.current.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n            }\n            return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\n                legacyErrorBoundariesThatAlreadyFailed = new Set([\n                    instance\n                ]);\n            } else {\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\n            }\n        }\n        function prepareToThrowUncaughtError(error) {\n            if (!hasUncaughtError) {\n                hasUncaughtError = true;\n                firstUncaughtError = error;\n            }\n        }\n        var onUncaughtError = prepareToThrowUncaughtError;\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n            var errorInfo = createCapturedValue(error, sourceFiber);\n            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n            enqueueUpdate(rootFiber, update);\n            var eventTime = requestEventTime();\n            var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);\n            if (root !== null) {\n                markRootUpdated(root, SyncLane, eventTime);\n                ensureRootIsScheduled(root, eventTime);\n            }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n            if (sourceFiber.tag === HostRoot) {\n                // Error was thrown at the root. There is no parent, so the root\n                // itself should capture it.\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n                return;\n            }\n            var fiber = null;\n            {\n                fiber = nearestMountedAncestor;\n            }\n            while(fiber !== null){\n                if (fiber.tag === HostRoot) {\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n                    return;\n                } else if (fiber.tag === ClassComponent) {\n                    var ctor = fiber.type;\n                    var instance = fiber.stateNode;\n                    if (typeof ctor.getDerivedStateFromError === \"function\" || typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                        var errorInfo = createCapturedValue(error$1, sourceFiber);\n                        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n                        enqueueUpdate(fiber, update);\n                        var eventTime = requestEventTime();\n                        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);\n                        if (root !== null) {\n                            markRootUpdated(root, SyncLane, eventTime);\n                            ensureRootIsScheduled(root, eventTime);\n                        }\n                        return;\n                    }\n                }\n                fiber = fiber.return;\n            }\n            {\n                // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n                // will fire for errors that are thrown by destroy functions inside deleted\n                // trees. What it should instead do is propagate the error to the parent of\n                // the deleted tree. In the meantime, do not add this warning to the\n                // allowlist; this is only for our internal use.\n                error(\"Internal React error: Attempted to capture a commit phase error \" + \"inside a detached tree. This indicates a bug in React. Likely \" + \"causes include deleting the same fiber more than once, committing an \" + \"already-finished tree, or an inconsistent return pointer.\\n\\n\" + \"Error message:\\n\\n%s\", error$1);\n            }\n        }\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\n            var pingCache = root.pingCache;\n            if (pingCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                pingCache.delete(wakeable);\n            }\n            var eventTime = requestEventTime();\n            markRootPinged(root, pingedLanes);\n            warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n                // Received a ping at the same priority level at which we're currently\n                // rendering. We might want to restart this render. This should mirror\n                // the logic of whether or not a root suspends once it completes.\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\n                // we should probably never restart.\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\n                // so we can always restart.\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n                    // Restart from the root.\n                    prepareFreshStack(root, NoLanes);\n                } else {\n                    // Even though we can't restart right now, we might get an\n                    // opportunity later. So we mark this render as having a ping.\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n                }\n            }\n            ensureRootIsScheduled(root, eventTime);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n            // The boundary fiber (a Suspense component or SuspenseList component)\n            // previously was rendered in its fallback state. One of the promises that\n            // suspended it has resolved, which means at least part of the tree was\n            // likely unblocked. Try rendering again, at a new lanes.\n            if (retryLane === NoLane) {\n                // TODO: Assign this to `suspenseState.retryLane`? to avoid\n                // unnecessary entanglement?\n                retryLane = requestRetryLane(boundaryFiber);\n            } // TODO: Special case idle priority?\n            var eventTime = requestEventTime();\n            var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\n            if (root !== null) {\n                markRootUpdated(root, retryLane, eventTime);\n                ensureRootIsScheduled(root, eventTime);\n            }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n            var suspenseState = boundaryFiber.memoizedState;\n            var retryLane = NoLane;\n            if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n            var retryLane = NoLane; // Default\n            var retryCache;\n            {\n                switch(boundaryFiber.tag){\n                    case SuspenseComponent:\n                        retryCache = boundaryFiber.stateNode;\n                        var suspenseState = boundaryFiber.memoizedState;\n                        if (suspenseState !== null) {\n                            retryLane = suspenseState.retryLane;\n                        }\n                        break;\n                    case SuspenseListComponent:\n                        retryCache = boundaryFiber.stateNode;\n                        break;\n                    default:\n                        throw new Error(\"Pinged unknown suspense boundary type. \" + \"This is probably a bug in React.\");\n                }\n            }\n            if (retryCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                retryCache.delete(wakeable);\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        } // Computes the next Just Noticeable Difference (JND) boundary.\n        // The theory is that a person can't tell the difference between small differences in time.\n        // Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n        // difference in the experience. However, waiting for longer might mean that we can avoid\n        // showing an intermediate loading state. The longer we have already waited, the harder it\n        // is to tell small differences in time. Therefore, the longer we've already waited,\n        // the longer we can wait additionally. At some point we have to give up though.\n        // We pick a train model where the next boundary commits at a consistent schedule.\n        // These particular numbers are vague estimates. We expect to adjust them based on research.\n        function jnd(timeElapsed) {\n            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n        }\n        function checkForNestedUpdates() {\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n                nestedUpdateCount = 0;\n                rootWithNestedUpdates = null;\n                throw new Error(\"Maximum update depth exceeded. This can happen when a component \" + \"repeatedly calls setState inside componentWillUpdate or \" + \"componentDidUpdate. React limits the number of nested updates to \" + \"prevent infinite loops.\");\n            }\n            {\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n                    nestedPassiveUpdateCount = 0;\n                    error(\"Maximum update depth exceeded. This can happen when a component \" + \"calls setState inside useEffect, but useEffect either doesn't \" + \"have a dependency array, or one of the dependencies changes on \" + \"every render.\");\n                }\n            }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n            {\n                ReactStrictModeWarnings.flushLegacyContextWarning();\n                {\n                    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n                }\n            }\n        }\n        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n            {\n                // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n                // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n                // Maybe not a big deal since this is DEV only behavior.\n                setCurrentFiber(fiber);\n                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n                if (hasPassiveEffects) {\n                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n                }\n                invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n                if (hasPassiveEffects) {\n                    invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n                }\n                resetCurrentFiber();\n            }\n        }\n        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n            {\n                // We don't need to re-check StrictEffectsMode here.\n                // This function is only called if that check has already passed.\n                var current = firstChild;\n                var subtreeRoot = null;\n                while(current !== null){\n                    var primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n                    if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n                        current = current.child;\n                    } else {\n                        if ((current.flags & fiberFlags) !== NoFlags) {\n                            invokeEffectFn(current);\n                        }\n                        if (current.sibling !== null) {\n                            current = current.sibling;\n                        } else {\n                            current = subtreeRoot = current.return;\n                        }\n                    }\n                }\n            }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n            {\n                if ((executionContext & RenderContext) !== NoContext) {\n                    // We let the other warning about render phase updates deal with this one.\n                    return;\n                }\n                if (!(fiber.mode & ConcurrentMode)) {\n                    return;\n                }\n                var tag = fiber.tag;\n                if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n                    // Only warn for user-defined components, not internal ones like Suspense.\n                    return;\n                } // We show the whole stack but dedupe on the top component's name because\n                // the problematic code almost always lies inside that component.\n                var componentName = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                        return;\n                    }\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n                } else {\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([\n                        componentName\n                    ]);\n                }\n                var previousFiber = current;\n                try {\n                    setCurrentFiber(fiber);\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + \"This indicates that you have a side-effect in your render function that \" + \"asynchronously later calls tries to update the component. Move this work to \" + \"useEffect instead.\");\n                } finally{\n                    if (previousFiber) {\n                        setCurrentFiber(fiber);\n                    } else {\n                        resetCurrentFiber();\n                    }\n                }\n            }\n        }\n        var beginWork$1;\n        {\n            var dummyFiber = null;\n            beginWork$1 = function(current, unitOfWork, lanes) {\n                // If a component throws an error, we replay it again in a synchronously\n                // dispatched event, so that the debugger will treat it as an uncaught\n                // error See ReactErrorUtils for more information.\n                // Before entering the begin phase, copy the work-in-progress onto a dummy\n                // fiber. If beginWork throws, we'll use this to reset the state.\n                var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n                try {\n                    return beginWork(current, unitOfWork, lanes);\n                } catch (originalError) {\n                    if (originalError !== null && typeof originalError === \"object\" && typeof originalError.then === \"function\") {\n                        // Don't replay promises. Treat everything else like an error.\n                        throw originalError;\n                    } // Keep this code in sync with handleError; any changes here must have\n                    // corresponding changes there.\n                    resetContextDependencies();\n                    resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n                    // same fiber again.\n                    // Unwind the failed stack frame\n                    unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.\n                    assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n                    if (unitOfWork.mode & ProfileMode) {\n                        // Reset the profiler timer.\n                        startProfilerTimer(unitOfWork);\n                    } // Run beginWork again.\n                    invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\n                    if (hasCaughtError()) {\n                        var replayError = clearCaughtError();\n                        if (typeof replayError === \"object\" && replayError !== null && replayError._suppressLogging && typeof originalError === \"object\" && originalError !== null && !originalError._suppressLogging) {\n                            // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n                            originalError._suppressLogging = true;\n                        }\n                    } // We always throw the original error in case the second render pass is not idempotent.\n                    // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n                    throw originalError;\n                }\n            };\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n            {\n                if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n                    switch(fiber.tag){\n                        case FunctionComponent:\n                        case ForwardRef:\n                        case SimpleMemoComponent:\n                            {\n                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\"; // Dedupe by the rendering component because it's the one that needs to be fixed.\n                                var dedupeKey = renderingComponentName;\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                                    var setStateComponentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                                    error(\"Cannot update a component (`%s`) while rendering a \" + \"different component (`%s`). To locate the bad setState() call inside `%s`, \" + \"follow the stack trace as described in https://reactjs.org/link/setstate-in-render\", setStateComponentName, renderingComponentName, renderingComponentName);\n                                }\n                                break;\n                            }\n                        case ClassComponent:\n                            {\n                                if (!didWarnAboutUpdateInRender) {\n                                    error(\"Cannot update during an existing state transition (such as \" + \"within `render`). Render methods should be a pure \" + \"function of props and state.\");\n                                    didWarnAboutUpdateInRender = true;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function restorePendingUpdaters(root, lanes) {\n            {\n                if (isDevToolsPresent) {\n                    var memoizedUpdaters = root.memoizedUpdaters;\n                    memoizedUpdaters.forEach(function(schedulingFiber) {\n                        addFiberToLanesMap(root, schedulingFiber, lanes);\n                    }); // This function intentionally does not clear memoized updaters.\n                // Those may still be relevant to the current commit\n                // and a future one (e.g. Suspense).\n                }\n            }\n        }\n        var fakeActCallbackNode = {};\n        function scheduleCallback$1(priorityLevel, callback) {\n            {\n                // If we're currently inside an `act` scope, bypass Scheduler and push to\n                // the `act` queue instead.\n                var actQueue = ReactCurrentActQueue$1.current;\n                if (actQueue !== null) {\n                    actQueue.push(callback);\n                    return fakeActCallbackNode;\n                } else {\n                    return scheduleCallback(priorityLevel, callback);\n                }\n            }\n        }\n        function cancelCallback$1(callbackNode) {\n            if (callbackNode === fakeActCallbackNode) {\n                return;\n            } // In production, always call Scheduler. This function will be stripped out.\n            return cancelCallback(callbackNode);\n        }\n        function shouldForceFlushFallbacksInDEV() {\n            // Never force flush in production. This function should get stripped out.\n            return ReactCurrentActQueue$1.current !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n            {\n                if (fiber.mode & ConcurrentMode) {\n                    if (!isConcurrentActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                } else {\n                    // Legacy mode has additional cases where we suppress a warning.\n                    if (!isLegacyActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                    if (executionContext !== NoContext) {\n                        // Legacy mode doesn't warn if the update is batched, i.e.\n                        // batchedUpdates or flushSync.\n                        return;\n                    }\n                    if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n                        // For backwards compatibility with pre-hooks code, legacy mode only\n                        // warns for updates that originate from a hook.\n                        return;\n                    }\n                }\n                if (ReactCurrentActQueue$1.current === null) {\n                    var previousFiber = current;\n                    try {\n                        setCurrentFiber(fiber);\n                        error(\"An update to %s inside a test was not wrapped in act(...).\\n\\n\" + \"When testing, code that causes React state updates should be \" + \"wrapped into act(...):\\n\\n\" + \"act(() => {\\n\" + \"  /* fire events that update state */\\n\" + \"});\\n\" + \"/* assert on the output */\\n\\n\" + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n                    } finally{\n                        if (previousFiber) {\n                            setCurrentFiber(fiber);\n                        } else {\n                            resetCurrentFiber();\n                        }\n                    }\n                }\n            }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n            {\n                if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n                    error(\"A suspended resource finished loading inside a test, but the event \" + \"was not wrapped in act(...).\\n\\n\" + \"When testing, code that resolves suspended data should be wrapped \" + \"into act(...):\\n\\n\" + \"act(() => {\\n\" + \"  /* finish loading suspended data */\\n\" + \"});\\n\" + \"/* assert on the output */\\n\\n\" + \"This ensures that you're testing the behavior the user would see \" + \"in the browser.\" + \" Learn more at https://reactjs.org/link/wrap-tests-with-act\");\n                }\n            }\n        }\n        /* eslint-disable react-internal/prod-error-codes */ var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n            {\n                resolveFamily = handler;\n            }\n        };\n        function resolveFunctionForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function resolveClassForHotReloading(type) {\n            // No implementation differences.\n            return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\n                    if (type !== null && type !== undefined && typeof type.render === \"function\") {\n                        // ForwardRef is special because its resolved .type is an object,\n                        // but it's possible that we only have its inner render function in the map.\n                        // If that inner render function is different, we'll build a new forwardRef type.\n                        var currentRender = resolveFunctionForHotReloading(type.render);\n                        if (type.render !== currentRender) {\n                            var syntheticType = {\n                                $$typeof: REACT_FORWARD_REF_TYPE,\n                                render: currentRender\n                            };\n                            if (type.displayName !== undefined) {\n                                syntheticType.displayName = type.displayName;\n                            }\n                            return syntheticType;\n                        }\n                    }\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return false;\n                }\n                var prevType = fiber.elementType;\n                var nextType = element.type; // If we got here, we know types aren't === equal.\n                var needsCompareFamilies = false;\n                var $$typeofNextType = typeof nextType === \"object\" && nextType !== null ? nextType.$$typeof : null;\n                switch(fiber.tag){\n                    case ClassComponent:\n                        {\n                            if (typeof nextType === \"function\") {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case FunctionComponent:\n                        {\n                            if (typeof nextType === \"function\") {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                // We don't know the inner type yet.\n                                // We're going to assume that the lazy inner type is stable,\n                                // and so it is sufficient to avoid reconciling it away.\n                                // We're not going to unwrap or actually use the new lazy type.\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case ForwardRef:\n                        {\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\n                                // TODO: if it was but can no longer be simple,\n                                // we shouldn't set this.\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    default:\n                        return false;\n                } // Check if both types have a family and it's the same one.\n                if (needsCompareFamilies) {\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n                    // This means both of them need to be registered to preserve state.\n                    // If we unwrapped and compared the inner types for wrappers instead,\n                    // then we would risk falsely saying two separate memo(Foo)\n                    // calls are equivalent because they wrap the same Foo function.\n                    var prevFamily = resolveFamily(prevType);\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                if (typeof WeakSet !== \"function\") {\n                    return;\n                }\n                if (failedBoundaries === null) {\n                    failedBoundaries = new WeakSet();\n                }\n                failedBoundaries.add(fiber);\n            }\n        }\n        var scheduleRefresh = function(root, update) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n                flushPassiveEffects();\n                flushSync(function() {\n                    scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n                });\n            }\n        };\n        var scheduleRoot = function(root, element) {\n            {\n                if (root.context !== emptyContextObject) {\n                    // Super edge case: root has a legacy _renderSubtree context\n                    // but we don't know the parentComponent so we can't pass it.\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\n                    return;\n                }\n                flushPassiveEffects();\n                flushSync(function() {\n                    updateContainer(element, root, null, null);\n                });\n            }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n            {\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                if (resolveFamily === null) {\n                    throw new Error(\"Expected resolveFamily to be set during hot reload.\");\n                }\n                var needsRender = false;\n                var needsRemount = false;\n                if (candidateType !== null) {\n                    var family = resolveFamily(candidateType);\n                    if (family !== undefined) {\n                        if (staleFamilies.has(family)) {\n                            needsRemount = true;\n                        } else if (updatedFamilies.has(family)) {\n                            if (tag === ClassComponent) {\n                                needsRemount = true;\n                            } else {\n                                needsRender = true;\n                            }\n                        }\n                    }\n                }\n                if (failedBoundaries !== null) {\n                    if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n                        needsRemount = true;\n                    }\n                }\n                if (needsRemount) {\n                    fiber._debugNeedsRemount = true;\n                }\n                if (needsRemount || needsRender) {\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n                if (child !== null && !needsRemount) {\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n                }\n                if (sibling !== null) {\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n                }\n            }\n        }\n        var findHostInstancesForRefresh = function(root, families) {\n            {\n                var hostInstances = new Set();\n                var types = new Set(families.map(function(family) {\n                    return family.current;\n                }));\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n                return hostInstances;\n            }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n            {\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                var didMatch = false;\n                if (candidateType !== null) {\n                    if (types.has(candidateType)) {\n                        didMatch = true;\n                    }\n                }\n                if (didMatch) {\n                    // We have a match. This only drills down to the closest host components.\n                    // There's no need to search deeper because for the purpose of giving\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\n                } else {\n                    // If there's no match, maybe there will be one further down in the child tree.\n                    if (child !== null) {\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n                    }\n                }\n                if (sibling !== null) {\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n                }\n            }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n                if (foundHostInstances) {\n                    return;\n                } // If we didn't find any host children, fallback to closest host parent.\n                var node = fiber;\n                while(true){\n                    switch(node.tag){\n                        case HostComponent:\n                            hostInstances.add(node.stateNode);\n                            return;\n                        case HostPortal:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                        case HostRoot:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                    }\n                    if (node.return === null) {\n                        throw new Error(\"Expected to reach root first.\");\n                    }\n                    node = node.return;\n                }\n            }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var node = fiber;\n                var foundHostInstances = false;\n                while(true){\n                    if (node.tag === HostComponent) {\n                        // We got a match.\n                        foundHostInstances = true;\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === fiber) {\n                        return foundHostInstances;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === fiber) {\n                            return foundHostInstances;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n            return false;\n        }\n        var hasBadMapPolyfill;\n        {\n            hasBadMapPolyfill = false;\n            try {\n                var nonExtensibleObject = Object.preventExtensions({});\n                /* eslint-disable no-new */ new Map([\n                    [\n                        nonExtensibleObject,\n                        null\n                    ]\n                ]);\n                new Set([\n                    nonExtensibleObject\n                ]);\n            /* eslint-enable no-new */ } catch (e) {\n                // TODO: Consider warning about bad polyfills\n                hasBadMapPolyfill = true;\n            }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n            // Instance\n            this.tag = tag;\n            this.key = key;\n            this.elementType = null;\n            this.type = null;\n            this.stateNode = null; // Fiber\n            this.return = null;\n            this.child = null;\n            this.sibling = null;\n            this.index = 0;\n            this.ref = null;\n            this.pendingProps = pendingProps;\n            this.memoizedProps = null;\n            this.updateQueue = null;\n            this.memoizedState = null;\n            this.dependencies = null;\n            this.mode = mode; // Effects\n            this.flags = NoFlags;\n            this.subtreeFlags = NoFlags;\n            this.deletions = null;\n            this.lanes = NoLanes;\n            this.childLanes = NoLanes;\n            this.alternate = null;\n            {\n                // Note: The following is done to avoid a v8 performance cliff.\n                //\n                // Initializing the fields below to smis and later updating them with\n                // double values will cause Fibers to end up having separate shapes.\n                // This behavior/bug has something to do with Object.preventExtension().\n                // Fortunately this only impacts DEV builds.\n                // Unfortunately it makes React unusably slow for some applications.\n                // To work around this, initialize the fields below with doubles.\n                //\n                // Learn more about this here:\n                // https://github.com/facebook/react/issues/14365\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n                this.actualDuration = Number.NaN;\n                this.actualStartTime = Number.NaN;\n                this.selfBaseDuration = Number.NaN;\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n                // This won't trigger the performance cliff mentioned above,\n                // and it simplifies other profiler code (including DevTools).\n                this.actualDuration = 0;\n                this.actualStartTime = -1;\n                this.selfBaseDuration = 0;\n                this.treeBaseDuration = 0;\n            }\n            {\n                // This isn't directly used but is handy for debugging internals:\n                this._debugSource = null;\n                this._debugOwner = null;\n                this._debugNeedsRemount = false;\n                this._debugHookTypes = null;\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n                    Object.preventExtensions(this);\n                }\n            }\n        } // This is a constructor function, rather than a POJO constructor, still\n        // please ensure we do the following:\n        // 1) Nobody should add any instance methods on this. Instance methods can be\n        //    more difficult to predict when they get optimized and they are almost\n        //    never inlined properly in static compilers.\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n        //    always know when it is a fiber.\n        // 3) We might want to experiment with using numeric keys since they are easier\n        //    to optimize in a non-JIT environment.\n        // 4) We can easily go from a constructor to a createFiber object literal if that\n        //    is faster.\n        // 5) It should be easy to port this to a C struct and keep a C implementation\n        //    compatible.\n        var createFiber = function(tag, pendingProps, key, mode) {\n            // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n            return new FiberNode(tag, pendingProps, key, mode);\n        };\n        function shouldConstruct$1(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n            return typeof type === \"function\" && !shouldConstruct$1(type) && type.defaultProps === undefined;\n        }\n        function resolveLazyComponentTag(Component) {\n            if (typeof Component === \"function\") {\n                return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n            } else if (Component !== undefined && Component !== null) {\n                var $$typeof = Component.$$typeof;\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\n                    return ForwardRef;\n                }\n                if ($$typeof === REACT_MEMO_TYPE) {\n                    return MemoComponent;\n                }\n            }\n            return IndeterminateComponent;\n        } // This is used to create an alternate fiber to do work on.\n        function createWorkInProgress(current, pendingProps) {\n            var workInProgress = current.alternate;\n            if (workInProgress === null) {\n                // We use a double buffering pooling technique because we know that we'll\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\n                // node that we're free to reuse. This is lazily created to avoid allocating\n                // extra objects for things that are never updated. It also allow us to\n                // reclaim the extra memory if needed.\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n                workInProgress.elementType = current.elementType;\n                workInProgress.type = current.type;\n                workInProgress.stateNode = current.stateNode;\n                {\n                    // DEV-only fields\n                    workInProgress._debugSource = current._debugSource;\n                    workInProgress._debugOwner = current._debugOwner;\n                    workInProgress._debugHookTypes = current._debugHookTypes;\n                }\n                workInProgress.alternate = current;\n                current.alternate = workInProgress;\n            } else {\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // We already have an alternate.\n                // Reset the effect tag.\n                workInProgress.flags = NoFlags; // The effects are no longer valid.\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.deletions = null;\n                {\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n                    // This prevents time from endlessly accumulating in new commits.\n                    // This has the downside of resetting values for different priority renders,\n                    // But works for yielding (the common case) and should support resuming.\n                    workInProgress.actualDuration = 0;\n                    workInProgress.actualStartTime = -1;\n                }\n            } // Reset all effects except static ones.\n            // Static effects are not specific to a render.\n            workInProgress.flags = current.flags & StaticMask;\n            workInProgress.childLanes = current.childLanes;\n            workInProgress.lanes = current.lanes;\n            workInProgress.child = current.child;\n            workInProgress.memoizedProps = current.memoizedProps;\n            workInProgress.memoizedState = current.memoizedState;\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n            // it cannot be shared with the current fiber.\n            var currentDependencies = current.dependencies;\n            workInProgress.dependencies = currentDependencies === null ? null : {\n                lanes: currentDependencies.lanes,\n                firstContext: currentDependencies.firstContext\n            }; // These will be overridden during the parent's reconciliation\n            workInProgress.sibling = current.sibling;\n            workInProgress.index = current.index;\n            workInProgress.ref = current.ref;\n            {\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\n            }\n            {\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n                switch(workInProgress.tag){\n                    case IndeterminateComponent:\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\n                        break;\n                    case ClassComponent:\n                        workInProgress.type = resolveClassForHotReloading(current.type);\n                        break;\n                    case ForwardRef:\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n                        break;\n                }\n            }\n            return workInProgress;\n        } // Used to reuse a Fiber for a second pass.\n        function resetWorkInProgress(workInProgress, renderLanes) {\n            // This resets the Fiber to what createFiber or createWorkInProgress would\n            // have set the values to before during the first pass. Ideally this wouldn't\n            // be necessary but unfortunately many code paths reads from the workInProgress\n            // when they should be reading from current and writing to workInProgress.\n            // We assume pendingProps, index, key, ref, return are still untouched to\n            // avoid doing another reconciliation.\n            // Reset the effect flags but keep any Placement tags, since that's something\n            // that child fiber is setting, not the reconciliation.\n            workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n            var current = workInProgress.alternate;\n            if (current === null) {\n                // Reset to createFiber's initial values.\n                workInProgress.childLanes = NoLanes;\n                workInProgress.lanes = renderLanes;\n                workInProgress.child = null;\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.memoizedProps = null;\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null;\n                workInProgress.dependencies = null;\n                workInProgress.stateNode = null;\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = 0;\n                    workInProgress.treeBaseDuration = 0;\n                }\n            } else {\n                // Reset to the cloned values that createWorkInProgress would've.\n                workInProgress.childLanes = current.childLanes;\n                workInProgress.lanes = current.lanes;\n                workInProgress.child = current.child;\n                workInProgress.subtreeFlags = NoFlags;\n                workInProgress.deletions = null;\n                workInProgress.memoizedProps = current.memoizedProps;\n                workInProgress.memoizedState = current.memoizedState;\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n                // it cannot be shared with the current fiber.\n                var currentDependencies = current.dependencies;\n                workInProgress.dependencies = currentDependencies === null ? null : {\n                    lanes: currentDependencies.lanes,\n                    firstContext: currentDependencies.firstContext\n                };\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\n                }\n            }\n            return workInProgress;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n            var mode;\n            if (tag === ConcurrentRoot) {\n                mode = ConcurrentMode;\n                if (isStrictMode === true) {\n                    mode |= StrictLegacyMode;\n                    {\n                        mode |= StrictEffectsMode;\n                    }\n                }\n            } else {\n                mode = NoMode;\n            }\n            if (isDevToolsPresent) {\n                // Always collect profile timings when DevTools are present.\n                // This enables DevTools to start capturing timing at any point–\n                // Without some nodes in the tree having empty base times.\n                mode |= ProfileMode;\n            }\n            return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n            var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n            var resolvedType = type;\n            if (typeof type === \"function\") {\n                if (shouldConstruct$1(type)) {\n                    fiberTag = ClassComponent;\n                    {\n                        resolvedType = resolveClassForHotReloading(resolvedType);\n                    }\n                } else {\n                    {\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\n                    }\n                }\n            } else if (typeof type === \"string\") {\n                fiberTag = HostComponent;\n            } else {\n                getTag: switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                    case REACT_STRICT_MODE_TYPE:\n                        fiberTag = Mode;\n                        mode |= StrictLegacyMode;\n                        if ((mode & ConcurrentMode) !== NoMode) {\n                            // Strict effects should never run on legacy roots\n                            mode |= StrictEffectsMode;\n                        }\n                        break;\n                    case REACT_PROFILER_TYPE:\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_TYPE:\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                    case REACT_OFFSCREEN_TYPE:\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                    case REACT_LEGACY_HIDDEN_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_SCOPE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_CACHE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_TRACING_MARKER_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\n                    // eslint-disable-next-line no-fallthrough\n                    default:\n                        {\n                            if (typeof type === \"object\" && type !== null) {\n                                switch(type.$$typeof){\n                                    case REACT_PROVIDER_TYPE:\n                                        fiberTag = ContextProvider;\n                                        break getTag;\n                                    case REACT_CONTEXT_TYPE:\n                                        // This is a consumer\n                                        fiberTag = ContextConsumer;\n                                        break getTag;\n                                    case REACT_FORWARD_REF_TYPE:\n                                        fiberTag = ForwardRef;\n                                        {\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                                        }\n                                        break getTag;\n                                    case REACT_MEMO_TYPE:\n                                        fiberTag = MemoComponent;\n                                        break getTag;\n                                    case REACT_LAZY_TYPE:\n                                        fiberTag = LazyComponent;\n                                        resolvedType = null;\n                                        break getTag;\n                                }\n                            }\n                            var info = \"\";\n                            {\n                                if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                                    info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and \" + \"named imports.\";\n                                }\n                                var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n                                if (ownerName) {\n                                    info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                                }\n                            }\n                            throw new Error(\"Element type is invalid: expected a string (for built-in \" + \"components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n                        }\n                }\n            }\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\n            fiber.elementType = type;\n            fiber.type = resolvedType;\n            fiber.lanes = lanes;\n            {\n                fiber._debugOwner = owner;\n            }\n            return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n            var owner = null;\n            {\n                owner = element._owner;\n            }\n            var type = element.type;\n            var key = element.key;\n            var pendingProps = element.props;\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n            {\n                fiber._debugSource = element._source;\n                fiber._debugOwner = element._owner;\n            }\n            return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n            var fiber = createFiber(Fragment, elements, key, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n            {\n                if (typeof pendingProps.id !== \"string\") {\n                    error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n                }\n            }\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n            fiber.elementType = REACT_PROFILER_TYPE;\n            fiber.lanes = lanes;\n            {\n                fiber.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                };\n            }\n            return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\n            fiber.lanes = lanes;\n            var primaryChildInstance = {};\n            fiber.stateNode = primaryChildInstance;\n            return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n            var fiber = createFiber(HostText, content, null, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromHostInstanceForDeletion() {\n            var fiber = createFiber(HostComponent, null, null, NoMode);\n            fiber.elementType = \"DELETED\";\n            return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n            var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n            fiber.stateNode = dehydratedNode;\n            return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n            var pendingProps = portal.children !== null ? portal.children : [];\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n            fiber.lanes = lanes;\n            fiber.stateNode = {\n                containerInfo: portal.containerInfo,\n                pendingChildren: null,\n                // Used by persistent updates\n                implementation: portal.implementation\n            };\n            return fiber;\n        } // Used for stashing WIP properties to replay failed work in DEV.\n        function assignFiberPropertiesInDEV(target, source) {\n            if (target === null) {\n                // This Fiber's initial properties will always be overwritten.\n                // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n                target = createFiber(IndeterminateComponent, null, null, NoMode);\n            } // This is intentionally written as a list of all properties.\n            // We tried to use Object.assign() instead but this is called in\n            // the hottest path, and Object.assign() was too slow:\n            // https://github.com/facebook/react/issues/12502\n            // This code is DEV-only so size is not a concern.\n            target.tag = source.tag;\n            target.key = source.key;\n            target.elementType = source.elementType;\n            target.type = source.type;\n            target.stateNode = source.stateNode;\n            target.return = source.return;\n            target.child = source.child;\n            target.sibling = source.sibling;\n            target.index = source.index;\n            target.ref = source.ref;\n            target.pendingProps = source.pendingProps;\n            target.memoizedProps = source.memoizedProps;\n            target.updateQueue = source.updateQueue;\n            target.memoizedState = source.memoizedState;\n            target.dependencies = source.dependencies;\n            target.mode = source.mode;\n            target.flags = source.flags;\n            target.subtreeFlags = source.subtreeFlags;\n            target.deletions = source.deletions;\n            target.lanes = source.lanes;\n            target.childLanes = source.childLanes;\n            target.alternate = source.alternate;\n            {\n                target.actualDuration = source.actualDuration;\n                target.actualStartTime = source.actualStartTime;\n                target.selfBaseDuration = source.selfBaseDuration;\n                target.treeBaseDuration = source.treeBaseDuration;\n            }\n            target._debugSource = source._debugSource;\n            target._debugOwner = source._debugOwner;\n            target._debugNeedsRemount = source._debugNeedsRemount;\n            target._debugHookTypes = source._debugHookTypes;\n            return target;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n            this.tag = tag;\n            this.containerInfo = containerInfo;\n            this.pendingChildren = null;\n            this.current = null;\n            this.pingCache = null;\n            this.finishedWork = null;\n            this.timeoutHandle = noTimeout;\n            this.context = null;\n            this.pendingContext = null;\n            this.callbackNode = null;\n            this.callbackPriority = NoLane;\n            this.eventTimes = createLaneMap(NoLanes);\n            this.expirationTimes = createLaneMap(NoTimestamp);\n            this.pendingLanes = NoLanes;\n            this.suspendedLanes = NoLanes;\n            this.pingedLanes = NoLanes;\n            this.expiredLanes = NoLanes;\n            this.mutableReadLanes = NoLanes;\n            this.finishedLanes = NoLanes;\n            this.entangledLanes = NoLanes;\n            this.entanglements = createLaneMap(NoLanes);\n            this.identifierPrefix = identifierPrefix;\n            this.onRecoverableError = onRecoverableError;\n            if (supportsHydration) {\n                this.mutableSourceEagerHydrationData = null;\n            }\n            {\n                this.effectDuration = 0;\n                this.passiveEffectDuration = 0;\n            }\n            {\n                this.memoizedUpdaters = new Set();\n                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n                for(var _i = 0; _i < TotalLanes; _i++){\n                    pendingUpdatersLaneMap.push(new Set());\n                }\n            }\n            {\n                switch(tag){\n                    case ConcurrentRoot:\n                        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n                        break;\n                    case LegacyRoot:\n                        this._debugRootType = hydrate ? \"hydrate()\" : \"render()\";\n                        break;\n                }\n            }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread\n        // them through the root constructor. Perhaps we should put them all into a\n        // single type, like a DynamicHostConfig that is defined by the renderer.\n        identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n            // stateNode is any.\n            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n            root.current = uninitializedFiber;\n            uninitializedFiber.stateNode = root;\n            {\n                var _initialState = {\n                    element: initialChildren,\n                    isDehydrated: hydrate,\n                    cache: null,\n                    // not enabled yet\n                    transitions: null\n                };\n                uninitializedFiber.memoizedState = _initialState;\n            }\n            initializeUpdateQueue(uninitializedFiber);\n            return root;\n        }\n        var ReactVersion = \"18.0.0-fc46dba67-20220329\";\n        function createPortal(children, containerInfo, implementation) {\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            {\n                checkKeyStringCoercion(key);\n            }\n            return {\n                // This tag allow us to uniquely identify this as a React Portal\n                $$typeof: REACT_PORTAL_TYPE,\n                key: key == null ? null : \"\" + key,\n                children: children,\n                containerInfo: containerInfo,\n                implementation: implementation\n            };\n        }\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n            didWarnAboutNestedUpdates = false;\n            didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n            if (!parentComponent) {\n                return emptyContextObject;\n            }\n            var fiber = get(parentComponent);\n            var parentContext = findCurrentUnmaskedContext(fiber);\n            if (fiber.tag === ClassComponent) {\n                var Component = fiber.type;\n                if (isContextProvider(Component)) {\n                    return processChildContext(fiber, Component, parentContext);\n                }\n            }\n            return parentContext;\n        }\n        function findHostInstance(component) {\n            var fiber = get(component);\n            if (fiber === undefined) {\n                if (typeof component.render === \"function\") {\n                    throw new Error(\"Unable to find node on an unmounted component.\");\n                } else {\n                    var keys = Object.keys(component).join(\",\");\n                    throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n            {\n                var fiber = get(component);\n                if (fiber === undefined) {\n                    if (typeof component.render === \"function\") {\n                        throw new Error(\"Unable to find node on an unmounted component.\");\n                    } else {\n                        var keys = Object.keys(component).join(\",\");\n                        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                    }\n                }\n                var hostFiber = findCurrentHostFiber(fiber);\n                if (hostFiber === null) {\n                    return null;\n                }\n                if (hostFiber.mode & StrictLegacyMode) {\n                    var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\n                        var previousFiber = current;\n                        try {\n                            setCurrentFiber(hostFiber);\n                            if (fiber.mode & StrictLegacyMode) {\n                                error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which is inside StrictMode. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                            } else {\n                                error(\"%s is deprecated in StrictMode. \" + \"%s was passed an instance of %s which renders StrictMode children. \" + \"Instead, add a ref directly to the element you want to reference. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                            }\n                        } finally{\n                            // Ideally this should reset to previous but this shouldn't be called in\n                            // render and there's another warning for that anyway.\n                            if (previousFiber) {\n                                setCurrentFiber(previousFiber);\n                            } else {\n                                resetCurrentFiber();\n                            }\n                        }\n                    }\n                }\n                return hostFiber.stateNode;\n            }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var hydrate = false;\n            var initialChildren = null;\n            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n            var hydrate = true;\n            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor\n            root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n            // a regular update because the initial render must match was was rendered\n            // on the server.\n            // NOTE: This update intentionally doesn't have a payload. We're only using\n            // the update to schedule work on the root fiber (and, for legacy roots, to\n            // enqueue the callback if one is provided).\n            var current = root.current;\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(current);\n            var update = createUpdate(eventTime, lane);\n            update.callback = callback !== undefined && callback !== null ? callback : null;\n            enqueueUpdate(current, update);\n            scheduleInitialHydrationOnRoot(root, lane, eventTime);\n            return root;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n            {\n                onScheduleRoot(container, element);\n            }\n            var current$1 = container.current;\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(current$1);\n            {\n                markRenderScheduled(lane);\n            }\n            var context = getContextForSubtree(parentComponent);\n            if (container.context === null) {\n                container.context = context;\n            } else {\n                container.pendingContext = context;\n            }\n            {\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n                    didWarnAboutNestedUpdates = true;\n                    error(\"Render methods should be a pure function of props and state; \" + \"triggering nested component updates from render is not allowed. \" + \"If necessary, trigger nested updates in componentDidUpdate.\\n\\n\" + \"Check the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\");\n                }\n            }\n            var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: element\n            };\n            callback = callback === undefined ? null : callback;\n            if (callback !== null) {\n                {\n                    if (typeof callback !== \"function\") {\n                        error(\"render(...): Expected the last optional `callback` argument to be a \" + \"function. Instead received: %s.\", callback);\n                    }\n                }\n                update.callback = callback;\n            }\n            enqueueUpdate(current$1, update);\n            var root = scheduleUpdateOnFiber(current$1, lane, eventTime);\n            if (root !== null) {\n                entangleTransitions(root, current$1, lane);\n            }\n            return lane;\n        }\n        function getPublicRootInstance(container) {\n            var containerFiber = container.current;\n            if (!containerFiber.child) {\n                return null;\n            }\n            switch(containerFiber.child.tag){\n                case HostComponent:\n                    return getPublicInstance(containerFiber.child.stateNode);\n                default:\n                    return containerFiber.child.stateNode;\n            }\n        }\n        function attemptSynchronousHydration(fiber) {\n            switch(fiber.tag){\n                case HostRoot:\n                    var root = fiber.stateNode;\n                    if (isRootDehydrated(root)) {\n                        // Flush the first scheduled \"update\".\n                        var lanes = getHighestPriorityPendingLanes(root);\n                        flushRoot(root, lanes);\n                    }\n                    break;\n                case SuspenseComponent:\n                    var eventTime = requestEventTime();\n                    flushSync(function() {\n                        return scheduleUpdateOnFiber(fiber, SyncLane, eventTime);\n                    }); // If we're still blocked after this, we need to increase\n                    // the priority of any promises resolving within this\n                    // boundary so that they next attempt also has higher pri.\n                    var retryLane = SyncLane;\n                    markRetryLaneIfNotHydrated(fiber, retryLane);\n                    break;\n            }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n            }\n        } // Increases the priority of thenables when they resolve within this boundary.\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n            markRetryLaneImpl(fiber, retryLane);\n            var alternate = fiber.alternate;\n            if (alternate) {\n                markRetryLaneImpl(alternate, retryLane);\n            }\n        }\n        function attemptContinuousHydration(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority and they should not suspend on I/O,\n                // since you have to wrap anything that might suspend in\n                // Suspense.\n                return;\n            }\n            var eventTime = requestEventTime();\n            var lane = SelectiveHydrationLane;\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority other than synchronously flush it.\n                return;\n            }\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            scheduleUpdateOnFiber(fiber, lane, eventTime);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        var shouldErrorImpl = function(fiber) {\n            return null;\n        };\n        function shouldError(fiber) {\n            return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n            return false;\n        };\n        function shouldSuspend(fiber) {\n            return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n            var copyWithDeleteImpl = function(obj, path, index) {\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === path.length) {\n                    if (isArray(updated)) {\n                        updated.splice(key, 1);\n                    } else {\n                        delete updated[key];\n                    }\n                    return updated;\n                } // $FlowFixMe number or string is fine here\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n                return updated;\n            };\n            var copyWithDelete = function(obj, path) {\n                return copyWithDeleteImpl(obj, path, 0);\n            };\n            var copyWithRenameImpl = function(obj, oldPath, newPath, index) {\n                var oldKey = oldPath[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === oldPath.length) {\n                    var newKey = newPath[index]; // $FlowFixMe number or string is fine here\n                    updated[newKey] = updated[oldKey];\n                    if (isArray(updated)) {\n                        updated.splice(oldKey, 1);\n                    } else {\n                        delete updated[oldKey];\n                    }\n                } else {\n                    // $FlowFixMe number or string is fine here\n                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n                }\n                return updated;\n            };\n            var copyWithRename = function(obj, oldPath, newPath) {\n                if (oldPath.length !== newPath.length) {\n                    warn(\"copyWithRename() expects paths of the same length\");\n                    return;\n                } else {\n                    for(var i = 0; i < newPath.length - 1; i++){\n                        if (oldPath[i] !== newPath[i]) {\n                            warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                            return;\n                        }\n                    }\n                }\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\n            };\n            var copyWithSetImpl = function(obj, path, index, value) {\n                if (index >= path.length) {\n                    return value;\n                }\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n                return updated;\n            };\n            var copyWithSet = function(obj, path, value) {\n                return copyWithSetImpl(obj, path, 0, value);\n            };\n            var findHook = function(fiber, id) {\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\n                // This may change in the future with e.g. nested hooks.\n                var currentHook = fiber.memoizedState;\n                while(currentHook !== null && id > 0){\n                    currentHook = currentHook.next;\n                    id--;\n                }\n                return currentHook;\n            }; // Support DevTools editable values for useState and useReducer.\n            overrideHookState = function(fiber, id, path, value) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithSet(hook.memoizedState, path, value);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            };\n            overrideHookStateDeletePath = function(fiber, id, path) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithDelete(hook.memoizedState, path);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            };\n            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n                }\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n            overrideProps = function(fiber, path, value) {\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            overridePropsDeletePath = function(fiber, path) {\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            overridePropsRenamePath = function(fiber, oldPath, newPath) {\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            scheduleUpdate = function(fiber) {\n                scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n            };\n            setErrorHandler = function(newShouldErrorImpl) {\n                shouldErrorImpl = newShouldErrorImpl;\n            };\n            setSuspenseHandler = function(newShouldSuspendImpl) {\n                shouldSuspendImpl = newShouldSuspendImpl;\n            };\n        }\n        function findHostInstanceByFiber(fiber) {\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n            return null;\n        }\n        function getCurrentFiberForDevTools() {\n            return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n            var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n            return injectInternals({\n                bundleType: devToolsConfig.bundleType,\n                version: devToolsConfig.version,\n                rendererPackageName: devToolsConfig.rendererPackageName,\n                rendererConfig: devToolsConfig.rendererConfig,\n                overrideHookState: overrideHookState,\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\n                overrideProps: overrideProps,\n                overridePropsDeletePath: overridePropsDeletePath,\n                overridePropsRenamePath: overridePropsRenamePath,\n                setErrorHandler: setErrorHandler,\n                setSuspenseHandler: setSuspenseHandler,\n                scheduleUpdate: scheduleUpdate,\n                currentDispatcherRef: ReactCurrentDispatcher,\n                findHostInstanceByFiber: findHostInstanceByFiber,\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n                // React Refresh\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\n                scheduleRefresh: scheduleRefresh,\n                scheduleRoot: scheduleRoot,\n                setRefreshHandler: setRefreshHandler,\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\n                getCurrentFiber: getCurrentFiberForDevTools,\n                // Enables DevTools to detect reconciler version rather than renderer version\n                // which may not match for third party renderers.\n                reconcilerVersion: ReactVersion\n            });\n        }\n        exports.attemptContinuousHydration = attemptContinuousHydration;\n        exports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n        exports.attemptSynchronousHydration = attemptSynchronousHydration;\n        exports.batchedUpdates = batchedUpdates;\n        exports.createComponentSelector = createComponentSelector;\n        exports.createContainer = createContainer;\n        exports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n        exports.createHydrationContainer = createHydrationContainer;\n        exports.createPortal = createPortal;\n        exports.createRoleSelector = createRoleSelector;\n        exports.createTestNameSelector = createTestNameSelector;\n        exports.createTextSelector = createTextSelector;\n        exports.deferredUpdates = deferredUpdates;\n        exports.discreteUpdates = discreteUpdates;\n        exports.findAllNodes = findAllNodes;\n        exports.findBoundingRects = findBoundingRects;\n        exports.findHostInstance = findHostInstance;\n        exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n        exports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n        exports.flushControlled = flushControlled;\n        exports.flushPassiveEffects = flushPassiveEffects;\n        exports.flushSync = flushSync;\n        exports.focusWithin = focusWithin;\n        exports.getCurrentUpdatePriority = getCurrentUpdatePriority;\n        exports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n        exports.getPublicRootInstance = getPublicRootInstance;\n        exports.injectIntoDevTools = injectIntoDevTools;\n        exports.isAlreadyRendering = isAlreadyRendering;\n        exports.observeVisibleRects = observeVisibleRects;\n        exports.registerMutableSourceForHydration = registerMutableSourceForHydration;\n        exports.runWithPriority = runWithPriority;\n        exports.shouldError = shouldError;\n        exports.shouldSuspend = shouldSuspend;\n        exports.updateContainer = updateContainer;\n        return exports;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjI3LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztDQVFDLEdBRUQ7QUFFQSxJQUFJQSxJQUFxQyxFQUFFO0lBQ3pDQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsY0FBY0MsYUFBYTtRQUNuRCxJQUFJRixVQUFVLENBQUM7UUFDbkI7UUFFQSxJQUFJRyxRQUFRQyxtQkFBT0EsQ0FBQztRQUNwQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztRQUV4QixJQUFJRSx1QkFBdUJILE1BQU1JLGtEQUFrRDtRQUVuRixJQUFJQyxrQkFBa0I7UUFDdEIsU0FBU0MsbUJBQW1CQyxrQkFBa0I7WUFDNUM7Z0JBQ0VGLGtCQUFrQkU7WUFDcEI7UUFDRixFQUFFLCtEQUErRDtRQUNqRSwrQ0FBK0M7UUFDL0MsRUFBRTtRQUNGLDhEQUE4RDtRQUM5RCxxQ0FBcUM7UUFFckMsU0FBU0MsS0FBS0MsTUFBTTtZQUNsQjtnQkFDRSxJQUFJLENBQUNKLGlCQUFpQjtvQkFDcEIsSUFBSyxJQUFJSyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO3dCQUMxR0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO29CQUNsQztvQkFFQUMsYUFBYSxRQUFRUCxRQUFRSTtnQkFDL0I7WUFDRjtRQUNGO1FBQ0EsU0FBU0ksTUFBTVIsTUFBTTtZQUNuQjtnQkFDRSxJQUFJLENBQUNKLGlCQUFpQjtvQkFDcEIsSUFBSyxJQUFJYSxRQUFRUCxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUksUUFBUSxJQUFJQSxRQUFRLElB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aHJFLFFBQVFzdEUsa0JBQWtCLEdBQUdBO1FBQzdCdHRFLFFBQVFpakUsa0JBQWtCLEdBQUdBO1FBQzdCampFLFFBQVFvN0QsbUJBQW1CLEdBQUdBO1FBQzlCcDdELFFBQVFncUMsaUNBQWlDLEdBQUdBO1FBQzVDaHFDLFFBQVFvakIsZUFBZSxHQUFHQTtRQUMxQnBqQixRQUFRMmpELFdBQVcsR0FBR0E7UUFDdEIzakQsUUFBUXNtRCxhQUFhLEdBQUdBO1FBQ3hCdG1ELFFBQVF3bkUsZUFBZSxHQUFHQTtRQUN0QixPQUFPeG5FO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWNvbmNpbGVyQDAuMjcuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanM/MzQwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gJCQkcmVjb25jaWxlcigkJCRob3N0Q29uZmlnKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKCdzY2hlZHVsZXInKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBzdXBwcmVzc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpIHtcbiAge1xuICAgIHN1cHByZXNzV2FybmluZyA9IG5ld1N1cHByZXNzV2FybmluZztcbiAgfVxufSAvLyBJbiBERVYsIGNhbGxzIHRvIGNvbnNvbGUud2FybiBhbmQgY29uc29sZS5lcnJvciBnZXQgcmVwbGFjZWRcbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGlmICghc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlbmFibGVQZXJzaXN0ZW50T2Zmc2NyZWVuSG9zdENvbnRhaW5lciA9IGZhbHNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdGhlIHJlYWN0LXJlY29uY2lsZXIgcGFja2FnZS5cblxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXIgPSBmYWxzZTsgLy8gU3VwcG9ydCBsZWdhY3kgUHJpbWVyIHN1cHBvcnQgb24gaW50ZXJuYWwgRkIgd3d3XG5cbnZhciBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uID0gZmFsc2U7IC8vIEZCLW9ubHkgdXNhZ2UuIFRoZSBuZXcgQVBJIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzLlxuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuXG52YXIgZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRml6elxudmFyIHdhcm5BYm91dFN0cmluZ1JlZnMgPSBmYWxzZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxuXG52YXIgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyID0gdHJ1ZTsgLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyA9IHRydWU7IC8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgRnJhZ21lbnQgPSA3O1xudmFyIE1vZGUgPSA4O1xudmFyIENvbnRleHRDb25zdW1lciA9IDk7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFByb2ZpbGVyID0gMTI7XG52YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbnZhciBNZW1vQ29tcG9uZW50ID0gMTQ7XG52YXIgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xudmFyIExhenlDb21wb25lbnQgPSAxNjtcbnZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbnZhciBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbnZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIE9mZnNjcmVlbkNvbXBvbmVudCA9IDIyO1xudmFyIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IDIzO1xudmFyIENhY2hlQ29tcG9uZW50ID0gMjQ7XG52YXIgVHJhY2luZ01hcmtlckNvbXBvbmVudCA9IDI1O1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKTtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUkMShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lJDEodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgdmFyIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnQ2FjaGUnO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lJDEocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRGVoeWRyYXRlZEZyYWdtZW50JztcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgLy8gSG9zdCBjb21wb25lbnQgdHlwZSBpcyB0aGUgZGlzcGxheSBuYW1lIChlLmcuIFwiZGl2XCIsIFwiVmlld1wiKVxuICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuICdSb290JztcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gJ1RleHQnO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgLy8gTmFtZSBjb21lcyBmcm9tIHRoZSB0eXBlIGluIHRoaXMgY2FzZTsgd2UgZG9uJ3QgaGF2ZSBhIHRhZy5cbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSkge1xuICAgICAgICAvLyBEb24ndCBiZSBsZXNzIHNwZWNpZmljIHRoYW4gc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuICAgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ01vZGUnO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTY29wZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG4gICAgLy8gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhpcyB0YWdzIGNvbWUgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB0eXBlOlxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuUGxhY2VtZW50IHwgVXBkYXRlO1xudmFyIENoaWxkRGVsZXRpb24gPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBGb3JjZUNsaWVudFJlbmRlciA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgUmVmID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyO1xudmFyIFNuYXBzaG90ID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBIeWRyYXRpbmcgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIEh5ZHJhdGluZ0FuZFVwZGF0ZSA9XG4vKiAgICAgICAgICAgKi9cbkh5ZHJhdGluZyB8IFVwZGF0ZTtcbnZhciBWaXNpYmlsaXR5ID1cbi8qICAgICAgICAgICAgICAgICAgICovXG44MTkyO1xudmFyIFN0b3JlQ29uc2lzdGVuY3kgPVxuLyogICAgICAgICAgICAgKi9cbjE2Mzg0O1xudmFyIExpZmVjeWNsZUVmZmVjdE1hc2sgPSBQYXNzaXZlIHwgVXBkYXRlIHwgQ2FsbGJhY2sgfCBSZWYgfCBTbmFwc2hvdCB8IFN0b3JlQ29uc2lzdGVuY3k7IC8vIFVuaW9uIG9mIGFsbCBjb21taXQgZmxhZ3MgKGZsYWdzIHdpdGggdGhlIGxpZmV0aW1lIG9mIGEgcGFydGljdWxhciBjb21taXQpXG5cbnZhciBIb3N0RWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAgICAgICovXG4zMjc2NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFNob3VsZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgKi9cbjY1NTM2O1xudmFyIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UgPVxuLyogKi9cbjEzMTA3MjtcbnZhciBGb3JrZWQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4xMDQ4NTc2OyAvLyBTdGF0aWMgdGFncyBkZXNjcmliZSBhc3BlY3RzIG9mIGEgZmliZXIgdGhhdCBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLFxuLy8gZS5nLiBhIGZpYmVyIHVzZXMgYSBwYXNzaXZlIGVmZmVjdCAoZXZlbiBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlcyBvbiB0aGlzIHBhcnRpY3VsYXIgcmVuZGVyKS5cbi8vIFRoaXMgZW5hYmxlcyB1cyB0byBkZWZlciBtb3JlIHdvcmsgaW4gdGhlIHVubW91bnQgY2FzZSxcbi8vIHNpbmNlIHdlIGNhbiBkZWZlciB0cmF2ZXJzaW5nIHRoZSB0cmVlIGR1cmluZyBsYXlvdXQgdG8gbG9vayBmb3IgUGFzc2l2ZSBlZmZlY3RzLFxuLy8gYW5kIGluc3RlYWQgcmVseSBvbiB0aGUgc3RhdGljIGZsYWcgYXMgYSBzaWduYWwgdGhhdCB0aGVyZSBtYXkgYmUgY2xlYW51cCB3b3JrLlxuXG52YXIgUmVmU3RhdGljID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBMYXlvdXRTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgICovXG40MTk0MzA0O1xudmFyIFBhc3NpdmVTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7IC8vIFRoZXNlIGZsYWdzIGFsbG93IHVzIHRvIHRyYXZlcnNlIHRvIGZpYmVycyB0aGF0IGhhdmUgZWZmZWN0cyBvbiBtb3VudFxuLy8gd2l0aG91dCB0cmF2ZXJzaW5nIHRoZSBlbnRpcmUgdHJlZSBhZnRlciBldmVyeSBjb21taXQgZm9yXG4vLyBkb3VibGUgaW52b2tpbmdcblxudmFyIE1vdW50TGF5b3V0RGV2ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIE1vdW50UGFzc2l2ZURldiA9XG4vKiAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyOyAvLyBHcm91cHMgb2YgZmxhZ3MgdGhhdCBhcmUgdXNlZCBpbiB0aGUgY29tbWl0IHBoYXNlIHRvIHNraXAgb3ZlciB0cmVlcyB0aGF0XG4vLyBkb24ndCBjb250YWluIGVmZmVjdHMsIGJ5IGNoZWNraW5nIHN1YnRyZWVGbGFncy5cblxudmFyIEJlZm9yZU11dGF0aW9uTWFzayA9IC8vIFRPRE86IFJlbW92ZSBVcGRhdGUgZmxhZyBmcm9tIGJlZm9yZSBtdXRhdGlvbiBwaGFzZSBieSByZS1sYW5kaW5nIFZpc2liaWxpdHlcbi8vIGZsYWcgbG9naWMgKHNlZSAjMjAwNDMpXG5VcGRhdGUgfCBTbmFwc2hvdCB8ICggMCk7XG52YXIgTXV0YXRpb25NYXNrID0gUGxhY2VtZW50IHwgVXBkYXRlIHwgQ2hpbGREZWxldGlvbiB8IENvbnRlbnRSZXNldCB8IFJlZiB8IEh5ZHJhdGluZyB8IFZpc2liaWxpdHk7XG52YXIgTGF5b3V0TWFzayA9IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgVmlzaWJpbGl0eTsgLy8gVE9ETzogU3BsaXQgaW50byBQYXNzaXZlTW91bnRNYXNrIGFuZCBQYXNzaXZlVW5tb3VudE1hc2tcblxudmFyIFBhc3NpdmVNYXNrID0gUGFzc2l2ZSB8IENoaWxkRGVsZXRpb247IC8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuLy8gVGhpcyBhbGxvd3MgY2VydGFpbiBjb25jZXB0cyB0byBwZXJzaXN0IHdpdGhvdXQgcmVjYWxjdWxhdGluZyB0aGVtLFxuLy8gZS5nLiB3aGV0aGVyIGEgc3VidHJlZSBjb250YWlucyBwYXNzaXZlIGVmZmVjdHMgb3IgcG9ydGFscy5cblxudmFyIFN0YXRpY01hc2sgPSBMYXlvdXRTdGF0aWMgfCBQYXNzaXZlU3RhdGljIHwgUmVmU3RhdGljO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcblxuICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICBpZiAocGFyZW50QiA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4gICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuICAgICAgLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgIGlmIChuZXh0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGEgPSBiID0gbmV4dFBhcmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSdyZSBhdCB0aGUgcm9vdC5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cblxuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH0gLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyAnICsgJ2luIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIiArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoYS50YWcgIT09IEhvc3RSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH1cblxuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuXG5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGN1cnJlbnRQYXJlbnQpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICByZXR1cm4gY3VycmVudFBhcmVudCAhPT0gbnVsbCA/IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoY2hpbGQudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKGNoaWxkKTtcblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBUaGlzIGlzIGEgaG9zdCBjb25maWcgdGhhdCdzIHVzZWQgZm9yIHRoZSBgcmVhY3QtcmVjb25jaWxlcmAgcGFja2FnZSBvbiBucG0uXG4vLyBJdCBpcyBvbmx5IHVzZWQgYnkgdGhpcmQtcGFydHkgcmVuZGVyZXJzLlxuLy9cbi8vIEl0cyBBUEkgbGV0cyB5b3UgcGFzcyB0aGUgaG9zdCBjb25maWcgYXMgYW4gYXJndW1lbnQuXG4vLyBIb3dldmVyLCBpbnNpZGUgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCB3ZSB0cmVhdCBob3N0IGNvbmZpZyBhcyBhIG1vZHVsZS5cbi8vIFRoaXMgZmlsZSBpcyBhIHNoaW0gYmV0d2VlbiB0d28gd29ybGRzLlxuLy9cbi8vIEl0IHdvcmtzIGJlY2F1c2UgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCBidW5kbGUgaXMgd3JhcHBlZCBpbiBzb21ldGhpbmcgbGlrZTpcbi8vXG4vLyBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkJCRjb25maWcpIHtcbi8vICAgLyogcmVjb25jaWxlciBjb2RlICovXG4vLyB9XG4vL1xuLy8gU28gYCQkJGNvbmZpZ2AgbG9va3MgbGlrZSBhIGdsb2JhbCB2YXJpYWJsZSwgYnV0IGl0J3Ncbi8vIHJlYWxseSBhbiBhcmd1bWVudCB0byBhIHRvcC1sZXZlbCB3cmFwcGluZyBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbnZhciBnZXRQdWJsaWNJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZ2V0UHVibGljSW5zdGFuY2U7XG52YXIgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkaG9zdENvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG52YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGhvc3RDb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dDtcbnZhciBwcmVwYXJlRm9yQ29tbWl0ID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlRm9yQ29tbWl0O1xudmFyIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRob3N0Q29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNyZWF0ZUluc3RhbmNlO1xudmFyIGFwcGVuZEluaXRpYWxDaGlsZCA9ICQkJGhvc3RDb25maWcuYXBwZW5kSW5pdGlhbENoaWxkO1xudmFyIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkaG9zdENvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbjtcbnZhciBwcmVwYXJlVXBkYXRlID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlVXBkYXRlO1xudmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gJCQkaG9zdENvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudDtcbnZhciBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZTtcbnZhciBzY2hlZHVsZVRpbWVvdXQgPSAkJCRob3N0Q29uZmlnLnNjaGVkdWxlVGltZW91dDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gJCQkaG9zdENvbmZpZy5jYW5jZWxUaW1lb3V0O1xudmFyIG5vVGltZW91dCA9ICQkJGhvc3RDb25maWcubm9UaW1lb3V0O1xudmFyIG5vdyA9ICQkJGhvc3RDb25maWcubm93O1xudmFyIGlzUHJpbWFyeVJlbmRlcmVyID0gJCQkaG9zdENvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbnZhciB3YXJuc0lmTm90QWN0aW5nID0gJCQkaG9zdENvbmZpZy53YXJuc0lmTm90QWN0aW5nO1xudmFyIHN1cHBvcnRzTXV0YXRpb24gPSAkJCRob3N0Q29uZmlnLnN1cHBvcnRzTXV0YXRpb247XG52YXIgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGhvc3RDb25maWcuc3VwcG9ydHNQZXJzaXN0ZW5jZTtcbnZhciBzdXBwb3J0c0h5ZHJhdGlvbiA9ICQkJGhvc3RDb25maWcuc3VwcG9ydHNIeWRyYXRpb247XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9ICQkJGhvc3RDb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbnZhciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIgPSAkJCRob3N0Q29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbnZhciBhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICQkJGhvc3RDb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG52YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG52YXIgcHJlcGFyZVNjb3BlVXBkYXRlID0gJCQkaG9zdENvbmZpZy5wcmVwYXJlUG9ydGFsTW91bnQ7XG52YXIgZ2V0SW5zdGFuY2VGcm9tU2NvcGUgPSAkJCRob3N0Q29uZmlnLmdldEluc3RhbmNlRnJvbVNjb3BlO1xudmFyIGdldEN1cnJlbnRFdmVudFByaW9yaXR5ID0gJCQkaG9zdENvbmZpZy5nZXRDdXJyZW50RXZlbnRQcmlvcml0eTtcbnZhciBkZXRhY2hEZWxldGVkSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRldGFjaERlbGV0ZWRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgICBNaWNyb3Rhc2tzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNNaWNyb3Rhc2tzID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c01pY3JvdGFza3M7XG52YXIgc2NoZWR1bGVNaWNyb3Rhc2sgPSAkJCRob3N0Q29uZmlnLnNjaGVkdWxlTWljcm90YXNrOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgIFRlc3Qgc2VsZWN0b3JzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNUZXN0U2VsZWN0b3JzID0gJCQkaG9zdENvbmZpZy5zdXBwb3J0c1Rlc3RTZWxlY3RvcnM7XG52YXIgZmluZEZpYmVyUm9vdCA9ICQkJGhvc3RDb25maWcuZmluZEZpYmVyUm9vdDtcbnZhciBnZXRCb3VuZGluZ1JlY3QgPSAkJCRob3N0Q29uZmlnLmdldEJvdW5kaW5nUmVjdDtcbnZhciBnZXRUZXh0Q29udGVudCA9ICQkJGhvc3RDb25maWcuZ2V0VGV4dENvbnRlbnQ7XG52YXIgaXNIaWRkZW5TdWJ0cmVlID0gJCQkaG9zdENvbmZpZy5pc0hpZGRlblN1YnRyZWU7XG52YXIgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSA9ICQkJGhvc3RDb25maWcubWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZTtcbnZhciBzZXRGb2N1c0lmRm9jdXNhYmxlID0gJCQkaG9zdENvbmZpZy5zZXRGb2N1c0lmRm9jdXNhYmxlO1xudmFyIHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAkJCRob3N0Q29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgTXV0YXRpb25cbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBhcHBlbmRDaGlsZCA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGQ7XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjtcbnZhciBjb21taXRUZXh0VXBkYXRlID0gJCQkaG9zdENvbmZpZy5jb21taXRUZXh0VXBkYXRlO1xudmFyIGNvbW1pdE1vdW50ID0gJCQkaG9zdENvbmZpZy5jb21taXRNb3VudDtcbnZhciBjb21taXRVcGRhdGUgPSAkJCRob3N0Q29uZmlnLmNvbW1pdFVwZGF0ZTtcbnZhciBpbnNlcnRCZWZvcmUgPSAkJCRob3N0Q29uZmlnLmluc2VydEJlZm9yZTtcbnZhciBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGhvc3RDb25maWcuaW5zZXJ0SW5Db250YWluZXJCZWZvcmU7XG52YXIgcmVtb3ZlQ2hpbGQgPSAkJCRob3N0Q29uZmlnLnJlbW92ZUNoaWxkO1xudmFyIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xudmFyIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRob3N0Q29uZmlnLnJlc2V0VGV4dENvbnRlbnQ7XG52YXIgaGlkZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oaWRlSW5zdGFuY2U7XG52YXIgaGlkZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaGlkZVRleHRJbnN0YW5jZTtcbnZhciB1bmhpZGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcudW5oaWRlSW5zdGFuY2U7XG52YXIgdW5oaWRlVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2U7XG52YXIgY2xlYXJDb250YWluZXIgPSAkJCRob3N0Q29uZmlnLmNsZWFyQ29udGFpbmVyOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgUGVyc2lzdGVuY2Vcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjbG9uZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jbG9uZUluc3RhbmNlO1xudmFyIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gJCQkaG9zdENvbmZpZy5jcmVhdGVDb250YWluZXJDaGlsZFNldDtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRob3N0Q29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldDtcbnZhciBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkaG9zdENvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9ICQkJGhvc3RDb25maWcucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIGdldE9mZnNjcmVlbkNvbnRhaW5lclR5cGUgPSAkJCRob3N0Q29uZmlnLmdldE9mZnNjcmVlbkNvbnRhaW5lclR5cGU7XG52YXIgZ2V0T2Zmc2NyZWVuQ29udGFpbmVyUHJvcHMgPSAkJCRob3N0Q29uZmlnLmdldE9mZnNjcmVlbkNvbnRhaW5lclByb3BzO1xudmFyIGNsb25lSGlkZGVuSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2U7XG52YXIgY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgSHlkcmF0aW9uXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jYW5IeWRyYXRlSW5zdGFuY2U7XG52YXIgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZztcbnZhciBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayA9ICQkJGhvc3RDb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2s7XG52YXIgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRob3N0Q29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5O1xudmFyIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9ICQkJGhvc3RDb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nO1xudmFyIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gJCQkaG9zdENvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDtcbnZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXI7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5oeWRyYXRlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXI7XG52YXIgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5jb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2U7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5ID0gJCQkaG9zdENvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnk7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcjtcbnZhciBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyA9ICQkJGhvc3RDb25maWcuc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXM7XG52YXIgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTtcbnZhciBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlO1xudmFyIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyO1xudmFyIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RIeWRyYXRlSW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcjtcbnZhciBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluQ29udGFpbmVyID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXI7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRob3N0Q29uZmlnLmRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTtcbnZhciBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9ICQkJGhvc3RDb25maWcuZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlID0gJCQkaG9zdENvbmZpZy5kaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2U7XG52YXIgZXJyb3JIeWRyYXRpbmdDb250YWluZXIgPSAkJCRob3N0Q29uZmlnLmVycm9ySHlkcmF0aW5nQ29udGFpbmVyO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTsgLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cblxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpIHtcbiAge1xuICAgIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9IC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gICAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKSArIFwiLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXFxcIlwiICsgY29udGV4dEtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gICAgLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG4gICAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuXG4gICAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlDb250ZXh0T2JqZWN0OyAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gICAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG5cbiAgICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHR5cGUsIGRpZENoYW5nZSkge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7IC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG5cbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7IC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuXG4gICAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICAvLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbiAgICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgICBpZiAoIWlzRmliZXJNb3VudGVkKGZpYmVyKSB8fCBmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IG5vZGUudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbnZhciBMZWdhY3lSb290ID0gMDtcbnZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cbnZhciBOb01vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7IC8vIFRPRE86IFJlbW92ZSBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3QgdGFnIGluc3RlYWRcblxudmFyIENvbmN1cnJlbnRNb2RlID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBQcm9maWxlTW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgU3RyaWN0TGVnYWN5TW9kZSA9XG4vKiAgICAgICAgICAgICAgICovXG44O1xudmFyIFN0cmljdEVmZmVjdHNNb2RlID1cbi8qICAgICAgICAgICAgICAqL1xuMTY7XG5cbi8vIFRPRE86IFRoaXMgaXMgcHJldHR5IHdlbGwgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzLiBNYXliZSB3ZSBjYW4gZHJvcCBpdC5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG5cbmZ1bmN0aW9uIGNsejMyRmFsbGJhY2soeCkge1xuICB2YXIgYXNVaW50ID0geCA+Pj4gMDtcblxuICBpZiAoYXNVaW50ID09PSAwKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9XG5cbiAgcmV0dXJuIDMxIC0gKGxvZyhhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBJZiB0aG9zZSB2YWx1ZXMgYXJlIGNoYW5nZWQgdGhhdCBwYWNrYWdlIHNob3VsZCBiZSByZWJ1aWx0IGFuZCByZWRlcGxveWVkLlxuXG52YXIgVG90YWxMYW5lcyA9IDMxO1xudmFyIE5vTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBOb0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFN5bmNMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAqL1xuMjtcbnZhciBJbnB1dENvbnRpbnVvdXNMYW5lID1cbi8qICAgICAgICAgICAgKi9cbjQ7XG52YXIgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAqL1xuODtcbnZhciBEZWZhdWx0TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBUcmFuc2l0aW9uTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40MTk0MjQwO1xudmFyIFRyYW5zaXRpb25MYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG42NDtcbnZhciBUcmFuc2l0aW9uTGFuZTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFRyYW5zaXRpb25MYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgVHJhbnNpdGlvbkxhbmU0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBUcmFuc2l0aW9uTGFuZTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBUcmFuc2l0aW9uTGFuZTYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBUcmFuc2l0aW9uTGFuZTcgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBUcmFuc2l0aW9uTGFuZTggPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBUcmFuc2l0aW9uTGFuZTkgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTYzODQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxMCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFRyYW5zaXRpb25MYW5lMTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBUcmFuc2l0aW9uTGFuZTEyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTMxMDcyO1xudmFyIFRyYW5zaXRpb25MYW5lMTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yNjIxNDQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUyNDI4ODtcbnZhciBUcmFuc2l0aW9uTGFuZTE1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTE2ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzAwMjM0MjQ7XG52YXIgUmV0cnlMYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUmV0cnlMYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7XG52YXIgUmV0cnlMYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIFJldHJ5TGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBSZXRyeUxhbmU1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjcxMDg4NjQ7XG52YXIgU29tZVJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTU7XG52YXIgSWRsZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAqL1xuMjY4NDM1NDU2O1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xudmFyIE9mZnNjcmVlbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEwNzM3NDE4MjQ7IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgdGhlIGV4cGVyaW1lbnRhbCB0aW1lbGluZSAocmVhY3QtZGV2dG9vbHMtdGltZWxpbmUpXG4vLyBJdCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIExhbmVzIHZhbHVlcyBhYm92ZS5cblxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpIHtcbiAge1xuICAgIGlmIChsYW5lICYgU3luY0xhbmUpIHtcbiAgICAgIHJldHVybiAnU3luYyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91cyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0SHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0SHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmF1bHRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmF1bHQnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbkh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBSZXRyeUxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1JldHJ5JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnU2VsZWN0aXZlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGVIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSWRsZUxhbmUpIHtcbiAgICAgIHJldHVybiAnSWRsZSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG4gICAgfVxuICB9XG59XG52YXIgTm9UaW1lc3RhbXAgPSAtMTtcbnZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG52YXIgbmV4dFJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHN3aXRjaCAoZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykpIHtcbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgcmV0dXJuIFN5bmNMYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRMYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcbiAgICAgIHJldHVybiBsYW5lcyAmIFRyYW5zaXRpb25MYW5lcztcblxuICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICBjYXNlIFJldHJ5TGFuZTU6XG4gICAgICByZXR1cm4gbGFuZXMgJiBSZXRyeUxhbmVzO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElkbGVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIHJldHVybiBJZGxlTGFuZTtcblxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybiBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIG5leHRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIERvIG5vdCB3b3JrIG9uIGFueSBpZGxlIHdvcmsgdW50aWwgYWxsIHRoZSBub24taWRsZSB3b3JrIGhhcyBmaW5pc2hlZCxcbiAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG5cbiAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbm9uSWRsZVVuYmxvY2tlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlUGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICBpZiAodW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbmV4dExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG4gICAgdmFyIHdpcExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtcblxuICAgIGlmICggLy8gVGVzdHMgd2hldGhlciB0aGUgbmV4dCBsYW5lIGlzIGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5IHRoYW4gdGhlIHdpcFxuICAgIC8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICAgIG5leHRMYW5lID49IHdpcExhbmUgfHwgLy8gRGVmYXVsdCBwcmlvcml0eSB1cGRhdGVzIHNob3VsZCBub3QgaW50ZXJydXB0IHRyYW5zaXRpb24gdXBkYXRlcy4gVGhlXG4gICAgLy8gb25seSBkaWZmZXJlbmNlIGJldHdlZW4gZGVmYXVsdCB1cGRhdGVzIGFuZCB0cmFuc2l0aW9uIHVwZGF0ZXMgaXMgdGhhdFxuICAgIC8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxuICAgIG5leHRMYW5lID09PSBEZWZhdWx0TGFuZSAmJiAod2lwTGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgIC8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbiAgICAgIHJldHVybiB3aXBMYW5lcztcbiAgICB9XG4gIH1cblxuICBpZiAoKG5leHRMYW5lcyAmIElucHV0Q29udGludW91c0xhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gV2hlbiB1cGRhdGVzIGFyZSBzeW5jIGJ5IGRlZmF1bHQsIHdlIGVudGFuZ2xlIGNvbnRpbnVvdXMgcHJpb3JpdHkgdXBkYXRlc1xuICAgIC8vIGFuZCBkZWZhdWx0IHVwZGF0ZXMsIHNvIHRoZXkgcmVuZGVyIGluIHRoZSBzYW1lIGJhdGNoLiBUaGUgb25seSByZWFzb25cbiAgICAvLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4gICAgLy8gdHJhbnNpdGlvbnMsIGJ1dCBkZWZhdWx0IHVwZGF0ZXMgc2hvdWxkIG5vdC5cbiAgICBuZXh0TGFuZXMgfD0gcGVuZGluZ0xhbmVzICYgRGVmYXVsdExhbmU7XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy4gVGhlIGNvdW50ZXItYXJndW1lbnQgaXMgdGhhdCB0aGUgcGFydGlhbCB3b3JrXG4gIC8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4gIC8vIHRpbWUgaXQgdGFrZXMgdG8gc2hvdyB0aGUgZmluYWwgc3RhdGUsIHdoaWNoIGlzIHdoYXQgdGhleSBhcmUgYWN0dWFsbHlcbiAgLy8gd2FpdGluZyBmb3IuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LCBsaWtlXG4gIC8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gbmV4dExhbmVzICYgZW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIG5leHRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV2ZW50VGltZSA9IGV2ZW50VGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcbiAgICAgIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBldmVudFRpbWU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICByZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIHN3aXRjaCAobGFuZSkge1xuICAgIGNhc2UgU3luY0xhbmU6XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgc2V0IHRvIHRoZSBjb3JyZXNwb25kaW5nIGNvbnN0YW50IGFzIGluIFNjaGVkdWxlci5qcy5cbiAgICAgIC8vIFdoZW4gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZ1xuICAgICAgLy8gdGhlcmUncyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2ZcbiAgICAgIC8vIHN5bmNocm9ub3VzIHVwZGF0ZXMuIElmIHRoYXQgdGhlb3J5IGlzIGNvcnJlY3QsIHRoZSBwcm9wZXIgc29sdXRpb24gaXNcbiAgICAgIC8vIHRvIGZpeCB0aGUgc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0XG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvblxuICAgICAgLy8gZG9lcyBoYXBwZW4uXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIC8vIFRPRE86IFJldHJpZXMgc2hvdWxkIGJlIGFsbG93ZWQgdG8gZXhwaXJlIGlmIHRoZXkgYXJlIENQVSBib3VuZCBmb3JcbiAgICAgIC8vIHRvbyBsb25nLCBidXQgd2hlbiBJIG1hZGUgdGhpcyBjaGFuZ2UgaXQgY2F1c2VkIGEgc3Bpa2UgaW4gYnJvd3NlclxuICAgICAgLy8gY3Jhc2hlcy4gVGhlcmUgbXVzdCBiZSBzb21lIG90aGVyIHVuZGVybHlpbmcgYnVnOyBub3Qgc3VwZXIgdXJnZW50IGJ1dFxuICAgICAgLy8gaWRlYWxseSBzaG91bGQgZmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gVW5mb3J0dW5hdGVseSB3ZSBkb24ndCBoYXZlXG4gICAgICAvLyBhIHJlcHJvIGZvciB0aGUgY3Jhc2hlcywgb25seSBkZXRlY3RlZCB2aWEgcHJvZHVjdGlvbiBtZXRyaWNzLlxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgICAvLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpIHtcbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3QucGVuZGluZ0xhbmVzKTtcbn1cbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNTeW5jTGFuZShsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgU3luY0xhbmUpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSB7XG5cbiAgdmFyIFN5bmNEZWZhdWx0TGFuZXMgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRIeWRyYXRpb25MYW5lIHwgRGVmYXVsdExhbmU7XG4gIHJldHVybiAobGFuZXMgJiBTeW5jRGVmYXVsdExhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCwgbGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG4gIC8vIGV4cGlyZSBhZnRlciBhIHJlbmRlciBoYXMgYWxyZWFkeSBzdGFydGVkLlxuICByZXR1cm4gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uTGFuZShsYW5lKSB7XG4gIHJldHVybiAobGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IDA7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgLy8gQ3ljbGUgdGhyb3VnaCB0aGUgbGFuZXMsIGFzc2lnbmluZyBlYWNoIG5ldyB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IGxhbmUuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgbWVhbnMgZXZlcnkgdHJhbnNpdGlvbiBnZXRzIGl0cyBvd24gbGFuZSwgdW50aWwgd2VcbiAgLy8gcnVuIG91dCBvZiBsYW5lcyBhbmQgY3ljbGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLlxuICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuXG4gIGlmICgobmV4dFRyYW5zaXRpb25MYW5lICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gMCkge1xuICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IFRyYW5zaXRpb25MYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gIG5leHRSZXRyeUxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0UmV0cnlMYW5lICYgUmV0cnlMYW5lcykgPT09IDApIHtcbiAgICBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykge1xuICByZXR1cm4gbGFuZXMgJiAtbGFuZXM7XG59XG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdExhbmVzKGEsIGIpIHtcbiAgcmV0dXJuIGEgJiBiO1xufSAvLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKSB7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsIGIpIHtcbiAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2Jsb2cvZWxlbWVudHMta2luZHMjYXZvaWQtY3JlYXRpbmctaG9sZXNcbiAgdmFyIGxhbmVNYXAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuICAgIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHVwZGF0ZUxhbmUsIGV2ZW50VGltZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBJZiB0aGVyZSBhcmUgYW55IHN1c3BlbmRlZCB0cmFuc2l0aW9ucywgaXQncyBwb3NzaWJsZSB0aGlzIG5ldyB1cGRhdGVcbiAgLy8gY291bGQgdW5ibG9jayB0aGVtLiBDbGVhciB0aGUgc3VzcGVuZGVkIGxhbmVzIHNvIHRoYXQgd2UgY2FuIHRyeSByZW5kZXJpbmdcbiAgLy8gdGhlbSBhZ2Fpbi5cbiAgLy9cbiAgLy8gVE9ETzogV2UgcmVhbGx5IG9ubHkgbmVlZCB0byB1bnN1c3BlbmQgb25seSBsYW5lcyB0aGF0IGFyZSBpbiB0aGVcbiAgLy8gYHN1YnRyZWVMYW5lc2Agb2YgdGhlIHVwZGF0ZWQgZmliZXIsIG9yIHRoZSB1cGRhdGUgbGFuZXMgb2YgdGhlIHJldHVyblxuICAvLyBwYXRoLiBUaGlzIHdvdWxkIGV4Y2x1ZGUgc3VzcGVuZGVkIHVwZGF0ZXMgaW4gYW4gdW5yZWxhdGVkIHNpYmxpbmcgdHJlZSxcbiAgLy8gc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIHRoaXMgdXBkYXRlIHRvIHVuYmxvY2sgaXQuXG4gIC8vXG4gIC8vIFdlIGRvbid0IGRvIHRoaXMgaWYgdGhlIGluY29taW5nIHVwZGF0ZSBpcyBpZGxlLCBiZWNhdXNlIHdlIG5ldmVyIHByb2Nlc3NcbiAgLy8gaWRsZSB1cGRhdGVzIHVudGlsIGFmdGVyIGFsbCB0aGUgcmVndWxhciB1cGRhdGVzIGhhdmUgZmluaXNoZWQ7IHRoZXJlJ3Mgbm9cbiAgLy8gd2F5IGl0IGNvdWxkIHVuYmxvY2sgYSB0cmFuc2l0aW9uLlxuXG4gIGlmICh1cGRhdGVMYW5lICE9PSBJZGxlTGFuZSkge1xuICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHJvb3QucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOyAvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3RcbiAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG4gIGV2ZW50VGltZXNbaW5kZXhdID0gZXZlbnRUaW1lO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgdmFyIG5vTG9uZ2VyUGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5cbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5tdXRhYmxlUmVhZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gQ2xlYXIgdGhlIGxhbmVzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgcGVuZGluZyB3b3JrXG5cbiAgdmFyIGxhbmVzID0gbm9Mb25nZXJQZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IE5vTGFuZXM7XG4gICAgZXZlbnRUaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gIC8vIEluIGFkZGl0aW9uIHRvIGVudGFuZ2xpbmcgZWFjaCBvZiB0aGUgZ2l2ZW4gbGFuZXMgd2l0aCBlYWNoIG90aGVyLCB3ZSBhbHNvXG4gIC8vIGhhdmUgdG8gY29uc2lkZXIgX3RyYW5zaXRpdmVfIGVudGFuZ2xlbWVudHMuIEZvciBlYWNoIGxhbmUgdGhhdCBpcyBhbHJlYWR5XG4gIC8vIGVudGFuZ2xlZCB3aXRoICphbnkqIG9mIHRoZSBnaXZlbiBsYW5lcywgdGhhdCBsYW5lIGlzIG5vdyB0cmFuc2l0aXZlbHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFsbCogdGhlIGdpdmVuIGxhbmVzLlxuICAvL1xuICAvLyBUcmFuc2xhdGVkOiBJZiBDIGlzIGVudGFuZ2xlZCB3aXRoIEEsIHRoZW4gZW50YW5nbGluZyBBIHdpdGggQiBhbHNvXG4gIC8vIGVudGFuZ2xlcyBDIHdpdGggQi5cbiAgLy9cbiAgLy8gSWYgdGhpcyBpcyBoYXJkIHRvIGdyYXNwLCBpdCBtaWdodCBoZWxwIHRvIGludGVudGlvbmFsbHkgYnJlYWsgdGhpc1xuICAvLyBmdW5jdGlvbiBhbmQgbG9vayBhdCB0aGUgdGVzdHMgdGhhdCBmYWlsIGluIFJlYWN0VHJhbnNpdGlvbi10ZXN0LmpzLiBUcnlcbiAgLy8gY29tbWVudGluZyBvdXQgb25lIG9mIHRoZSBjb25kaXRpb25zIGJlbG93LlxuICB2YXIgcm9vdEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBlbnRhbmdsZWRMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBsYW5lcyA9IHJvb3RFbnRhbmdsZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMpIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG5cbiAgICBpZiAoIC8vIElzIHRoaXMgb25lIG9mIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgbGFuZSAmIGVudGFuZ2xlZExhbmVzIHwgLy8gSXMgdGhpcyBsYW5lIHRyYW5zaXRpdmVseSBlbnRhbmdsZWQgd2l0aCB0aGUgbmV3bHkgZW50YW5nbGVkIGxhbmVzP1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdICYgZW50YW5nbGVkTGFuZXMpIHtcbiAgICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gIHZhciByZW5kZXJMYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShyZW5kZXJMYW5lcyk7XG4gIHZhciBsYW5lO1xuXG4gIHN3aXRjaCAocmVuZGVyTGFuZSkge1xuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIGxhbmUgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgbGFuZSA9IERlZmF1bHRIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIGxhbmUgPSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIGxhbmUgPSBJZGxlSHlkcmF0aW9uTGFuZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBhbHJlYWR5IGVpdGhlciBhIGh5ZHJhdGlvbiBsYW5lLCBvciBzaG91bGRuJ3RcbiAgICAgIC8vIGJlIHJldHJpZWQgYXQgYSBoeWRyYXRpb24gbGFuZS5cbiAgICAgIGxhbmUgPSBOb0xhbmU7XG4gICAgICBicmVhaztcbiAgfSAvLyBDaGVjayBpZiB0aGUgbGFuZSB3ZSBjaG9zZSBpcyBzdXNwZW5kZWQuIElmIHNvLCB0aGF0IGluZGljYXRlcyB0aGF0IHdlXG4gIC8vIGFscmVhZHkgYXR0ZW1wdGVkIGFuZCBmYWlsZWQgdG8gaHlkcmF0ZSBhdCB0aGF0IGxldmVsLiBBbHNvIGNoZWNrIGlmIHdlJ3JlXG4gIC8vIGFscmVhZHkgcmVuZGVyaW5nIHRoYXQgbGFuZSwgd2hpY2ggaXMgcmFyZSBidXQgY291bGQgaGFwcGVuLlxuXG5cbiAgaWYgKChsYW5lICYgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpICE9PSBOb0xhbmUpIHtcbiAgICAvLyBHaXZlIHVwIHRyeWluZyB0byBoeWRyYXRlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlci5cbiAgICByZXR1cm4gTm9MYW5lO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgIHVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcykge1xuXG4gIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcbiAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG5cbiAgICBpZiAodXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgIHVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCAhbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVycy5jbGVhcigpO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBTeW5jTGFuZTtcbnZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG52YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcbnZhciBJZGxlRXZlbnRQcmlvcml0eSA9IElkbGVMYW5lO1xudmFyIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IE5vTGFuZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG5cbiAgdHJ5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmV2aW91c1ByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IDAgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGxvd2VyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSAwIHx8IGEgPiBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYjtcbn1cbmZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gIHZhciBsYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LCBsYW5lKSkge1xuICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShDb250aW51b3VzRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoaW5jbHVkZXNOb25JZGxlV29yayhsYW5lKSkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBJZGxlRXZlbnRQcmlvcml0eTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgb25seSBleGlzdHMgYXMgYW4gRVNNIHdyYXBwZXIgYXJvdW5kIHRoZSBleHRlcm5hbCBDb21tb25KU1xudmFyIHNjaGVkdWxlQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbnZhciBjYW5jZWxDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjaztcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50O1xudmFyIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTtcbnZhciBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eTtcbnZhciBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG52YXIgdW5zdGFibGVfeWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlO1xudmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcikge1xuICAgICAgLy8gQ29uZGl0aW9uYWxseSBpbmplY3QgdGhlc2UgaG9va3Mgb25seSBpZiBUaW1lbGluZSBwcm9maWxlciBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBidWlsZC5cbiAgICAgIC8vIFRoaXMgZ2l2ZXMgRGV2VG9vbHMgYSB3YXkgdG8gZmVhdHVyZSBkZXRlY3QgdGhhdCBpc24ndCB0aWVkIHRvIHZlcnNpb24gbnVtYmVyXG4gICAgICAvLyAoc2luY2UgcHJvZmlsaW5nIGFuZCB0aW1lbGluZSBhcmUgY29udHJvbGxlZCBieSBkaWZmZXJlbnQgZmVhdHVyZSBmbGFncykuXG4gICAgICBpbnRlcm5hbHMgPSBhc3NpZ24oe30sIGludGVybmFscywge1xuICAgICAgICBnZXRMYW5lTGFiZWxNYXA6IGdldExhbmVMYWJlbE1hcCxcbiAgICAgICAgaW5qZWN0UHJvZmlsaW5nSG9va3M6IGluamVjdFByb2ZpbGluZ0hvb2tzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhvb2suY2hlY2tEQ0UpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFsIERldlRvb2xzLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5O1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgc2NoZWR1bGVyUHJpb3JpdHksIGRpZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCB1bmRlZmluZWQsIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgdW5zdGFibGVfeWllbGRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UncmUgaW4gYSB0ZXN0IGJlY2F1c2UgU2NoZWR1bGVyLnVuc3RhYmxlX3lpZWxkVmFsdWUgb25seSBleGlzdHNcbiAgICAgIC8vIGluIFNjaGVkdWxlck1vY2suIFRvIHJlZHVjZSB0aGUgbm9pc2UgaW4gc3RyaWN0IG1vZGUgdGVzdHMsXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBhbmQgZGlzYWJsZSBzY2hlZHVsZXIgeWllbGRpbmcgZHVyaW5nIHRoZSBkb3VibGUgcmVuZGVyXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgc2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBQcm9maWxlciBBUEkgaG9va3NcblxuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xufVxuXG5mdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciBsYW5lID0gMTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBUb3RhbExhbmVzOyBpbmRleCsrKSB7XG4gICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgIGxhbmUgKj0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgc3luY1F1ZXVlID0gbnVsbDtcbnZhciBpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MgPSBmYWxzZTtcbnZhciBpc0ZsdXNoaW5nU3luY1F1ZXVlID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjaykge1xuICAvLyBQdXNoIHRoaXMgY2FsbGJhY2sgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gV2UnbGwgZmx1c2ggdGhlc2UgZWl0aGVyIGluXG4gIC8vIHRoZSBuZXh0IHRpY2ssIG9yIGVhcmxpZXIgaWYgc29tZXRoaW5nIGNhbGxzIGBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlYC5cbiAgaWYgKHN5bmNRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHN5bmNRdWV1ZSA9IFtjYWxsYmFja107XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgc2NoZWR1bGVTeW5jQ2FsbGJhY2soY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpIHtcbiAgLy8gT25seSBmbHVzaGVzIHRoZSBxdWV1ZSBpZiB0aGVyZSdzIGEgbGVnYWN5IHN5bmMgY2FsbGJhY2sgc2NoZWR1bGVkLlxuICAvLyBUT0RPOiBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgdHlwZSBvZiBjYWxsYmFjazogcGVyZm9ybVN5bmNPbldvcmtPblJvb3QuIFNvXG4gIC8vIGl0IG1pZ2h0IG1ha2UgbW9yZSBzZW5zZSBmb3IgdGhlIHF1ZXVlIHRvIGJlIGEgbGlzdCBvZiByb290cyBpbnN0ZWFkIG9mIGFcbiAgLy8gbGlzdCBvZiBnZW5lcmljIGNhbGxiYWNrcy4gVGhlbiB3ZSBjYW4gaGF2ZSB0d286IG9uZSBmb3IgbGVnYWN5IHJvb3RzLCBvbmVcbiAgLy8gZm9yIGNvbmN1cnJlbnQgcm9vdHMuIEFuZCB0aGlzIG1ldGhvZCB3b3VsZCBvbmx5IGZsdXNoIHRoZSBsZWdhY3kgb25lcy5cbiAgaWYgKGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcykge1xuICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3MoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmNlLlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc1N5bmMgPSB0cnVlO1xuICAgICAgdmFyIHF1ZXVlID0gc3luY1F1ZXVlOyAvLyBUT0RPOiBJcyB0aGlzIG5lY2Vzc2FyeSBhbnltb3JlPyBUaGUgb25seSB1c2VyIGNvZGUgdGhhdCBydW5zIGluIHRoaXNcbiAgICAgIC8vIHF1ZXVlIGlzIGluIHRoZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlcy5cblxuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG5cbiAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaXNTeW5jKTtcbiAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBzeW5jUXVldWUgPSBudWxsO1xuICAgICAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cbiAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgc3luY1F1ZXVlID0gc3luY1F1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgIH0gLy8gUmVzdW1lIGZsdXNoaW5nIGluIHRoZSBuZXh0IHRpY2tcblxuXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja3MpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZVByaW9yaXR5KTtcbiAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVGhpcyBpcyBpbXBvcnRlZCBieSB0aGUgZXZlbnQgcmVwbGF5aW5nIGltcGxlbWVudGF0aW9uIGluIFJlYWN0IERPTS4gSXQnc1xuLy8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gaXNSb290RGVoeWRyYXRlZChyb290KSB7XG4gIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIE5vVHJhbnNpdGlvbiA9IG51bGw7XG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtpXTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fCAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICB2YXIgb3duZXIgPSAgZmliZXIuX2RlYnVnT3duZXIgPyBmaWJlci5fZGVidWdPd25lci50eXBlIDogbnVsbCA7XG4gIHZhciBzb3VyY2UgPSAgZmliZXIuX2RlYnVnU291cmNlIDtcblxuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBjdXJyZW50ID0gbnVsbDtcbnZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG93bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cblxuXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgIGN1cnJlbnQgPSBudWxsO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXBlIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG4gICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9IC8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3NcbiAgICAvLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcblxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIHNvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIFwiICsgJ3JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMik7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbE1vdW50IHRvIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczMpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM0ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiICsgJ2NvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM0KTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNSA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxVcGRhdGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFVwZGF0ZSB0byBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG5cbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuXG5cbiAgICBpZiAoZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZ3NGb3JSb290ID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KTtcblxuICAgIGlmIChmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsIHx8IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAod2FybmluZ3NGb3JSb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290ID0gW107XG4gICAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgd2FybmluZ3NGb3JSb290KTtcbiAgICAgIH1cblxuICAgICAgd2FybmluZ3NGb3JSb290LnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlckFycmF5LCBzdHJpY3RSb290KSB7XG4gICAgICBpZiAoZmliZXJBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RGaWJlciA9IGZpYmVyQXJyYXlbMF07XG4gICAgICB2YXIgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtcblxuICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGJhc2VQcm9wcyk7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xudmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbmZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG5cbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcCh2YWx1ZUN1cnNvciwgcHJvdmlkZXJGaWJlcik7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgLy8gVXBkYXRlIHRoZSBjaGlsZCBsYW5lcyBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nIHRoZSBhbHRlcm5hdGVzLlxuICB2YXIgbm9kZSA9IHBhcmVudDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcblxuICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBub2RlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmICFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChub2RlICE9PSBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcblxuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG4gICAgICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTsgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgLy8gSW5saW5lZCBgZW5xdWV1ZVVwZGF0ZWAgdG8gcmVtb3ZlIGludGVybGVhdmVkIHVwZGF0ZSBjaGVja1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICAgICAgICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAoIGZpYmVyLnRhZyA9PT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG4gICAgICAvLyBpZiBpdCB3aWxsIGhhdmUgYW55IGNvbnRleHQgY29uc3VtZXJzIGluIGl0LiBUaGUgYmVzdCB3ZSBjYW4gZG8gaXNcbiAgICAgIC8vIG1hcmsgaXQgYXMgaGF2aW5nIHVwZGF0ZXMuXG4gICAgICB2YXIgcGFyZW50U3VzcGVuc2UgPSBmaWJlci5yZXR1cm47XG5cbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudFN1c3BlbnNlLmxhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnRTdXNwZW5zZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIF9hbHRlcm5hdGUgPSBwYXJlbnRTdXNwZW5zZS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIF9hbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKF9hbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHBhc3NpbmcgdGhpcyBmaWJlciBhcyB0aGUgcGFyZW50XG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gc2NoZWR1bGUgdGhpcyBmaWJlciBhcyBoYXZpbmcgd29ya1xuICAgICAgLy8gb24gaXRzIGNoaWxkcmVuLiBXZSdsbCB1c2UgdGhlIGNoaWxkTGFuZXMgb25cbiAgICAgIC8vIHRoaXMgZmliZXIgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cblxuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnRTdXNwZW5zZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuXG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHZhciBmaXJzdENvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuXG4gICAgICBpZiAoZmlyc3RDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICAgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICAgIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXIgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuXG4gIGlmIChsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPT09IGNvbnRleHQpIDsgZWxzZSB7XG4gICAgdmFyIGNvbnRleHRJdGVtID0ge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG1lbW9pemVkVmFsdWU6IHZhbHVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBBbiBhcnJheSBvZiBhbGwgdXBkYXRlIHF1ZXVlcyB0aGF0IHJlY2VpdmVkIHVwZGF0ZXMgZHVyaW5nIHRoZSBjdXJyZW50XG4vLyByZW5kZXIuIFdoZW4gdGhpcyByZW5kZXIgZXhpdHMsIGVpdGhlciBiZWNhdXNlIGl0IGZpbmlzaGVzIG9yIGJlY2F1c2UgaXQgaXNcbi8vIGludGVycnVwdGVkLCB0aGUgaW50ZXJsZWF2ZWQgdXBkYXRlcyB3aWxsIGJlIHRyYW5zZmVycmVkIG9udG8gdGhlIG1haW4gcGFydFxuLy8gb2YgdGhlIHF1ZXVlLlxudmFyIGludGVybGVhdmVkUXVldWVzID0gbnVsbDtcbmZ1bmN0aW9uIHB1c2hJbnRlcmxlYXZlZFF1ZXVlKHF1ZXVlKSB7XG4gIGlmIChpbnRlcmxlYXZlZFF1ZXVlcyA9PT0gbnVsbCkge1xuICAgIGludGVybGVhdmVkUXVldWVzID0gW3F1ZXVlXTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcmxlYXZlZFF1ZXVlcy5wdXNoKHF1ZXVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpIHtcbiAgLy8gVHJhbnNmZXIgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgb250byB0aGUgbWFpbiBxdWV1ZS4gRWFjaCBxdWV1ZSBoYXMgYVxuICAvLyBgcGVuZGluZ2AgZmllbGQgYW5kIGFuIGBpbnRlcmxlYXZlZGAgZmllbGQuIFdoZW4gdGhleSBhcmUgbm90IG51bGwsIHRoZXlcbiAgLy8gcG9pbnQgdG8gdGhlIGxhc3Qgbm9kZSBpbiBhIGNpcmN1bGFyIGxpbmtlZCBsaXN0LiBXZSBuZWVkIHRvIGFwcGVuZCB0aGVcbiAgLy8gaW50ZXJsZWF2ZWQgbGlzdCB0byB0aGUgZW5kIG9mIHRoZSBwZW5kaW5nIGxpc3QgYnkgam9pbmluZyB0aGVtIGludG8gYVxuICAvLyBzaW5nbGUsIGNpcmN1bGFyIGxpc3QuXG4gIGlmIChpbnRlcmxlYXZlZFF1ZXVlcyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJsZWF2ZWRRdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZSA9IGludGVybGVhdmVkUXVldWVzW2ldO1xuICAgICAgdmFyIGxhc3RJbnRlcmxlYXZlZFVwZGF0ZSA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgICBpZiAobGFzdEludGVybGVhdmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmludGVybGVhdmVkID0gbnVsbDtcbiAgICAgICAgdmFyIGZpcnN0SW50ZXJsZWF2ZWRVcGRhdGUgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dDtcbiAgICAgICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcXVldWUucGVuZGluZztcblxuICAgICAgICBpZiAobGFzdFBlbmRpbmdVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gZmlyc3RJbnRlcmxlYXZlZFVwZGF0ZTtcbiAgICAgICAgICBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZXJsZWF2ZWRRdWV1ZXMgPSBudWxsO1xuICB9XG59XG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7IC8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuXG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDoge1xuICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgICAgbGFuZXM6IE5vTGFuZXNcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIGlmIChpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyKSkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHNoYXJlZFF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgICBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShzaGFyZWRRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgc2hhcmVkUXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBlbmRpbmcgPSBzaGFyZWRRdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB9XG5cbiAge1xuICAgIGlmIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHNoYXJlZFF1ZXVlICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICBlcnJvcignQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuXG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG5cbiAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IHNoYXJlZFF1ZXVlLmxhbmVzOyAvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5IG11c3RcbiAgICAvLyBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4gICAgLy8gYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZSBtYXkgZW50YW5nbGVcbiAgICAvLyBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmIHdlICpkb24ndCpcbiAgICAvLyBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cbiAgICB2YXIgbmV3UXVldWVMYW5lcyA9IG1lcmdlTGFuZXMocXVldWVMYW5lcywgbGFuZSk7XG4gICAgc2hhcmVkUXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4gICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbiAgICAvLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxuXG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY2FwdHVyZWRVcGRhdGUpIHtcbiAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IGFyZSB0aHJvd24gYnkgYSBjaGlsZCBkdXJpbmcgdGhlIHJlbmRlclxuICAvLyBwaGFzZS4gVGhleSBzaG91bGQgYmUgZGlzY2FyZGVkIGlmIHRoZSByZW5kZXIgaXMgYWJvcnRlZC4gVGhlcmVmb3JlLFxuICAvLyB3ZSBzaG91bGQgb25seSBwdXQgdGhlbSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgbm90IHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIENoZWNrIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGEgY2xvbmUuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAgIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlblxuICAgICAgLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuICAgICAgLy8gYSBjaGlsZC4gU2luY2Ugd2Ugd2FudCB0byBhcHBlbmQgdGhlIHVwZGF0ZSBvbmx5IHRvIHRoZSB3b3JrLWluXG4gICAgICAvLyAtcHJvZ3Jlc3MgcXVldWUsIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHVwZGF0ZXMuIFdlIHVzdWFsbHkgY2xvbmUgZHVyaW5nXG4gICAgICAvLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIHNraXBwZWQgb3ZlciB0aGUgcGFyZW50IHdoZW4gd2UgYmFpbGVkIG91dC5cbiAgICAgIHZhciBuZXdGaXJzdCA9IG51bGw7XG4gICAgICB2YXIgbmV3TGFzdCA9IG51bGw7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgdXBkYXRlcyBhbmQgY2xvbmUgdGhlbS5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGUuZXZlbnRUaW1lLFxuICAgICAgICAgICAgbGFuZTogdXBkYXRlLmxhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgICAgICBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuXG5cbiAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgICBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBubyBiYXNlIHVwZGF0ZXMuXG4gICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgICBlZmZlY3RzOiBjdXJyZW50UXVldWUuZWZmZWN0c1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cblxuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gIH1cblxuICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcblxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gIH1cblxuICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7IC8vIFRoZSBwZW5kaW5nIHF1ZXVlIGlzIGNpcmN1bGFyLiBEaXNjb25uZWN0IHRoZSBwb2ludGVyIGJldHdlZW4gZmlyc3RcbiAgICAvLyBhbmQgbGFzdCBzbyB0aGF0IGl0J3Mgbm9uLWNpcmN1bGFyLlxuXG4gICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHZhciBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsOyAvLyBBcHBlbmQgcGVuZGluZyB1cGRhdGVzIHRvIGJhc2UgcXVldWVcblxuICAgIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH1cblxuICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7IC8vIElmIHRoZXJlJ3MgYSBjdXJyZW50IHF1ZXVlLCBhbmQgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgYmFzZSBxdWV1ZSwgdGhlblxuICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlIHVwZGF0ZXMgdG8gdGhhdCBxdWV1ZSwgdG9vLiBCZWNhdXNlIHRoZSBiYXNlXG4gICAgLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuICAgIC8vIGxpc3RzIGFuZCB0YWtlIGFkdmFudGFnZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuXG4gICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnRcblxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgdmFyIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSAhPT0gbGFzdEJhc2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG5cblxuICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHVwZGF0ZXMgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LlxuICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTsgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmUgcmVuZGVyTGFuZXNcbiAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuICAgIHZhciBuZXdMYW5lcyA9IE5vTGFuZXM7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0xhc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZTtcbiAgICAgIHZhciB1cGRhdGVFdmVudFRpbWUgPSB1cGRhdGUuZXZlbnRUaW1lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5cblxuICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIG5ld1N0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBuZXdTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuXG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCAmJiAvLyBJZiB0aGUgdXBkYXRlIHdhcyBhbHJlYWR5IGNvbW1pdHRlZCwgd2Ugc2hvdWxkIG5vdCBxdWV1ZSBpdHNcbiAgICAgICAgLy8gY2FsbGJhY2sgYWdhaW4uXG4gICAgICAgIHVwZGF0ZS5sYW5lICE9PSBOb0xhbmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDYWxsYmFjaztcbiAgICAgICAgICB2YXIgZWZmZWN0cyA9IHF1ZXVlLmVmZmVjdHM7XG5cbiAgICAgICAgICBpZiAoZWZmZWN0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUuZWZmZWN0cyA9IFt1cGRhdGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTsgLy8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuICAgIC8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG4gICAgLy8gYXJlIHJlbWFpbmluZy5cblxuICAgIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5zaGFyZWQuaW50ZXJsZWF2ZWQ7XG5cbiAgICBpZiAobGFzdEludGVybGVhdmVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJsZWF2ZWQgPSBsYXN0SW50ZXJsZWF2ZWQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCBpbnRlcmxlYXZlZC5sYW5lKTtcbiAgICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgICAgfSB3aGlsZSAoaW50ZXJsZWF2ZWQgIT09IGxhc3RJbnRlcmxlYXZlZCk7XG4gICAgfSBlbHNlIGlmIChmaXJzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAgcXVldWUuc2hhcmVkLmxhbmVzID0gTm9MYW5lcztcbiAgICB9IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkICcgKyAoXCJyZWNlaXZlZDogXCIgKyBjYWxsYmFjaykpO1xuICB9XG5cbiAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIGZpbmlzaGVkUXVldWUsIGluc3RhbmNlKSB7XG4gIC8vIENvbW1pdCB0aGUgZWZmZWN0c1xuICB2YXIgZWZmZWN0cyA9IGZpbmlzaGVkUXVldWUuZWZmZWN0cztcbiAgZmluaXNoZWRRdWV1ZS5lZmZlY3RzID0gbnVsbDtcblxuICBpZiAoZWZmZWN0cyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVmZmVjdCA9IGVmZmVjdHNbaV07XG4gICAgICB2YXIgY2FsbGJhY2sgPSBlZmZlY3QuY2FsbGJhY2s7XG5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBlZmZlY3QuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307IC8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG5cbnZhciBlbXB0eVJlZnNPYmplY3QgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkucmVmcztcbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuXG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcblxuICAgICAgZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgJyArICdtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgJyArICdhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnICsgXCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgXCIgKyAndG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggJyArICd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXh0UHJvcHMpIHtcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7IC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgdmFyIHJvb3QgPSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGVycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcbiAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7XG5cbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnICsgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0ID0gaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cbiAge1xuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cblxuXG4gIGlmIChpc0xlZ2FjeUNvbnRleHRDb25zdW1lcikge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgIHtcbiAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBmaWJlckZsYWdzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gICAgICB7XG4gICAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG4gICAgICB9XG5cbiAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gX2ZpYmVyRmxhZ3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9maWJlckZsYWdzMiA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFnczIgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX2ZpYmVyRmxhZ3MyIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgICAgfVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBfZmliZXJGbGFnczI7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSAmJiAhKGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gICApKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkgfHwgLy8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG4gIC8vIGJvdGggYmVmb3JlIGFuZCBhZnRlciBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBoYXMgYmVlbiBjYWxsZWQuIE5vdCBpZGVhbCxcbiAgLy8gYnV0IEknbSBsb2F0aCB0byByZWZhY3RvciB0aGlzIGZ1bmN0aW9uLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgbWVtb2l6ZWRcbiAgLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cbiAgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiAgIDtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbi8vIFRPRE86IFVzZSB0aGUgdW5pZmllZCBmaWJlciBzdGFjayBtb2R1bGUgaW5zdGVhZCBvZiB0aGlzIGxvY2FsIG9uZT9cbi8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGl0IHlldCB0byBkZXJpc2sgdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIGJlY2F1c2Vcbi8vIHRoZSB3YXkgd2UgcHVzaC9wb3AgdGhlc2UgdmFsdWVzIGlzIGEgYml0IHVudXN1YWwuIElmIHRoZXJlJ3MgYSBtaXN0YWtlLCBJJ2Rcbi8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG52YXIgZm9ya1N0YWNrID0gW107XG52YXIgZm9ya1N0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVGb3JrQ291bnQgPSAwO1xudmFyIGlkU3RhY2sgPSBbXTtcbnZhciBpZFN0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVDb250ZXh0SWQgPSAxO1xudmFyIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSAnJztcbmZ1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JrZWQpICE9PSBOb0ZsYWdzO1xufVxuZnVuY3Rpb24gZ2V0Rm9ya3NBdExldmVsKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICByZXR1cm4gdHJlZUZvcmtDb3VudDtcbn1cbmZ1bmN0aW9uIGdldFRyZWVJZCgpIHtcbiAgdmFyIG92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciB3ZSByZWNvbmNpbGUgYW4gYXJyYXkgKG9yIGl0ZXJhdG9yKSBvZiBjaGlsZFxuICAvLyBmaWJlcnMsIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIGtub3cgaG93IG1hbnkgY2hpbGRyZW4gaW5cbiAgLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG4gIC8vIGluZm9ybWF0aW9uIG9uIHRoZSBmaWJlci5cbiAgLy9cbiAgLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG4gIC8vIHRoZSByZW5kZXIgcGhhc2Ugb2YgdGhlIGZvcmsgcGFyZW50LCBub3QgdGhlIGNoaWxkLCB3aGljaCBpcyB3aGVyZSB3ZSBwdXNoXG4gIC8vIHRoZSBvdGhlciBjb250ZXh0IHZhbHVlcy5cbiAgLy9cbiAgLy8gSW4gdGhlIEZpenogaW1wbGVtZW50YXRpb24gdGhpcyBpcyBtdWNoIHNpbXBsZXIgYmVjYXVzZSB0aGUgY2hpbGQgaXNcbiAgLy8gcmVuZGVyZWQgaW4gdGhlIHNhbWUgY2FsbHN0YWNrIGFzIHRoZSBwYXJlbnQuXG4gIC8vXG4gIC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IGFkZCBhIGBmb3Jrc2AgZmllbGQgdG8gdGhlIEZpYmVyIHR5cGUuIEl0IHdvdWxkXG4gIC8vIG1ha2UgdGhpcyBtb2R1bGUgc2ltcGxlci5cbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgYmFzZU92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IHJlc3RPZkxlbmd0aCB8IGlkO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgcGF0aFxuICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG4gICAgdmFyIF9pZCA9IG5ld0JpdHMgfCBiYXNlSWQ7XG5cbiAgICB2YXIgX292ZXJmbG93ID0gYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IGxlbmd0aCB8IF9pZDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gX292ZXJmbG93O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpOyAvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFRoaXMgd2lsbCBhZmZlY3QgYW55IGlkcyB0aGF0IGFwcGVhclxuICAvLyBpbiBpdHMgY2hpbGRyZW4uXG5cbiAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBudW1iZXJPZkZvcmtzID0gMTtcbiAgICB2YXIgc2xvdEluZGV4ID0gMDtcbiAgICBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MpO1xuICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufVxuXG5mdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZXMuXG4gIC8vIFRoaXMgaXMgYSBiaXQgbW9yZSBjb21wbGljYXRlZCB0aGFuIG90aGVyIGNvbnRleHQtbGlrZSBtb2R1bGVzIGluIEZpYmVyXG4gIC8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuICAvLyBkaWZmZXJlbnQgcmVhc29ucy4gV2UgaGF2ZSB0byBrZWVwIHBvcHBpbmcgdW50aWwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaXNcbiAgLy8gbm8gbG9uZ2VyIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXIpIHtcbiAgICB0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO1xuICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG4gICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGw7XG4gIH1cblxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXIpIHtcbiAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXG4gIGlmICh0cmVlQ29udGV4dFByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0cmVlQ29udGV4dElkLFxuICAgICAgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3dcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbmRlZENvbnRleHQpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0SWQgPSBzdXNwZW5kZWRDb250ZXh0LmlkO1xuICB0cmVlQ29udGV4dE92ZXJmbG93ID0gc3VzcGVuZGVkQ29udGV4dC5vdmVyZmxvdztcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gIHtcbiAgICBpZiAoIWdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcgKyAnYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbnZhciBkaWRTdXNwZW5kID0gZmFsc2U7IC8vIEh5ZHJhdGlvbiBlcnJvcnMgdGhhdCB3ZXJlIHRocm93biBpbnNpZGUgdGhpcyBib3VuZGFyeVxuXG52YXIgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcblxuZnVuY3Rpb24gd2FybklmSHlkcmF0aW5nKCkge1xuICB7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICBlcnJvcignV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtEaWRTdXNwZW5kV2hpbGVIeWRyYXRpbmdERVYoKSB7XG4gIHtcbiAgICBkaWRTdXNwZW5kID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICBkaWRTdXNwZW5kID0gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsIHN1c3BlbnNlSW5zdGFuY2UsIHRyZWVDb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmQgPSBmYWxzZTtcblxuICBpZiAodHJlZUNvbnRleHQgIT09IG51bGwpIHtcbiAgICByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQoZmliZXIsIHRyZWVDb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuVW5oeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHJldHVybkZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGlmIChzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHdhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKTtcbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV07XG4gICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAge1xuICAgIGlmIChkaWRTdXNwZW5kKSB7XG4gICAgICAvLyBJbnNpZGUgYSBib3VuZGFyeSB0aGF0IGFscmVhZHkgc3VzcGVuZGVkLiBXZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHRoZVxuICAgICAgLy8gc2libGluZ3Mgb2YgYSBzdXNwZW5kZWQgbm9kZS4gVGhlIG1pc21hdGNoIG1heSBiZSBkdWUgdG8gdGhlIG1pc3NpbmdcbiAgICAgIC8vIGRhdGEsIHNvIGl0J3MgcHJvYmFibHkgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXIocGFyZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIF9wcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSByZXR1cm5GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgICAgICAgaWYgKF9wYXJlbnRJbnN0YW5jZSAhPT0gbnVsbCkgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlMiA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHMyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UsIF90eXBlMiwgX3Byb3BzMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgX3RleHQyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UoX3BhcmVudEluc3RhbmNlLCBfdGV4dDIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICBmaWJlci5mbGFncyA9IGZpYmVyLmZsYWdzICYgfkh5ZHJhdGluZyB8IFBsYWNlbWVudDtcbiAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuXG4gICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjsgLy8gVGV4dCBJbnN0YW5jZXMgZG9uJ3QgaGF2ZSBjaGlsZHJlbiBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gaHlkcmF0ZS5cblxuICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlKTtcblxuICAgICAgICAgIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgZGVoeWRyYXRlZDogc3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgICAgICAgICAgdHJlZUNvbnRleHQ6IGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCksXG4gICAgICAgICAgICAgIHJldHJ5TGFuZTogT2Zmc2NyZWVuTGFuZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBzdXNwZW5zZVN0YXRlOyAvLyBTdG9yZSB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudCBhcyBhIGNoaWxkIGZpYmVyLlxuICAgICAgICAgICAgLy8gVGhpcyBzaW1wbGlmaWVzIHRoZSBjb2RlIGZvciBnZXRIb3N0U2libGluZyBhbmQgZGVsZXRpbmcgbm9kZXMsXG4gICAgICAgICAgICAvLyBzaW5jZSBpdCBkb2Vzbid0IGhhdmUgdG8gY29uc2lkZXIgYWxsIFN1c3BlbnNlIGJvdW5kYXJpZXMgYW5kXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGV5J3JlIGRlaHlkcmF0ZWQgb25lcyBvciBub3QuXG5cbiAgICAgICAgICAgIHZhciBkZWh5ZHJhdGVkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgICAgICBkZWh5ZHJhdGVkRnJhZ21lbnQucmV0dXJuID0gZmliZXI7XG4gICAgICAgICAgICBmaWJlci5jaGlsZCA9IGRlaHlkcmF0ZWRGcmFnbWVudDtcbiAgICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbiAgICAgICAgICAgIC8vIGl0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSW5zdGVhZCwgd2UnbGwgcmVlbnRlciBpdCBsYXRlci5cblxuICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpIHtcbiAgcmV0dXJuICAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlICYmIChmaWJlci5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgJyArICdyZW5kZXJlZCBvbiB0aGUgc2VydmVyLicpO1xufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgIHdhcm5Ob25oeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goKTtcbiAgICB9IC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG5cblxuICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UgPSBuZXh0SW5zdGFuY2U7XG5cbiAgaWYgKCF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgaWYgKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKSB7XG4gICAgICB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKCk7XG4gICAgfSAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuXG5cbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gICAgdmFyIHByZXZIeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuXG4gICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZDtcbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyLCBzaG91bGRXYXJuSWZNaXNtYXRjaERldik7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZDtcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIsIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciBpc0NvbmN1cnJlbnRNb2RlID0gKHJldHVybkZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcblxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbiAgICAgICAgICAgIGlzQ29uY3VycmVudE1vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG4gICAgICAgICAgICBpc0NvbmN1cnJlbnRNb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgLy8gc2lkZSBvZiB0aGVtLiBXZSBhbHNvIGRvbid0IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyLlxuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QgJiYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICBpZiAobmV4dEluc3RhbmNlKSB7XG4gICAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcik7XG4gICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO1xuICB9IGVsc2Uge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmcgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcikge1xuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgd2FyblVuaHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgZGlkU3VzcGVuZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyAhPT0gbnVsbCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgYSBmb3JjZWQgY2xpZW50IHJlbmRlci4gVGhlIGVycm9ycyB0aGF0IG9jY3VycmVkXG4gICAgLy8gZHVyaW5nIHRoZSBoeWRyYXRpb24gYXR0ZW1wdCBhcmUgbm93IHJlY292ZXJlZC4gV2Ugd2lsbCBsb2cgdGhlbSBpblxuICAgIC8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxuICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKTtcbiAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldElzSHlkcmF0aW5nKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmc7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyA9PT0gbnVsbCkge1xuICAgIGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnM7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmc7XG52YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nO1xuXG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7fTtcblxue1xuICBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG5cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQuX3N0b3JlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcblxuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICAvLyBUT0RPOiBDbGVhbiB0aGlzIHVwIG9uY2Ugd2UgdHVybiBvbiB0aGUgc3RyaW5nIHJlZiB3YXJuaW5nIGZvclxuICAgICAgLy8gZXZlcnlvbmUsIGJlY2F1c2UgdGhlIHN0cmljdCBtb2RlIGNhc2Ugd2lsbCBubyBsb25nZXIgYmUgcmVsZXZhbnRcbiAgICAgIGlmICgocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgfHwgd2FybkFib3V0U3RyaW5nUmVmcykgJiYgLy8gV2Ugd2FybiBpbiBSZWFjdEVsZW1lbnQuanMgaWYgb3duZXIgYW5kIHNlbGYgYXJlIGVxdWFsIGZvciBzdHJpbmcgcmVmc1xuICAgICAgLy8gYmVjYXVzZSB0aGVzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb25cbiAgICAgIC8vIHVzaW5nIGEgY29kZW1vZC4gVGhlcmVmb3JlLCB3ZSBkb24ndCBoYXZlIHRvIHdhcm4gYWJvdXQgc3RyaW5nIHJlZnMgYWdhaW4uXG4gICAgICAhKGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX3NlbGYgJiYgZWxlbWVudC5fb3duZXIuc3RhdGVOb2RlICE9PSBlbGVtZW50Ll9zZWxmKSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdBIHN0cmluZyByZWYsIFwiJXNcIiwgaGFzIGJlZW4gZm91bmQgd2l0aGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdTdHJpbmcgcmVmcyBhcmUgYSBzb3VyY2Ugb2YgcG90ZW50aWFsIGJ1Z3MgYW5kIHNob3VsZCBiZSBhdm9pZGVkLiAnICsgJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIG1peGVkUmVmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdDtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG5cbiAgICAgICAgaWYgKG93bmVyRmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSBzdHJpbmcgcmVmcy4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbnN0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBcIiArICdidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0IHNvIEZsb3cga25vd3MgaXQgd29uJ3QgY2hhbmdlIGluIHRoZSBjbG9zdXJlXG5cblxuICAgICAgdmFyIHJlc29sdmVkSW5zdCA9IGluc3Q7XG5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tQcm9wU3RyaW5nQ29lcmNpb24obWl4ZWRSZWYsICdyZWYnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IHJlc29sdmVkSW5zdC5yZWZzO1xuXG4gICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6eSBwb29sZWQgZnJvemVuIG9iamVjdCwgc28gd2UgbmVlZCB0byBpbml0aWFsaXplLlxuICAgICAgICAgIHJlZnMgPSByZXNvbHZlZEluc3QucmVmcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIG1peGVkUmVmICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhIHN0cmluZywgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciBudWxsLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKFwiICsgbWl4ZWRSZWYgKyBcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2ZcIiArICcgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4nICsgXCIyLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnQncyByZW5kZXIgbWV0aG9kXFxuXCIgKyAnMy4gWW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgdmFyIGNoaWxkU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZFN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRTdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxhenkobGF6eVR5cGUpIHtcbiAgdmFyIHBheWxvYWQgPSBsYXp5VHlwZS5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5VHlwZS5faW5pdDtcbiAgcmV0dXJuIGluaXQocGF5bG9hZCk7XG59IC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5cblxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuICAgIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXTtcbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIER1cmluZyBoeWRyYXRpb24sIHRoZSB1c2VJZCBhbGdvcml0aG0gbmVlZHMgdG8ga25vdyB3aGljaCBmaWJlcnMgYXJlXG4gICAgICAvLyBwYXJ0IG9mIGEgbGlzdCBvZiBjaGlsZHJlbiAoYXJyYXlzLCBpdGVyYXRvcnMpLlxuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gRm9ya2VkO1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuXG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGVsZW1lbnRUeXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIGxhbmVzLCBlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuICAgICAgLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4gICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICAgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmIHJlc29sdmVMYXp5KGVsZW1lbnRUeXBlKSA9PT0gY3VycmVudC50eXBlKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIG51bGwpO1xuXG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsIGtleSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBjaGlsZC5faW5pdDtcbiAgICAgICAgICAgIHdhcm5PbkludmFsaWRLZXkoaW5pdChwYXlsb2FkKSwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzMiA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBsYW5lcykge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xuICAgICAgbmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnR2VuZXJhdG9yJykge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9IC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuXG5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKG5ld0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgX251bWJlck9mRm9ya3MzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzMyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczQgPSBuZXdJZHg7XG4gICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5cblxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHwgKCAvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcbiAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBhZnRlciB0aGUgSG90IFJlbG9hZGluZyBjaGVjayBhYm92ZSxcbiAgICAgICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGNoaWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcblxuICAgICAgICAgICAgdmFyIF9leGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzKTtcblxuICAgICAgICAgICAgX2V4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgX2V4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEaWRuJ3QgbWF0Y2guXG5cblxuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgX2NyZWF0ZWQ0LnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ0LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH0gLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuXG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWN1cnNpdmUuXG4gICAgLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbiAgICAvLyBub3QgYXMgYSBmcmFnbWVudC4gTmVzdGVkIGFycmF5cyBvbiB0aGUgb3RoZXIgaGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBmcmFnbWVudCBub2Rlcy4gUmVjdXJzaW9uIGhhcHBlbnMgYXQgdGhlIG5vcm1hbCBmbG93LlxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG5cbiAgICBpZiAoaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9IC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcblxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7IC8vIFRPRE86IFRoaXMgZnVuY3Rpb24gaXMgc3VwcG9zZWQgdG8gYmUgbm9uLXJlY3Vyc2l2ZS5cblxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn0gLy8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhjaGlsZCwgbGFuZXMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xudmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICBpZiAoYyA9PT0gTk9fQ09OVEVYVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7IC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuXG4gIGlmIChjb250ZXh0ID09PSBuZXh0Q29udGV4dCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIERlZmF1bHRTdXNwZW5zZUNvbnRleHQgPSAwOyAvLyBUaGUgU3VzcGVuc2UgQ29udGV4dCBpcyBzcGxpdCBpbnRvIHR3byBwYXJ0cy4gVGhlIGxvd2VyIGJpdHMgaXNcbi8vIGluaGVyaXRlZCBkZWVwbHkgZG93biB0aGUgc3VidHJlZS4gVGhlIHVwcGVyIGJpdHMgb25seSBhZmZlY3Rcbi8vIHRoaXMgaW1tZWRpYXRlIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBnZXRzIHJlc2V0IGVhY2ggbmV3XG4vLyBib3VuZGFyeSBvciBzdXNwZW5zZSBsaXN0LlxuXG52YXIgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxOyAvLyBTdWJ0cmVlIEZsYWdzOlxuLy8gSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0IGluZGljYXRlcyB0aGF0IG9uZSBvZiBvdXIgcGFyZW50IFN1c3BlbnNlXG4vLyBib3VuZGFyaWVzIGlzIG5vdCBjdXJyZW50bHkgc2hvd2luZyB2aXNpYmxlIG1haW4gY29udGVudC5cbi8vIEVpdGhlciBiZWNhdXNlIGl0IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIG9yIGlzIG5vdCBtb3VudGVkIGF0IGFsbC5cbi8vIFdlIGNhbiB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgaXQgaXMgZGVzaXJhYmxlIHRvIHRyaWdnZXIgYSBmYWxsYmFjayBhdFxuLy8gdGhlIHBhcmVudC4gSWYgbm90LCB0aGVuIHdlIG1pZ2h0IG5lZWQgdG8gdHJpZ2dlciB1bmRlc2lyYWJsZSBib3VuZGFyaWVzXG4vLyBhbmQvb3Igc3VzcGVuZCB0aGUgY29tbWl0IHRvIGF2b2lkIGhpZGluZyB0aGUgcGFyZW50IGNvbnRlbnQuXG5cbnZhciBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgPSAxOyAvLyBTaGFsbG93IEZsYWdzOlxuLy8gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGNhbiBiZSB1c2VkIGJ5IFN1c3BlbnNlTGlzdCB0byBmb3JjZSBuZXdseSBhZGRlZFxuLy8gaXRlbXMgaW50byB0aGVpciBmYWxsYmFjayBzdGF0ZSBkdXJpbmcgb25lIG9mIHRoZSByZW5kZXIgcGFzc2VzLlxuXG52YXIgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMjtcbnZhciBzdXNwZW5zZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKERlZmF1bHRTdXNwZW5zZUNvbnRleHQpO1xuZnVuY3Rpb24gaGFzU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIGZsYWcpIHtcbiAgcmV0dXJuIChwYXJlbnRDb250ZXh0ICYgZmxhZykgIT09IDA7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG59XG5mdW5jdGlvbiBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIHNoYWxsb3dDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgfCBzaGFsbG93Q29udGV4dDtcbn1cbmZ1bmN0aW9uIGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc3VidHJlZUNvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgfCBzdWJ0cmVlQ29udGV4dDtcbn1cbmZ1bmN0aW9uIHB1c2hTdXNwZW5zZUNvbnRleHQoZmliZXIsIG5ld0NvbnRleHQpIHtcbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXdDb250ZXh0LCBmaWJlcik7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUNvbnRleHQoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKHdvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgLy8gSWYgaXQgd2FzIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHRoYXQganVzdCBzdXNwZW5kZWQsIGNhcHR1cmUgYW5kIHJlbmRlciB0aGVcbiAgLy8gZmFsbGJhY2suIE90aGVyd2lzZSwgZG9uJ3QgY2FwdHVyZSBhbmQgYnViYmxlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV4dFN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGRlaHlkcmF0ZWQgYm91bmRhcnkgYWx3YXlzIGNhcHR1cmVzLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wczsgLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG4gIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgICovXG4wOyAvLyBSZXByZXNlbnRzIHdoZXRoZXIgZWZmZWN0IHNob3VsZCBmaXJlLlxuXG52YXIgSGFzRWZmZWN0ID1cbi8qICovXG4xOyAvLyBSZXByZXNlbnRzIHRoZSBwaGFzZSBpbiB3aGljaCB0aGUgZWZmZWN0IChub3QgdGhlIGNsZWFuLXVwKSBmaXJlcy5cblxudmFyIEluc2VydGlvbiA9XG4vKiAgKi9cbjI7XG52YXIgTGF5b3V0ID1cbi8qICAgICovXG40O1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG44O1xuXG4vLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG4vLyBUaGlzIHRyYWNrcyB3aGljaCBtdXRhYmxlIHNvdXJjZXMgbmVlZCB0byBiZSByZXNldCBhZnRlciBhIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzU291cmNlcyA9IFtdO1xuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtdXRhYmxlU291cmNlID0gd29ya0luUHJvZ3Jlc3NTb3VyY2VzW2ldO1xuXG4gICAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgICBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uU2Vjb25kYXJ5ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoID0gMDtcbn1cbi8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSB2ZXJzaW9uIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcgbWF0Y2hlcyB0aGUgb25lXG4vLyB0aGF0IGlzIGV2ZW50dWFsbHkgcmVhZCBkdXJpbmcgaHlkcmF0aW9uLlxuLy8gSWYgdGhleSBkb24ndCBtYXRjaCB0aGVyZSdzIGEgcG90ZW50aWFsIHRlYXIgYW5kIGEgZnVsbCBkZW9wdCByZW5kZXIgaXMgcmVxdWlyZWQuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LCBtdXRhYmxlU291cmNlKSB7XG4gIHZhciBnZXRWZXJzaW9uID0gbXV0YWJsZVNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKG11dGFibGVTb3VyY2UuX3NvdXJjZSk7IC8vIFRPRE8gQ2xlYXIgdGhpcyBkYXRhIG9uY2UgYWxsIHBlbmRpbmcgaHlkcmF0aW9uIHdvcmsgaXMgZmluaXNoZWQuXG4gIC8vIFJldGFpbmluZyBpdCBmb3JldmVyIG1heSBpbnRlcmZlcmUgd2l0aCBHQy5cblxuICBpZiAocm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID09IG51bGwpIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSBbbXV0YWJsZVNvdXJjZSwgdmVyc2lvbl07XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLnB1c2gobXV0YWJsZVNvdXJjZSwgdmVyc2lvbik7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcblxue1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50LlxuXG52YXIgbG9jYWxJZENvdW50ZXIgPSAwOyAvLyBVc2VkIGZvciBpZHMgdGhhdCBhcmUgZ2VuZXJhdGVkIGNvbXBsZXRlbHkgY2xpZW50LXNpZGUgKGkuZS4gbm90IGR1cmluZ1xuLy8gaHlkcmF0aW9uKS4gVGhpcyBjb3VudGVyIGlzIGdsb2JhbCwgc28gY2xpZW50IGlkcyBhcmUgbm90IHN0YWJsZSBhY3Jvc3Ncbi8vIHJlbmRlciBhdHRlbXB0cy5cblxudmFyIGdsb2JhbENsaWVudElkQ291bnRlciA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIWlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gJyc7XG4gICAgICAgIHZhciBzZWNvbmRDb2x1bW5TdGFydCA9IDMwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcbiAgICAgICAgICB2YXIgb2xkSG9va05hbWUgPSBob29rVHlwZXNEZXZbaV07XG4gICAgICAgICAgdmFyIG5ld0hvb2tOYW1lID0gaSA9PT0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPyBjdXJyZW50SG9va05hbWUgOiBvbGRIb29rTmFtZTtcbiAgICAgICAgICB2YXIgcm93ID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTsgLy8gRXh0cmEgc3BhY2Ugc28gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cFxuICAgICAgICAgIC8vIGxvbCBAIElFIG5vdCBzdXBwb3J0aW5nIFN0cmluZyNyZXBlYXRcblxuICAgICAgICAgIHdoaWxlIChyb3cubGVuZ3RoIDwgc2Vjb25kQ29sdW1uU3RhcnQpIHtcbiAgICAgICAgICAgIHJvdyArPSAnICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93ICs9IG5ld0hvb2tOYW1lICsgJ1xcbic7XG4gICAgICAgICAgdGFibGUgKz0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJ1JlYWN0IGhhcyBkZXRlY3RlZCBhIGNoYW5nZSBpbiB0aGUgb3JkZXIgb2YgSG9va3MgY2FsbGVkIGJ5ICVzLiAnICsgJ1RoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlIFJ1bGVzIG9mIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4nICsgJyAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuJyArICcgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nICsgJyVzJyArICcgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG4nLCBjb21wb25lbnROYW1lLCB0YWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yJyArICcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4nICsgJzEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbicgKyAnMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbicgKyAnMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcbicgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAge1xuICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykge1xuICAgICAgLy8gT25seSB0cnVlIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYmVpbmcgaG90IHJlbG9hZGVkLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZywgbmV4dFJlbmRlckxhbmVzKSB7XG4gIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gVXNlZCBmb3IgaG90IHJlbG9hZGluZzpcblxuICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSBmb2xsb3dpbmcgc2hvdWxkIGhhdmUgYWxyZWFkeSBiZWVuIHJlc2V0XG4gIC8vIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBsb2NhbElkQ291bnRlciA9IDA7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG4gICAgICBsb2NhbElkQ291bnRlciA9IDA7XG5cbiAgICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgJyArICdhbiBpbmZpbml0ZSBsb29wLicpO1xuICAgICAgfVxuXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIH1cblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG5cblxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gQ29uZmlybSB0aGF0IGEgc3RhdGljIGZsYWcgd2FzIG5vdCBhZGRlZCBvciByZW1vdmVkIHNpbmNlIHRoZSBsYXN0XG4gICAgLy8gcmVuZGVyLiBJZiB0aGlzIGZpcmVzLCBpdCBzdWdnZXN0cyB0aGF0IHdlIGluY29ycmVjdGx5IHJlc2V0IHRoZSBzdGF0aWNcbiAgICAvLyBmbGFncyBpbiBzb21lIG90aGVyIHBhcnQgb2YgdGhlIGNvZGViYXNlLiBUaGlzIGhhcyBoYXBwZW5lZCBiZWZvcmUsIGZvclxuICAgIC8vIGV4YW1wbGUsIGluIHRoZSBTdXNwZW5zZUxpc3QgaW1wbGVtZW50YXRpb24uXG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAoY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2spICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBTdGF0aWNNYXNrKSAmJiAvLyBEaXNhYmxlIHRoaXMgd2FybmluZyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBsZWdhY3kgU3VzcGVuc2UgaXMgd2VpcmRcbiAgICAvLyBhbmQgY3JlYXRlcyBmYWxzZSBwb3NpdGl2ZXMuIFRvIG1ha2UgdGhpcyB3b3JrIGluIGxlZ2FjeSBtb2RlLCB3ZSdkXG4gICAgLy8gbmVlZCB0byBtYXJrIGZpYmVycyB0aGF0IGNvbW1pdCBpbiBhbiBpbmNvbXBsZXRlIHN0YXRlLCBzb21laG93LiBGb3JcbiAgICAvLyBub3cgSSdsbCBkaXNhYmxlIHRoZSB3YXJuaW5nIHRoYXQgbW9zdCBvZiB0aGUgYnVncyB0aGF0IHdvdWxkIHRyaWdnZXJcbiAgICAvLyBpdCBhcmUgZWl0aGVyIGV4Y2x1c2l2ZSB0byBjb25jdXJyZW50IG1vZGUgb3IgZXhpc3QgaW4gYm90aC5cbiAgICAoY3VycmVudC5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSAnICsgJ25vdGlmeSB0aGUgUmVhY3QgdGVhbS4nKTtcbiAgICB9XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgaXMgcmVzZXQgYnkgY2hlY2tEaWRSZW5kZXJJZEhvb2tcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuXG4gIGlmIChkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgJyArICdlYXJseSByZXR1cm4gc3RhdGVtZW50LicpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSByZW5kZXJXaXRoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiByZW5kZXJXaXRoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICB2YXIgZGlkUmVuZGVySWRIb29rID0gbG9jYWxJZENvdW50ZXIgIT09IDA7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBmbGFncyBoZXJlLCBiZWNhdXNlIHRoZXkncmUgcmVzZXQgaW4gdGhlXG4gIC8vIGNvbXBsZXRlIHBoYXNlIChidWJibGVQcm9wZXJ0aWVzKS5cblxuICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KE1vdW50UGFzc2l2ZURldiB8IE1vdW50TGF5b3V0RGV2IHwgUGFzc2l2ZSB8IFVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlIHwgVXBkYXRlKTtcbiAgfVxuXG4gIGN1cnJlbnQubGFuZXMgPSByZW1vdmVMYW5lcyhjdXJyZW50LmxhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzQWZ0ZXJUaHJvdygpIHtcbiAgLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVGhlcmUgd2VyZSByZW5kZXIgcGhhc2UgdXBkYXRlcy4gVGhlc2UgYXJlIG9ubHkgdmFsaWQgZm9yIHRoaXMgcmVuZGVyXG4gICAgLy8gcGhhc2UsIHdoaWNoIHdlIGFyZSBub3cgYWJvcnRpbmcuIFJlbW92ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZXMgc29cbiAgICAvLyB0aGV5IGRvIG5vdCBwZXJzaXN0IHRvIHRoZSBuZXh0IHJlbmRlci4gRG8gbm90IHJlbW92ZSB1cGRhdGVzIGZyb20gaG9va3NcbiAgICAvLyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkLlxuICAgIC8vXG4gICAgLy8gT25seSByZXNldCB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZSBpZiBpdCBoYXMgYSBjbG9uZS4gSWYgaXQgZG9lc1xuICAgIC8vIG5vdCBoYXZlIGEgY2xvbmUsIHRoYXQgbWVhbnMgaXQgd2Fzbid0IHByb2Nlc3NlZCwgYW5kIHRoZSB1cGRhdGVzIHdlcmVcbiAgICAvLyBzY2hlZHVsZWQgYmVmb3JlIHdlIGVudGVyZWQgdGhlIHJlbmRlciBwaGFzZS5cbiAgICB2YXIgaG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gICAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhvb2sgPSBob29rLm5leHQ7XG4gICAgfVxuXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuICAvLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAobmV4dEN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICB2YXIgbmV3SG9vayA9IHtcbiAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0LlxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gbmV3SG9vaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5ld0hvb2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIHN0b3JlczogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgaW50ZXJsZWF2ZWQ6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50ID0gY3VycmVudEhvb2s7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gY3VycmVudC5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIGlmICh1cGRhdGUuaGFzRWFnZXJTdGF0ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgdXBkYXRlIGlzIGEgc3RhdGUgdXBkYXRlIChub3QgYSByZWR1Y2VyKSBhbmQgd2FzIHByb2Nlc3NlZCBlYWdlcmx5LFxuICAgICAgICAgIC8vIHdlIGNhbiB1c2UgdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGVcbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIEludGVybGVhdmVkIHVwZGF0ZXMgYXJlIHN0b3JlZCBvbiBhIHNlcGFyYXRlIHF1ZXVlLiBXZSBhcmVuJ3QgZ29pbmcgdG9cbiAgLy8gcHJvY2VzcyB0aGVtIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHdlIGRvIG5lZWQgdG8gdHJhY2sgd2hpY2ggbGFuZXNcbiAgLy8gYXJlIHJlbWFpbmluZy5cblxuXG4gIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5pbnRlcmxlYXZlZDtcblxuICBpZiAobGFzdEludGVybGVhdmVkICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVybGVhdmVkID0gbGFzdEludGVybGVhdmVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIGludGVybGVhdmVkTGFuZSA9IGludGVybGVhdmVkLmxhbmU7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBpbnRlcmxlYXZlZExhbmUpO1xuICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhpbnRlcmxlYXZlZExhbmUpO1xuICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgIH0gd2hpbGUgKGludGVybGVhdmVkICE9PSBsYXN0SW50ZXJsZWF2ZWQpO1xuICB9IGVsc2UgaWYgKGJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICBxdWV1ZS5sYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyOyAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAvLyB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nO1xuICB2YXIgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBxdWV1ZSBkb2Vzbid0IHBlcnNpc3QgcGFzdCB0aGlzIHJlbmRlciBwYXNzLlxuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIHJlbmRlcidzLlxuICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpOyAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7IC8vIERvbid0IHBlcnNpc3QgdGhlIHN0YXRlIGFjY3VtdWxhdGVkIGZyb20gdGhlIHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvXG4gICAgLy8gdGhlIGJhc2Ugc3RhdGUgdW5sZXNzIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBkZXNpcmVkIHNlbWFudGljcywgYnV0IGl0J3Mgd2hhdCB3ZVxuICAgIC8vIGRvIGZvciBnRFNGUC4gSSBjYW4ndCByZW1lbWJlciB3aHkuXG5cbiAgICBpZiAoaG9vay5iYXNlUXVldWUgPT09IG51bGwpIHtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHRTbmFwc2hvdDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZ2V0SXNIeWRyYXRpbmcoKTtcblxuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICBpZiAoZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICB9XG5cbiAgICBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICBpZiAobmV4dFNuYXBzaG90ICE9PSBnZXRTZXJ2ZXJTbmFwc2hvdCgpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U2VydmVyU25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHRTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuICAgIC8vXG4gICAgLy8gV2Ugd29uJ3QgZG8gdGhpcyBpZiB3ZSdyZSBoeWRyYXRpbmcgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQsIGJlY2F1c2UgaWZcbiAgICAvLyB0aGUgY29udGVudCBpcyBzdGFsZSwgaXQncyBhbHJlYWR5IHZpc2libGUgYW55d2F5LiBJbnN0ZWFkIHdlJ2xsIHBhdGNoXG4gICAgLy8gaXQgdXAgaW4gYSBwYXNzaXZlIGVmZmVjdC5cblxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgdmFyIGluc3QgPSB7XG4gICAgdmFsdWU6IG5leHRTbmFwc2hvdCxcbiAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IGluc3Q7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBzdWJzY3JpYmUgdG8gdGhlIHN0b3JlLlxuXG4gIG1vdW50RWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSwgW3N1YnNjcmliZV0pOyAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gdXBkYXRlIHRoZSBtdXRhYmxlIGluc3RhbmNlIGZpZWxkcy4gV2Ugd2lsbCB1cGRhdGVcbiAgLy8gdGhpcyB3aGVuZXZlciBzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBvciB2YWx1ZSBjaGFuZ2VzLiBCZWNhdXNlIHRoZXJlJ3Mgbm9cbiAgLy8gY2xlYW4tdXAgZnVuY3Rpb24sIGFuZCB3ZSB0cmFjayB0aGUgZGVwcyBjb3JyZWN0bHksIHdlIGNhbiBjYWxsIHB1c2hFZmZlY3RcbiAgLy8gZGlyZWN0bHksIHdpdGhvdXQgc3RvcmluZyBhbnkgYWRkaXRpb25hbCBzdGF0ZS4gRm9yIHRoZSBzYW1lIHJlYXNvbiwgd2VcbiAgLy8gZG9uJ3QgbmVlZCB0byBzZXQgYSBzdGF0aWMgZmxhZywgZWl0aGVyLlxuICAvLyBUT0RPOiBXZSBjYW4gbW92ZSB0aGlzIHRvIHRoZSBwYXNzaXZlIHBoYXNlIG9uY2Ugd2UgYWRkIGEgcHJlLWNvbW1pdFxuICAvLyBjb25zaXN0ZW5jeSBjaGVjay4gU2VlIHRoZSBuZXh0IGNvbW1lbnQuXG5cbiAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZTtcbiAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuICB2YXIgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZTbmFwc2hvdCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHNuYXBzaG90Q2hhbmdlZCA9ICFvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG5cbiAgaWYgKHNuYXBzaG90Q2hhbmdlZCkge1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5leHRTbmFwc2hvdDtcbiAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICB9XG5cbiAgdmFyIGluc3QgPSBob29rLnF1ZXVlO1xuICB1cGRhdGVFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFdoZW5ldmVyIGdldFNuYXBzaG90IG9yIHN1YnNjcmliZSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIGNoZWNrIGluIHRoZVxuICAvLyBjb21taXQgcGhhc2UgaWYgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIG11dGF0aW9uLiBJbiBjb25jdXJyZW50IG1vZGVcbiAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAvLyBlZmZlY3QgbWF5IGhhdmUgbXV0YXRlZCB0aGUgc3RvcmUuXG5cbiAgaWYgKGluc3QuZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8IHNuYXBzaG90Q2hhbmdlZCB8fCAvLyBDaGVjayBpZiB0aGUgc3VzYmNyaWJlIGZ1bmN0aW9uIGNoYW5nZWQuIFdlIGNhbiBzYXZlIHNvbWUgbWVtb3J5IGJ5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgd2Ugc2NoZWR1bGVkIGEgc3Vic2NyaXB0aW9uIGVmZmVjdCBhYm92ZS5cbiAgd29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLnRhZyAmIEhhc0VmZmVjdCkge1xuICAgIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmU7XG4gICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIHVuZGVmaW5lZCwgbnVsbCk7IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgZmliZXIuZmxhZ3MgfD0gU3RvcmVDb25zaXN0ZW5jeTtcbiAgdmFyIGNoZWNrID0ge1xuICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCxcbiAgICB2YWx1ZTogcmVuZGVyZWRTbmFwc2hvdFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdG9yZXMgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXM7XG5cbiAgICBpZiAoc3RvcmVzID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZXMucHVzaChjaGVjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcbiAgLy8gVGhlc2UgYXJlIHVwZGF0ZWQgaW4gdGhlIHBhc3NpdmUgcGhhc2VcbiAgaW5zdC52YWx1ZSA9IG5leHRTbmFwc2hvdDtcbiAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBTb21ldGhpbmcgbWF5IGhhdmUgYmVlbiBtdXRhdGVkIGluIGJldHdlZW4gcmVuZGVyIGFuZCBjb21taXQuIFRoaXMgY291bGRcbiAgLy8gaGF2ZSBiZWVuIGluIGFuIGV2ZW50IHRoYXQgZmlyZWQgYmVmb3JlIHRoZSBwYXNzaXZlIGVmZmVjdHMsIG9yIGl0IGNvdWxkXG4gIC8vIGhhdmUgYmVlbiBpbiBhIGxheW91dCBlZmZlY3QuIEluIHRoYXQgY2FzZSwgd2Ugd291bGQgaGF2ZSB1c2VkIHRoZSBvbGRcbiAgLy8gc25hcHNobyBhbmQgZ2V0U25hcHNob3QgdmFsdWVzIHRvIGJhaWwgb3V0LiBXZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIHRpbWUuXG5cbiAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICB2YXIgaGFuZGxlU3RvcmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2VcbiAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgfVxuICB9OyAvLyBTdWJzY3JpYmUgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gYSBjbGVhbi11cCBmdW5jdGlvbi5cblxuXG4gIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xufVxuXG5mdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZSgpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoRWZmZWN0KHRhZywgY3JlYXRlLCBkZXN0cm95LCBkZXBzKSB7XG4gIHZhciBlZmZlY3QgPSB7XG4gICAgdGFnOiB0YWcsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgZGVzdHJveTogZGVzdHJveSxcbiAgICBkZXBzOiBkZXBzLFxuICAgIC8vIENpcmN1bGFyXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhc3RFZmZlY3QgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgbGFzdEVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgICAgZWZmZWN0Lm5leHQgPSBmaXJzdEVmZmVjdDtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVmZmVjdDtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICB7XG4gICAgdmFyIF9yZWYyID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBfcmVmMjtcbiAgICByZXR1cm4gX3JlZjI7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gaG9vay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCB1bmRlZmluZWQsIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIGRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGN1cnJlbnRIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZFZmZlY3QgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgIGRlc3Ryb3kgPSBwcmV2RWZmZWN0LmRlc3Ryb3k7XG5cbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZFZmZlY3QuZGVwcztcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0ZsYWdzLCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgaWYgKCAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKE1vdW50UGFzc2l2ZURldiB8IFBhc3NpdmUgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChQYXNzaXZlIHwgUGFzc2l2ZVN0YXRpYywgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoUGFzc2l2ZSwgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gIHtcbiAgICBmaWJlckZsYWdzIHw9IExheW91dFN0YXRpYztcbiAgfVxuXG4gIGlmICggKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZDYWxsYmFjayhfaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0MjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGU7XG5cbiAge1xuICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICB9XG5cbiAgaWYgKCAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICB9XG5cbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7Ly8gVGhpcyBob29rIGlzIG5vcm1hbGx5IGEgbm8tb3AuXG4gIC8vIFRoZSByZWFjdC1kZWJ1Zy1ob29rcyBwYWNrYWdlIGluamVjdHMgaXRzIG93biBpbXBsZW1lbnRhdGlvblxuICAvLyBzbyB0aGF0IGUuZy4gRGV2VG9vbHMgY2FuIGRpc3BsYXkgY3VzdG9tIGhvb2sgdmFsdWVzLlxufVxuXG52YXIgdXBkYXRlRGVidWdWYWx1ZSA9IG1vdW50RGVidWdWYWx1ZTtcblxuZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIG1vdW50TWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAvLyBBc3N1bWUgdGhlc2UgYXJlIGRlZmluZWQuIElmIHRoZXkncmUgbm90LCBhcmVIb29rSW5wdXRzRXF1YWwgd2lsbCB3YXJuLlxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX21vdW50U3RhdGUgPSBtb3VudFN0YXRlKHZhbHVlKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9tb3VudFN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfbW91bnRTdGF0ZVsxXTtcblxuICBtb3VudEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX3VwZGF0ZVN0YXRlID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF91cGRhdGVTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX3VwZGF0ZVN0YXRlWzFdO1xuXG4gIHVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfcmVyZW5kZXJTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSB7fTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzZXRQZW5kaW5nLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoaGlnaGVyRXZlbnRQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5LCBDb250aW51b3VzRXZlbnRQcmlvcml0eSkpO1xuICBzZXRQZW5kaW5nKHRydWUpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHt9O1xuICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICB2YXIgX21vdW50U3RhdGUyID0gbW91bnRTdGF0ZShmYWxzZSksXG4gICAgICBpc1BlbmRpbmcgPSBfbW91bnRTdGF0ZTJbMF0sXG4gICAgICBzZXRQZW5kaW5nID0gX21vdW50U3RhdGUyWzFdOyAvLyBUaGUgYHN0YXJ0YCBtZXRob2QgbmV2ZXIgY2hhbmdlcy5cblxuXG4gIHZhciBzdGFydCA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKG51bGwsIHNldFBlbmRpbmcpO1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXJ0O1xuICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICB2YXIgX3VwZGF0ZVN0YXRlMiA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGUyWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUyID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGUyWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxudmFyIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpIHtcbiAge1xuICAgIHJldHVybiBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTsgLy8gVE9ETzogSW4gRml6eiwgaWQgZ2VuZXJhdGlvbiBpcyBzcGVjaWZpYyB0byBlYWNoIHNlcnZlciBjb25maWcuIE1heWJlIHdlXG4gIC8vIHNob3VsZCBkbyB0aGlzIGluIEZpYmVyLCB0b28/IERlZmVycmluZyB0aGlzIGRlY2lzaW9uIGZvciBub3cgYmVjYXVzZVxuICAvLyB0aGVyZSdzIG5vIG90aGVyIHBsYWNlIHRvIHN0b3JlIHRoZSBwcmVmaXggZXhjZXB0IGZvciBhbiBpbnRlcm5hbCBmaWVsZCBvblxuICAvLyB0aGUgcHVibGljIGNyZWF0ZVJvb3Qgb2JqZWN0LCB3aGljaCB0aGUgZmliZXIgdHJlZSBkb2VzIG5vdCBjdXJyZW50bHkgaGF2ZVxuICAvLyBhIHJlZmVyZW5jZSB0by5cblxuICB2YXIgaWRlbnRpZmllclByZWZpeCA9IHJvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgdmFyIGlkO1xuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgdmFyIHRyZWVJZCA9IGdldFRyZWVJZCgpOyAvLyBVc2UgYSBjYXB0aWFsIFIgcHJlZml4IGZvciBzZXJ2ZXItZ2VuZXJhdGVkIGlkcy5cblxuICAgIGlkID0gJzonICsgaWRlbnRpZmllclByZWZpeCArICdSJyArIHRyZWVJZDsgLy8gVW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IGlkIGF0IHRoaXMgbGV2ZWwsIGFwcGVuZCBhIG51bWJlciBhdCB0aGUgZW5kXG4gICAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIHVzZUlkIGhvb2sgYW1vbmcgYWxsIHRoZSB1c2VJZFxuICAgIC8vIGhvb2tzIGZvciB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxvY2FsSWQgPSBsb2NhbElkQ291bnRlcisrO1xuXG4gICAgaWYgKGxvY2FsSWQgPiAwKSB7XG4gICAgICBpZCArPSAnSCcgKyBsb2NhbElkLnRvU3RyaW5nKDMyKTtcbiAgICB9XG5cbiAgICBpZCArPSAnOic7XG4gIH0gZWxzZSB7XG4gICAgLy8gVXNlIGEgbG93ZXJjYXNlIHIgcHJlZml4IGZvciBjbGllbnQtZ2VuZXJhdGVkIGlkcy5cbiAgICB2YXIgZ2xvYmFsQ2xpZW50SWQgPSBnbG9iYWxDbGllbnRJZENvdW50ZXIrKztcbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAncicgKyBnbG9iYWxDbGllbnRJZC50b1N0cmluZygzMikgKyAnOic7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBpZDtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJZCgpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGlkID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlKTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSk7XG4gICAgfVxuICB9XG5cbiAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICsgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUpO1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoZmliZXIubGFuZXMgPT09IE5vTGFuZXMgJiYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCBhbHRlcm5hdGUubGFuZXMgPT09IE5vTGFuZXMpKSB7XG4gICAgICAvLyBUaGUgcXVldWUgaXMgY3VycmVudGx5IGVtcHR5LCB3aGljaCBtZWFucyB3ZSBjYW4gZWFnZXJseSBjb21wdXRlIHRoZVxuICAgICAgLy8gbmV4dCBzdGF0ZSBiZWZvcmUgZW50ZXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gSWYgdGhlIG5ldyBzdGF0ZSBpcyB0aGVcbiAgICAgIC8vIHNhbWUgYXMgdGhlIGN1cnJlbnQgc3RhdGUsIHdlIG1heSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVudGlyZWx5LlxuICAgICAgdmFyIGxhc3RSZW5kZXJlZFJlZHVjZXIgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyO1xuXG4gICAgICBpZiAobGFzdFJlbmRlcmVkUmVkdWNlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlO1xuICAgICAgICAgIHZhciBlYWdlclN0YXRlID0gbGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7IC8vIFN0YXNoIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLCBhbmQgdGhlIHJlZHVjZXIgdXNlZCB0byBjb21wdXRlXG4gICAgICAgICAgLy8gaXQsIG9uIHRoZSB1cGRhdGUgb2JqZWN0LiBJZiB0aGUgcmVkdWNlciBoYXNuJ3QgY2hhbmdlZCBieSB0aGVcbiAgICAgICAgICAvLyB0aW1lIHdlIGVudGVyIHRoZSByZW5kZXIgcGhhc2UsIHRoZW4gdGhlIGVhZ2VyIHN0YXRlIGNhbiBiZSB1c2VkXG4gICAgICAgICAgLy8gd2l0aG91dCBjYWxsaW5nIHRoZSByZWR1Y2VyIGFnYWluLlxuXG4gICAgICAgICAgdXBkYXRlLmhhc0VhZ2VyU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcblxuICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuICAgICAgICAgICAgLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbiAgICAgICAgICAgIC8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIFN1cHByZXNzIHRoZSBlcnJvci4gSXQgd2lsbCB0aHJvdyBhZ2FpbiBpbiB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICByZXR1cm4gZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIGlmIChpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyKSkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgICBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgcXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSkge1xuICBpZiAoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7IC8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXlcbiAgICAvLyBtdXN0IGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoXG4gICAgLy8gcmVwcmVzZW50cyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlXG4gICAgLy8gbWF5IGVudGFuZ2xlIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWZcbiAgICAvLyB3ZSAqZG9uJ3QqIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxuXG4gICAgcXVldWVMYW5lcyA9IGludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMsIHJvb3QucGVuZGluZ0xhbmVzKTsgLy8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cblxuICAgIHZhciBuZXdRdWV1ZUxhbmVzID0gbWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLCBsYW5lKTtcbiAgICBxdWV1ZS5sYW5lcyA9IG5ld1F1ZXVlTGFuZXM7IC8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbiAgICAvLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuICAgIC8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5cbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBuZXdRdWV1ZUxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSwgYWN0aW9uKSB7XG5cbiAge1xuICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNdXRhYmxlU291cmNlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxufTtcblxudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG5cbntcbiAgdmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5JbnZhbGlkSG9va0FjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZSgpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMiA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbnZhciBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7XG4vKipcbiAqIFRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQvY2FzY2FkaW5nIHVwZGF0ZSAoc2NoZWR1bGVkIGZyb20gYSBsYXlvdXQgZWZmZWN0KS5cbiAqXG4gKiBUaGUgb3ZlcmFsbCBzZXF1ZW5jZSBpczpcbiAqICAgMS4gcmVuZGVyXG4gKiAgIDIuIGNvbW1pdCAoYW5kIGNhbGwgYG9uUmVuZGVyYCwgYG9uQ29tbWl0YClcbiAqICAgMy4gY2hlY2sgZm9yIG5lc3RlZCB1cGRhdGVzXG4gKiAgIDQuIGZsdXNoIHBhc3NpdmUgZWZmZWN0cyAoYW5kIGNhbGwgYG9uUG9zdENvbW1pdGApXG4gKlxuICogTmVzdGVkIHVwZGF0ZXMgYXJlIGlkZW50aWZpZWQgaW4gc3RlcCAzIGFib3ZlLFxuICogYnV0IHN0ZXAgNCBzdGlsbCBhcHBsaWVzIHRvIHRoZSB3b3JrIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkLlxuICogV2UgdXNlIHR3byBmbGFncyB0byB0cmFjayBuZXN0ZWQgdXBkYXRlcyB0aGVuOlxuICogb25lIHRyYWNrcyB3aGV0aGVyIHRoZSB1cGNvbWluZyB1cGRhdGUgaXMgYSBuZXN0ZWQgdXBkYXRlLFxuICogYW5kIHRoZSBvdGhlciB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkIHVwZGF0ZS5cbiAqIFRoZSBmaXJzdCB2YWx1ZSBnZXRzIHN5bmNlZCB0byB0aGUgc2Vjb25kIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLlxuICovXG5cbnZhciBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbnZhciBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkge1xuICByZXR1cm4gY3VycmVudFVwZGF0ZUlzTmVzdGVkO1xufVxuXG5mdW5jdGlvbiBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCkge1xuICB7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKSB7XG4gIHtcbiAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jTmVzdGVkVXBkYXRlRmxhZygpIHtcbiAge1xuICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuICBjb21taXRUaW1lID0gbm93JDIoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3ckMigpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93JDIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChsYXlvdXRFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBsYXlvdXRFZmZlY3RTdGFydFRpbWU7XG4gICAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7IC8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3JcbiAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAgd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpYmVyKSB7XG5cbiAgaWYgKHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQyKCkgLSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuICAgIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAtMTsgLy8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuICAgIC8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGFjaGVkIGZpYmVycyBoYXZlIHRoZWlyIHN0YXRlIG5vZGUgY2xlYXJlZCBvdXQuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZXR1cm4gcG9pbnRlciBpcyBhbHNvIGNsZWFyZWQgb3V0LFxuICAgICAgICAgICAgLy8gc28gd2Ugd29uJ3QgYmUgYWJsZSB0byByZXBvcnQgdGhlIHRpbWUgc3BlbnQgaW4gdGhpcyBQcm9maWxlcidzIHN1YnRyZWUuXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKSB7XG5cbiAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gbm93JDIoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKSB7XG5cbiAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IG5vdyQyKCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24oZmliZXIpIHtcbiAgLy8gVHJhbnNmZXIgdGltZSBzcGVudCByZW5kZXJpbmcgdGhlc2UgY2hpbGRyZW4gc28gd2UgZG9uJ3QgbG9zZSBpdFxuICAvLyBhZnRlciB3ZSByZXJlbmRlci4gVGhpcyBpcyB1c2VkIGFzIGEgaGVscGVyIGluIHNwZWNpYWwgY2FzZXNcbiAgLy8gd2hlcmUgd2Ugc2hvdWxkIGNvdW50IHRoZSB3b3JrIG9mIG11bHRpcGxlIHBhc3Nlcy5cbiAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkKSB7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgfTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgZm9ya2VkIGluIGRpZmZlcmVudCBlbnZpcm9ubWVudHMuXG4vLyBCeSBkZWZhdWx0LCByZXR1cm4gYHRydWVgIHRvIGxvZyBlcnJvcnMgdG8gdGhlIGNvbnNvbGUuXG4vLyBGb3JrcyBjYW4gcmV0dXJuIGBmYWxzZWAgaWYgdGhpcyBpc24ndCBkZXNpcmFibGUuXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbykge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgdmFyIGxvZ0Vycm9yID0gc2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LCBlcnJvckluZm8pOyAvLyBBbGxvdyBpbmplY3RlZCBzaG93RXJyb3JEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAgIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cblxuICAgIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICBpZiAodHJ1ZSkge1xuICAgICAgdmFyIHNvdXJjZSA9IGVycm9ySW5mby5zb3VyY2U7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJyc7IC8vIEJyb3dzZXJzIHN1cHBvcnQgc2lsZW5jaW5nIHVuY2F1Z2h0IGVycm9ycyBieSBjYWxsaW5nXG4gICAgICAvLyBgcHJldmVudERlZmF1bHQoKWAgaW4gd2luZG93IGBlcnJvcmAgaGFuZGxlci5cbiAgICAgIC8vIFdlIHJlY29yZCB0aGlzIGluZm9ybWF0aW9uIGFzIGFuIGV4cGFuZG8gb24gdGhlIGVycm9yLlxuXG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCAmJiBlcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgIGlmIChib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgLy8gVGhlIGVycm9yIGlzIHJlY292ZXJhYmxlIGFuZCB3YXMgc2lsZW5jZWQuXG4gICAgICAgICAgLy8gSWdub3JlIGl0IGFuZCBkb24ndCBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4gICAgICAgICAgLy8gVGhpcyBpcyBoYW5keSBmb3IgdGVzdGluZyBlcnJvciBib3VuZGFyaWVzIHdpdGhvdXQgbm9pc2UuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFRoZSBlcnJvciBpcyBmYXRhbC4gU2luY2UgdGhlIHNpbGVuY2luZyBtaWdodCBoYXZlXG4gICAgICAgIC8vIGJlZW4gYWNjaWRlbnRhbCwgd2UnbGwgc3VyZmFjZSBpdCBhbnl3YXkuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBicm93c2VyIHdvdWxkIGhhdmUgc2lsZW5jZWQgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAgIC8vIHNvIHdlJ2xsIHByaW50IGl0IGZpcnN0LCBhbmQgdGhlbiBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG5cblxuICAgICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgICAgIC8vIEZvciBhIG1vcmUgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhpcyBibG9jaywgc2VlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IHNvdXJjZSA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoc291cmNlKSA6IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50OlwiIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG4gICAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7XG5cbiAgICAgIGlmIChib3VuZGFyeS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGJvdW5kYXJ5KSB8fCAnQW5vbnltb3VzJztcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIFwiICsgKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgKyBlcnJvckJvdW5kYXJ5TmFtZSArIFwiLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9IGNvbXBvbmVudE5hbWVNZXNzYWdlICsgXCJcXG5cIiArIGNvbXBvbmVudFN0YWNrICsgXCJcXG5cXG5cIiArIChcIlwiICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpOyAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cblxuICAgICAgY29uc29sZVsnZXJyb3InXShjb21iaW5lZE1lc3NhZ2UpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiwgd2UgcHJpbnQgdGhlIGVycm9yIGRpcmVjdGx5LlxuICAgICAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIG1lc3NhZ2UsIHRoZSBKUyBzdGFjaywgYW5kIGFueXRoaW5nIHRoZSBicm93c2VyIHdhbnRzIHRvIHNob3cuXG4gICAgICAvLyBXZSBwYXNzIHRoZSBlcnJvciBvYmplY3QgaW5zdGVhZCBvZiBjdXN0b20gbWVzc2FnZSBzbyB0aGF0IHRoZSBicm93c2VyIGRpc3BsYXlzIHRoZSBlcnJvciBuYXRpdmVseS5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgUG9zc2libHlXZWFrTWFwJDEgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIGxhbmUpOyAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuXG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBudWxsXG4gIH07XG4gIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgb25VbmNhdWdodEVycm9yKGVycm9yKTtcbiAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICB9O1xuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBlcnJvciQxID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgaWYgKGluc3QgIT09IG51bGwgJiYgdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIHtcbiAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgfVxuXG4gICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuXG4gICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvZiB3aGljaCBvbmVzIGFscmVhZHkgZmFpbGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgICAgICAvLyBUaGlzIGdldHMgcmVzZXQgYmVmb3JlIHdlIHlpZWxkIGJhY2sgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzXG4gICAgICAgIC8vIG5vdCBkZWZpbmVkLlxuICAgICAgICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAvLyBBdHRhY2ggYSBwaW5nIGxpc3RlbmVyXG4gIC8vXG4gIC8vIFRoZSBkYXRhIG1pZ2h0IHJlc29sdmUgYmVmb3JlIHdlIGhhdmUgYSBjaGFuY2UgdG8gY29tbWl0IHRoZSBmYWxsYmFjay4gT3IsXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgcmVmcmVzaCwgd2UnbGwgbmV2ZXIgY29tbWl0IGEgZmFsbGJhY2suIFNvIHdlIG5lZWQgdG9cbiAgLy8gYXR0YWNoIGEgbGlzdGVuZXIgbm93LiBXaGVuIGl0IHJlc29sdmVzIChcInBpbmdzXCIpLCB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG9cbiAgLy8gdHJ5IHJlbmRlcmluZyB0aGUgdHJlZSBhZ2Fpbi5cbiAgLy9cbiAgLy8gT25seSBhdHRhY2ggYSBsaXN0ZW5lciBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzXG4gIC8vIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4gIC8vXG4gIC8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAvLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgdmFyIHRocmVhZElEcztcblxuICBpZiAocGluZ0NhY2hlID09PSBudWxsKSB7XG4gICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwJDEoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtcblxuICAgIGlmICh0aHJlYWRJRHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRocmVhZElEcy5oYXMobGFuZXMpKSB7XG4gICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgdGhyZWFkIElEIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKTtcbiAgICB2YXIgcGluZyA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnksIHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAvLyBSZXRyeSBsaXN0ZW5lclxuICAvL1xuICAvLyBJZiB0aGUgZmFsbGJhY2sgZG9lcyBjb21taXQsIHdlIG5lZWQgdG8gYXR0YWNoIGEgZGlmZmVyZW50IHR5cGUgb2ZcbiAgLy8gbGlzdGVuZXIuIFRoaXMgb25lIHNjaGVkdWxlcyBhbiB1cGRhdGUgb24gdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IHRvIHR1cm5cbiAgLy8gdGhlIGZhbGxiYWNrIHN0YXRlIG9mZi5cbiAgLy9cbiAgLy8gU3Rhc2ggdGhlIHdha2VhYmxlIG9uIHRoZSBib3VuZGFyeSBmaWJlciBzbyB3ZSBjYW4gYWNjZXNzIGl0IGluIHRoZVxuICAvLyBjb21taXQgcGhhc2UuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIHdha2VhYmxlIHJlc29sdmVzLCB3ZSdsbCBhdHRlbXB0IHRvIHJlbmRlciB0aGUgYm91bmRhcnlcbiAgLy8gYWdhaW4gKFwicmV0cnlcIikuXG4gIHZhciB3YWtlYWJsZXMgPSBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh3YWtlYWJsZXMgPT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgdXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWU7XG4gIH0gZWxzZSB7XG4gICAgd2FrZWFibGVzLmFkZCh3YWtlYWJsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBBIGxlZ2FjeSBtb2RlIFN1c3BlbnNlIHF1aXJrLCBvbmx5IHJlbGV2YW50IHRvIGhvb2sgY29tcG9uZW50cy5cblxuXG4gIHZhciB0YWcgPSBzb3VyY2VGaWJlci50YWc7XG5cbiAgaWYgKChzb3VyY2VGaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgKHRhZyA9PT0gRnVuY3Rpb25Db21wb25lbnQgfHwgdGFnID09PSBGb3J3YXJkUmVmIHx8IHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCkpIHtcbiAgICB2YXIgY3VycmVudFNvdXJjZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50U291cmNlKSB7XG4gICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IGN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7XG4gICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gY3VycmVudFNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICAgICAgc291cmNlRmliZXIubGFuZXMgPSBjdXJyZW50U291cmNlLmxhbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpIHtcbiAgdmFyIG5vZGUgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gLy8gVGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGR1cmluZyB0aGlzIHJlbmRlci4gQ29udGludWUgdG8gdGhlIG5leHRcbiAgICAvLyBib3VuZGFyeS5cblxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgbWFya3MgYSBTdXNwZW5zZSBib3VuZGFyeSBzbyB0aGF0IHdoZW4gd2UncmUgdW53aW5kaW5nIHRoZSBzdGFjayxcbiAgLy8gaXQgY2FwdHVyZXMgdGhlIHN1c3BlbmRlZCBcImV4Y2VwdGlvblwiIGFuZCBkb2VzIGEgc2Vjb25kIChmYWxsYmFjaykgcGFzcy5cbiAgaWYgKChzdXNwZW5zZUJvdW5kYXJ5Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIC8vIExlZ2FjeSBNb2RlIFN1c3BlbnNlXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgaW4gbGVnYWN5IG1vZGUsIHdlIHNob3VsZCAqbm90KlxuICAgIC8vIHN1c3BlbmQgdGhlIGNvbW1pdC4gUHJldGVuZCBhcyBpZiB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudCByZW5kZXJlZFxuICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBXaGVuIHRoZSBTdXNwZW5zZSBib3VuZGFyeSBjb21wbGV0ZXMsXG4gICAgLy8gd2UnbGwgZG8gYSBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLlxuICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ID09PSByZXR1cm5GaWJlcikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZXJlIHdlIHN1c3BlbmRlZCB3aGlsZSByZWNvbmNpbGluZyB0aGUgY2hpbGRyZW4gb2ZcbiAgICAgIC8vIGEgU3VzcGVuc2UgYm91bmRhcnkncyBpbm5lciBPZmZzY3JlZW4gd3JhcHBlciBmaWJlci4gVGhpcyBoYXBwZW5zXG4gICAgICAvLyB3aGVuIGEgUmVhY3QubGF6eSBjb21wb25lbnQgaXMgYSBkaXJlY3QgY2hpbGQgb2YgYVxuICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcnkuXG4gICAgICAvL1xuICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgaW1wbGVtZW50ZWQgYXMgbXVsdGlwbGUgZmliZXJzLCBidXQgdGhleVxuICAgICAgLy8gYXJlIGEgc2luZ2xlIGNvbmNlcHR1YWwgdW5pdC4gVGhlIGxlZ2FjeSBtb2RlIGJlaGF2aW9yIHdoZXJlIHdlXG4gICAgICAvLyBwcmV0ZW5kIHRoZSBzdXNwZW5kZWQgZmliZXIgY29tbWl0dGVkIGFzIGBudWxsYCB3b24ndCB3b3JrLFxuICAgICAgLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UgdGhlIFwic3VzcGVuZGVkXCIgZmliZXIgaXMgdGhlIGlubmVyXG4gICAgICAvLyBPZmZzY3JlZW4gd3JhcHBlci5cbiAgICAgIC8vXG4gICAgICAvLyBCZWNhdXNlIHRoZSBjb250ZW50cyBvZiB0aGUgYm91bmRhcnkgaGF2ZW4ndCBzdGFydGVkIHJlbmRlcmluZ1xuICAgICAgLy8geWV0IChpLmUuIG5vdGhpbmcgaW4gdGhlIHRyZWUgaGFzIHBhcnRpYWxseSByZW5kZXJlZCkgd2UgY2FuXG4gICAgICAvLyBzd2l0Y2ggdG8gdGhlIHJlZ3VsYXIsIGNvbmN1cnJlbnQgbW9kZSBiZWhhdmlvcjogbWFyayB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHdpdGggU2hvdWxkQ2FwdHVyZSBhbmQgZW50ZXIgdGhlIHVud2luZCBwaGFzZS5cbiAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgc291cmNlRmliZXIuZmxhZ3MgfD0gRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZTsgLy8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0IGNvbXBsZXRlLlxuICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgLy8gYWxsIGxpZmVjeWNsZSBlZmZlY3QgdGFncy5cblxuICAgICAgc291cmNlRmliZXIuZmxhZ3MgJj0gfihMaWZlY3ljbGVFZmZlY3RNYXNrIHwgSW5jb21wbGV0ZSk7XG5cbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlICYmIGVuYWJsZVBlcnNpc3RlbnRPZmZzY3JlZW5Ib3N0Q29udGFpbmVyKSB7XG4gICAgICAgIC8vIEFub3RoZXIgbGVnYWN5IFN1c3BlbnNlIHF1aXJrLiBJbiBwZXJzaXN0ZW50IG1vZGUsIGlmIHRoaXMgaXMgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgbW91bnQsIG92ZXJyaWRlIHRoZSBwcm9wcyBvZiB0aGUgaG9zdCBjb250YWluZXIgdG8gaGlkZVxuICAgICAgICAvLyBpdHMgY29udGVudHMuXG4gICAgICAgIHZhciBjdXJyZW50U3VzcGVuc2VCb3VuZGFyeSA9IHN1c3BlbnNlQm91bmRhcnkuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChjdXJyZW50U3VzcGVuc2VCb3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvZmZzY3JlZW5GaWJlciA9IHN1c3BlbnNlQm91bmRhcnkuY2hpbGQ7XG4gICAgICAgICAgdmFyIG9mZnNjcmVlbkNvbnRhaW5lciA9IG9mZnNjcmVlbkZpYmVyLmNoaWxkO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlbkNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gb2Zmc2NyZWVuQ29udGFpbmVyLm1lbW9pemVkUHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUHJvcHMgPSBnZXRPZmZzY3JlZW5Db250YWluZXJQcm9wcygnaGlkZGVuJywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGFpbmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRhaW5lclByb3BzO1xuICAgICAgICAgICAgb2Zmc2NyZWVuQ29udGFpbmVyLm1lbW9pemVkUHJvcHMgPSBjb250YWluZXJQcm9wcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTb3VyY2VGaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAoY3VycmVudFNvdXJjZUZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbiAgICAgICAgICAvLyBjb21wbGV0ZWQgY2xhc3MgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgd2Ugc2hvdWxkIG5vdCBjYWxsXG4gICAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgaWYgaXQgaXMgZGVsZXRlZC5cbiAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSB0cnkgcmVuZGVyaW5nIGFnYWluLCB3ZSBzaG91bGQgbm90IHJldXNlIHRoZSBjdXJyZW50IGZpYmVyLFxuICAgICAgICAgIC8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGRhdGUgdG9cbiAgICAgICAgICAvLyBwcmV2ZW50IGEgYmFpbCBvdXQuXG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgU3luY0xhbmUpO1xuICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKHNvdXJjZUZpYmVyLCB1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgIC8vIGluZGljYXRlIHRoYXQgaXQgc3RpbGwgaGFzIHBlbmRpbmcgd29yay5cblxuXG4gICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbiAgfSAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gQ29udGludWVcbiAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgLy9cbiAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgLy9cbiAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgLy9cbiAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gIC8vXG4gIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgLy9cbiAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gIC8vXG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAvL1xuICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gIC8vXG4gIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlOyAvLyBUT0RPOiBJIHRoaW5rIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2Ugbm93IHVzZSBgRGlkQ2FwdHVyZWAgaW5cbiAgLy8gdGhlIGJlZ2luIHBoYXNlIHRvIHByZXZlbnQgYW4gZWFybHkgYmFpbG91dC5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB3YWtlYWJsZS4gVGhlIGNvbXBvbmVudCBzdXNwZW5kZWQuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG4gICAgcmVzZXRTdXNwZW5kZWRDb21wb25lbnQoc291cmNlRmliZXIpO1xuXG5cbiAgICB2YXIgc3VzcGVuc2VCb3VuZGFyeSA9IGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKTtcblxuICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAgICAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuXG4gICAgICBpZiAoc3VzcGVuc2VCb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBhdHRhY2hSZXRyeUxpc3RlbmVyKHN1c3BlbnNlQm91bmRhcnksIHJvb3QsIHdha2VhYmxlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gYm91bmRhcnkgd2FzIGZvdW5kLiBVbmxlc3MgdGhpcyBpcyBhIHN5bmMgdXBkYXRlLCB0aGlzIGlzIE9LLlxuICAgICAgLy8gV2UgY2FuIHN1c3BlbmQgYW5kIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG4gICAgICBpZiAoIWluY2x1ZGVzU3luY0xhbmUocm9vdFJlbmRlckxhbmVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIHN5bmMgdXBkYXRlLiBTdXNwZW5kLiBTaW5jZSB3ZSdyZSBub3QgYWN0aXZhdGluZyBhXG4gICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGlzIHdpbGwgdW53aW5kIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IHdpdGhvdXRcbiAgICAgICAgLy8gcGVyZm9ybWluZyBhIHNlY29uZCBwYXNzIHRvIHJlbmRlciBhIGZhbGxiYWNrLiAoVGhpcyBpcyBhcmd1YWJseSBob3dcbiAgICAgICAgLy8gcmVmcmVzaCB0cmFuc2l0aW9ucyBzaG91bGQgd29yaywgdG9vLCBzaW5jZSB3ZSdyZSBub3QgZ29pbmcgdG8gY29tbWl0XG4gICAgICAgIC8vIHRoZSBmYWxsYmFja3MgYW55d2F5LilcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBjYXNlIGFsc28gYXBwbGllcyB0byBpbml0aWFsIGh5ZHJhdGlvbi5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGhpcyBpcyBhIHN5bmMvZGlzY3JldGUgdXBkYXRlLiBXZSB0cmVhdCB0aGlzIGNhc2UgbGlrZSBhbiBlcnJvclxuICAgICAgLy8gYmVjYXVzZSBkaXNjcmV0ZSByZW5kZXJzIGFyZSBleHBlY3RlZCB0byBwcm9kdWNlIGEgY29tcGxldGUgdHJlZVxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoIGV4dGVybmFsIHN0YXRlLlxuXG5cbiAgICAgIHZhciB1bmNhdWdodFN1c3BlbnNlRXJyb3IgPSBuZXcgRXJyb3IoJ0EgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZXNwb25kaW5nIHRvIHN5bmNocm9ub3VzIGlucHV0LiBUaGlzICcgKyAnd2lsbCBjYXVzZSB0aGUgVUkgdG8gYmUgcmVwbGFjZWQgd2l0aCBhIGxvYWRpbmcgaW5kaWNhdG9yLiBUbyAnICsgJ2ZpeCwgdXBkYXRlcyB0aGF0IHN1c3BlbmQgc2hvdWxkIGJlIHdyYXBwZWQgJyArICd3aXRoIHN0YXJ0VHJhbnNpdGlvbi4nKTsgLy8gSWYgd2UncmUgb3V0c2lkZSBhIHRyYW5zaXRpb24sIGZhbGwgdGhyb3VnaCB0byB0aGUgcmVndWxhciBlcnJvciBwYXRoLlxuICAgICAgLy8gVGhlIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IHN1c3BlbnNlIGJvdW5kYXJ5LlxuXG4gICAgICB2YWx1ZSA9IHVuY2F1Z2h0U3VzcGVuc2VFcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IsIG5vdCBhIFN1c3BlbnNlIHdha2VhYmxlLlxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIHNvdXJjZUZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgbWFya0RpZFN1c3BlbmRXaGlsZUh5ZHJhdGluZ0RFVigpO1xuXG4gICAgICB2YXIgX3N1c3BlbnNlQm91bmRhcnkgPSBnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcik7IC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGR1cmluZyBoeWRyYXRpb24sIHdlIG1heSBiZSBhYmxlIHRvIHJlY292ZXIgYnlcbiAgICAgIC8vIGRpc2NhcmRpbmcgdGhlIGRlaHlkcmF0ZWQgY29udGVudCBhbmQgc3dpdGNoaW5nIHRvIGEgY2xpZW50IHJlbmRlci5cbiAgICAgIC8vIEluc3RlYWQgb2Ygc3VyZmFjaW5nIHRoZSBlcnJvciwgZmluZCB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuICAgICAgLy8gYW5kIHJlbmRlciBpdCBhZ2FpbiB3aXRob3V0IGh5ZHJhdGlvbi5cblxuXG4gICAgICBpZiAoX3N1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKChfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmIFNob3VsZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgLy8gU2V0IGEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHdlIHNob3VsZCB0cnkgcmVuZGVyaW5nIHRoZSBub3JtYWxcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhZ2Fpbiwgbm90IHRoZSBmYWxsYmFjay5cbiAgICAgICAgICBfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShfc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpOyAvLyBFdmVuIHRob3VnaCB0aGUgdXNlciBtYXkgbm90IGJlIGFmZmVjdGVkIGJ5IHRoaXMgZXJyb3IsIHdlIHNob3VsZFxuICAgICAgICAvLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxuXG4gICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG5cbiAgcmVuZGVyRGlkRXJyb3IodmFsdWUpO1xuICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG5cbiAgZG8ge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF9lcnJvckluZm8sIGxhbmUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cbiAgICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBfbGFuZSk7IC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuXG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgc3VzcGVuZHMuIEl0IHJldHVybnMgdGhlXG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAvLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmU3RhdGljO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhZE5vTXV0YXRpb25zRWZmZWN0cyhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKSB7XG4gIHZhciBkaWRCYWlsb3V0ID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gIGlmIChkaWRCYWlsb3V0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUT0RPOiBJZiB3ZSBtb3ZlIHRoZSBgaGFkTm9NdXRhdGlvbnNFZmZlY3RzYCBjYWxsIGFmdGVyIGBidWJibGVQcm9wZXJ0aWVzYFxuICAvLyB0aGVuIHdlIG9ubHkgaGF2ZSB0byBjaGVjayB0aGUgYGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzYC5cblxuXG4gIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgaWYgKChjaGlsZC5mbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MgfHwgKGNoaWxkLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGFwcGVuZEFsbENoaWxkcmVuO1xudmFyIHVwZGF0ZUhvc3RDb250YWluZXI7XG52YXIgdXBkYXRlSG9zdENvbXBvbmVudDtcbnZhciB1cGRhdGVIb3N0VGV4dDtcblxuaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgLy8gTXV0YXRpb24gbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykgey8vIE5vb3BcbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgLy8gUGVyc2lzdGVudCBob3N0IHRyZWUgbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHRleHQgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgX2luc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoX2luc3RhbmNlLCB0ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIF9pbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIG5vZGUsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vICRGbG93Rml4TWUgVGhpcyBpcyBjb3JyZWN0IGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBsYWJlbGVkIGJyZWFrLlxuXG5cbiAgICAgIG5vZGUgPSBub2RlO1xuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9OyAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cblxuXG4gIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHByb3BzID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMiA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcbiAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuICAgICAgICAgIHZhciB0ZXh0ID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIF9pbnN0YW5jZTIgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShfaW5zdGFuY2UyLCB0ZXh0LCBub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgX2luc3RhbmNlMik7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKGNvbnRhaW5lckNoaWxkU2V0LCBub2RlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgY29ycmVjdCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgbGFiZWxlZCBicmVhay5cblxuXG4gICAgICBub2RlID0gbm9kZTtcblxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSBoYWROb011dGF0aW9uc0VmZmVjdHMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSA7IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTsgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuXG4gICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDsgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gaGFkTm9NdXRhdGlvbnNFZmZlY3RzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiBvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUocmVjeWNsYWJsZUluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuXG4gICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcblxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7Ly8gTm9vcFxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb21wb25lbnQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHsvLyBOb29wXG4gIH07XG5cbiAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHsvLyBOb29wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgLy8gSWYgd2UncmUgaHlkcmF0aW5nLCB3ZSBzaG91bGQgY29uc3VtZSBhcyBtYW55IGl0ZW1zIGFzIHdlIGNhblxuICAgIC8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAodGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSB0YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAobGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbGxhcHNlZCc6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgX3RhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChfdGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoX3RhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2xhc3RUYWlsTm9kZSA9IF90YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGFpbE5vZGUgPSBfdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChfbGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICBpZiAoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayAmJiByZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBzdXNwZW5kZWQgZHVyaW5nIHRoZSBoZWFkLiBXZSB3YW50IHRvIHNob3cgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICAvLyByb3cgYXQgdGhlIHRhaWwuIFNvIHdlJ2xsIGtlZXAgb24gYW5kIGN1dCBvZmYgdGhlIHJlc3QuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgX2xhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuXG4gIGlmICghZGlkQmFpbG91dCkge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoY2hpbGQubGFuZXMsIGNoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcbiAgICAgICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgICAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcbiAgICAgICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cblxuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5mbGFnczsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuICAgICAgICAvLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cbiAgICAgICAgX2NoaWxkLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgfSBlbHNlIHtcbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDIgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLCBfY2hpbGQyLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jaGlsZDMgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkMyAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsIF9jaGlsZDMuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuZmxhZ3MgJiBTdGF0aWNNYXNrOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4gICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cblxuICAgICAgICBfY2hpbGQzLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZDMgPSBfY2hpbGQzLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgcmV0dXJuIGRpZEJhaWxvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cblxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2NoZWR1bGUgYW4gdXBkYXRlIGZvclxuICAgICAgICAgICAgLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjbGllbnQgcm9vdFxuICAgICAgICAgICAgICAhcHJldlN0YXRlLmlzRGVoeWRyYXRlZCB8fCAvLyBDaGVjayBpZiB3ZSByZXZlcnRlZCB0byBjbGllbnQgcmVuZGVyaW5nIChlLmcuIGR1ZSB0byBhbiBlcnJvcilcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGNvbW1pdC4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGFcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi4gSXQncyBhbHNvIHNhZmUgdG8gZG8gZm9yXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGwgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcmVuZGVyIHdhcyBudWxsIChzbyB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBiZSBlbXB0eSkuXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7IC8vIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsIHRoZXJlIG1heSBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvbiBhdHRlbXB0LiBJZiBzbywgYWRkXG4gICAgICAgICAgICAgICAgLy8gdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGUgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICAgICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWQgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkgJiYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2Rlcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlciB8IEluY29tcGxldGUgfCBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0U3RhdGUgIT09IG51bGwgJiYgbmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIGluc2lkZSBhIGh5ZHJhdGlvbiBzdGF0ZSB0aGUgZmlyc3QgdGltZSB3ZSdyZSBwaWNraW5nIHVwIHRoaXNcbiAgICAgICAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCBhbmQgYWxzbyBhZnRlciB3ZSd2ZSByZWVudGVyZWQgaXQgZm9yIGZ1cnRoZXIgaHlkcmF0aW9uLlxuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDMgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICghX3dhc0h5ZHJhdGVkMykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHJlZW50ZXJlZCB0aGlzIGJvdW5kYXJ5IHRvIGh5ZHJhdGUgaXQuIElmIHNvLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBoeWRyYXRpb25cbiAgICAgICAgICAgICAgLy8gc3RhdGUgc2luY2Ugd2UncmUgbm93IGV4aXRpbmcgb3V0IG9mIGl0LiBwb3BIeWRyYXRpb25TdGF0ZSBkb2Vzbid0IGRvIHRoYXQgZm9yIHVzLlxuICAgICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBkaWQgbm90IHN1c3BlbmQgc28gaXQncyBub3cgaHlkcmF0ZWQgYW5kIHVuc3VzcGVuZGVkLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbiAgICAgICAgICAgICAgLy8gYXMgaGF2aW5nIGh5ZHJhdGVkIHNvIGV2ZW50cyBrbm93IHRoYXQgdGhleSdyZSBmcmVlIHRvIGJlIGludm9rZWQuXG4gICAgICAgICAgICAgIC8vIEl0J3MgYWxzbyBhIHNpZ25hbCB0byByZXBsYXkgZXZlbnRzIGFuZCB0aGUgc3VzcGVuc2UgY2FsbGJhY2suXG4gICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSBtaWdodCBhcyB3ZWxsIGFsd2F5cyBtYXJrIHRoaXMuXG5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9pc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB0aGlzIHRyZWUuIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsXG4gICAgICAgICAgLy8gdGhlcmUgbWF5IGhhdmUgYmVlbiByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvblxuICAgICAgICAgIC8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuXG5cblxuICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lczsgLy8gRG8gbm90IHJlc2V0IHRoZSBlZmZlY3QgbGlzdC5cblxuICAgICAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcHJldkRpZFRpbWVvdXQgPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFuIGVmZmVjdCB0byB0b2dnbGUgdGhlIHN1YnRyZWUncyB2aXNpYmlsaXR5LiBXaGVuIHdlIHN3aXRjaCBmcm9tXG4gICAgICAgIC8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG4gICAgICAgIC8vIGFzIHBhcnQgb2YgaXRzIG5vcm1hbCBjb21wbGV0ZSBwaGFzZS4gQnV0IHdoZW4gd2Ugc3dpdGNoIGZyb21cbiAgICAgICAgLy8gcHJpbWFyeSAtPiBmYWxsYmFjaywgdGhlIGlubmVyIE9mZnNjcmVlbiBmaWJlciBkb2VzIG5vdCBoYXZlIGEgY29tcGxldGVcbiAgICAgICAgLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGlzIGZsYWcgdG8gY29ubmVjdC9kaXNjb25uZWN0IHRoZSBlZmZlY3RzLCBidXQgdGhlIHNhbWVcbiAgICAgICAgLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcbiAgICAgICAgLy8gcGhhc2Ugd2lsbCBoYW5kbGUgc2NoZWR1bGluZyB0aGUgZWZmZWN0LiBJdCdzIG9ubHkgd2hlbiB0aGUgZmFsbGJhY2tcbiAgICAgICAgLy8gaXMgYWN0aXZlIHRoYXQgd2UgaGF2ZSB0byBkbyBhbnl0aGluZyBzcGVjaWFsLlxuXG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICYmICFwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIHZhciBfb2Zmc2NyZWVuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBfb2Zmc2NyZWVuRmliZXIuZmxhZ3MgfD0gVmlzaWJpbGl0eTsgLy8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG4gICAgICAgICAgLy8gaW4gdGhlIGNvbmN1cnJlbnQgdHJlZSBhbHJlYWR5IHN1c3BlbmRlZCBkdXJpbmcgdGhpcyByZW5kZXIuXG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGtub3duIGJ1Zy5cblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUgfHwgIWVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2spO1xuXG4gICAgICAgICAgICBpZiAoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IHx8IGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgaW4gYW4gaW52aXNpYmxlIHRyZWUgb3IgYSBuZXcgcmVuZGVyLCB0aGVuIHNob3dpbmdcbiAgICAgICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBpcyBvay5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGhpZGUgY29udGVudCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdha2VhYmxlcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIGEgcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuXG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gU2FtZSBhcyBjbGFzcyBjb21wb25lbnQgY2FzZS4gSSBwdXQgaXQgZG93biBoZXJlIHNvIHRoYXQgdGhlIHRhZ3MgYXJlXG4gICAgICAgIC8vIHNlcXVlbnRpYWwgdG8gZW5zdXJlIHRoaXMgc3dpdGNoIGlzIGNvbXBpbGVkIHRvIGEganVtcCB0YWJsZS5cbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZFN1c3BlbmRBbHJlYWR5ID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbm5vdEJlU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4gICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGl0cyB0aGVuYWJsZXMuIEluc3RlYWQsIHdlJ2xsIHRyYW5zZmVyIGl0cyB0aGVuYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbmFibGVzID0gc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbmV3VGhlbmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJlZm9yZSBkb2luZyB0aGUgc2Vjb25kIHBhc3Mgc2luY2UgdGhhdCdzIG5vdyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTsgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwgJiYgbm93JDEoKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICB9IC8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSByZW5kZXJlZCByb3cgdG8gdGhlIGNoaWxkIGxpc3QuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgdmFyIF9zdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocmVuZGVyZWRUYWlsKTtcblxuICAgICAgICAgICAgaWYgKF9zdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlOyAvLyBFbnN1cmUgd2UgdHJhbnNmZXIgdGhlIHVwZGF0ZSBxdWV1ZSB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBnZXQgbG9zdCBpZiB0aGlzIHJvdyBlbmRzIHVwIGRyb3BwZWQgZHVyaW5nIGEgc2Vjb25kIHBhc3MuXG5cbiAgICAgICAgICAgICAgdmFyIF9uZXdUaGVuYWJsZXMgPSBfc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgIGlmIChfbmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfbmV3VGhlbmFibGVzO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgdHJ1ZSk7IC8vIFRoaXMgbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuXG4gICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsID09PSBudWxsICYmIHJlbmRlclN0YXRlLnRhaWxNb2RlID09PSAnaGlkZGVuJyAmJiAhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSAmJiAhZ2V0SXNIeWRyYXRpbmcoKSAvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93JDEoKSAqIDIgLSByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkgJiYgcmVuZGVyTGFuZXMgIT09IE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBvZiB0aGUgYmFja3dhcmRzIHRhaWwgd2lsbCBoYXZlIGJlZW4gYWRkZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBlbmQuIFRoaXMgYnJlYWtzIHRoZSBndWFyYW50ZWUgdGhhdCBsaWZlLWN5Y2xlcyBmaXJlIGluXG4gICAgICAgICAgICAvLyBzaWJsaW5nIG9yZGVyIGJ1dCB0aGF0IGlzbid0IGEgc3Ryb25nIGd1YXJhbnRlZSBwcm9taXNlZCBieSBSZWFjdC5cbiAgICAgICAgICAgIC8vIEVzcGVjaWFsbHkgc2luY2UgdGhlc2UgbWlnaHQgYWxzbyBqdXN0IHBvcCBpbiBkdXJpbmcgZnV0dXJlIGNvbW1pdHMuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJlbmRlcmVkVGFpbC5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHJlbmRlclN0YXRlLmxhc3Q7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyU3RhdGUubGFzdCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIHN0aWxsIGhhdmUgdGFpbCByb3dzIHRvIHJlbmRlci5cbiAgICAgICAgICAvLyBQb3AgYSByb3cuXG4gICAgICAgICAgdmFyIG5leHQgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG5leHQ7XG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG5leHQuc2libGluZztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3ckMSgpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIG5leHRJc0hpZGRlbiA9IF9uZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX3ByZXZTdGF0ZTIgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUyICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmICggLy8gTGVnYWN5SGlkZGVuIGRvZXNuJ3QgZG8gYW55IGhpZGluZyDigJQgaXQgb25seSBwcmUtcmVuZGVycy5cbiAgICAgICAgICAhZW5hYmxlTGVnYWN5SGlkZGVuICkpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXh0SXNIaWRkZW4gfHwgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGZvciBoaWRkZW4gY2hpbGRyZW4gdW5sZXNzIHdlJ3JlIHJlbmRlcmluZ1xuICAgICAgICAgIC8vIGF0IG9mZnNjcmVlbiBwcmlvcml0eS5cbiAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGFuIGluc2VydGlvbiBvciB1cGRhdGUgaW4gdGhlIGhpZGRlbiBzdWJ0cmVlLlxuICAgICAgICAgICAgICAvLyBJZiBzbywgd2UgbmVlZCB0byBoaWRlIHRob3NlIG5vZGVzIGluIHRoZSBjb21taXQgcGhhc2UsIHNvXG4gICAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgdmlzaWJpbGl0eSBlZmZlY3QuXG4gICAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSwgbnVsbCwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MubW9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIGNoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHtcbiAgICB2YXIgX3R5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICB2YXIgX2lubmVyUHJvcFR5cGVzID0gX3R5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKF9pbm5lclByb3BUeXBlcykge1xuICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICBjaGVja1Byb3BUeXBlcyhfaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBvdXRlck1lbW9UeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG5cbiAgICAgIGlmIChvdXRlck1lbW9UeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgLy8gV2Ugd2FybiB3aGVuIHlvdSBkZWZpbmUgcHJvcFR5cGVzIG9uIGxhenkoKVxuICAgICAgICAvLyBzbyBsZXQncyBqdXN0IHNraXAgb3ZlciBpdCB0byBmaW5kIG1lbW8oKSBvdXRlciB3cmFwcGVyLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBmb3IgbWVtbyBhcmUgdmFsaWRhdGVkIGxhdGVyLlxuICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IG91dGVyTWVtb1R5cGU7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gbnVsbDtcbiAgICAgICAgfSAvLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxuXG5cbiAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gb3V0ZXJNZW1vVHlwZSAmJiBvdXRlck1lbW9UeXBlLnByb3BUeXBlcztcblxuICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IChpLmUuIHdoZW4gcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlKS4gQnV0IHNpbmNlIHNpbmNlXG4gICAgICAgIC8vIHdlJ3JlIGJhaWxpbmcgb3V0IGVhcmx5ICp3aXRob3V0KiBldmFsdWF0aW5nIHRoZSBjb21wb25lbnQsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgaXQgaGVyZSwgdG9vLiBSZXNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgZmliZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgb25seSBhcHBsaWVzIHRvIFNpbXBsZU1lbW9Db21wb25lbnQsIG5vdCBNZW1vQ29tcG9uZW50LFxuICAgICAgICAvLyBiZWNhdXNlIGEgTWVtb0NvbXBvbmVudCBmaWJlciBkb2VzIG5vdCBoYXZlIGhvb2tzIG9yIGFuIHVwZGF0ZSBxdWV1ZTtcbiAgICAgICAgLy8gcmF0aGVyLCBpdCB3cmFwcyBhcm91bmQgYW4gaW5uZXIgY29tcG9uZW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAvLyBjb250YWlucyBob29rcy5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGUgcmVzZXQgYXQgaW4gYmVnaW5Xb3JrIG91dCBvZiB0aGUgY29tbW9uIHBhdGggc28gdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJldlN0YXRlID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG5cbiAgaWYgKG5leHRQcm9wcy5tb2RlID09PSAnaGlkZGVuJyB8fCBlbmFibGVMZWdhY3lIaWRkZW4gKSB7XG4gICAgLy8gUmVuZGVyaW5nIGEgaGlkZGVuIHRyZWUuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IG51bGxcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuICAgICAgdmFyIHNwYXduZWRDYWNoZVBvb2wgPSBudWxsOyAvLyBXZSdyZSBoaWRkZW4sIGFuZCB3ZSdyZSBub3QgcmVuZGVyaW5nIGF0IE9mZnNjcmVlbi4gV2Ugd2lsbCBiYWlsIG91dFxuICAgICAgLy8gYW5kIHJlc3VtZSB0aGlzIHRyZWUgbGF0ZXIuXG5cbiAgICAgIHZhciBuZXh0QmFzZUxhbmVzO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2QmFzZUxhbmVzID0gcHJldlN0YXRlLmJhc2VMYW5lcztcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IG1lcmdlTGFuZXMocHJldkJhc2VMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgICAgfSAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cblxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgICAgIHZhciBfbmV4dFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogc3Bhd25lZENhY2hlUG9vbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgLy8gdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cblxuICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBuZXh0QmFzZUxhbmVzKTtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIuIFRoZSBzdXJyb3VuZGluZyB2aXNpYmxlIGNvbnRlbnQgaGFzIGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gTm93IHdlIHJlc3VtZSByZW5kZXJpbmcgdGhlIGhpZGRlbiB0cmVlLlxuICAgICAgLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxuICAgICAgdmFyIF9uZXh0U3RhdGUyID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXMsXG4gICAgICAgIGNhY2hlUG9vbDogbnVsbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlMjsgLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG4gICAgICB2YXIgc3VidHJlZVJlbmRlckxhbmVzID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmJhc2VMYW5lcyA6IHJlbmRlckxhbmVzO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cbiAgICB2YXIgX3N1YnRyZWVSZW5kZXJMYW5lcztcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyk7XG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHdlcmVuJ3QgcHJldmlvdXNseSBoaWRkZW4sIGFuZCB3ZSBzdGlsbCBhcmVuJ3QsIHNvIHRoZXJlJ3Mgbm90aGluZ1xuICAgICAgLy8gc3BlY2lhbCB0byBkby4gTmVlZCB0byBwdXNoIHRvIHRoZSBzdGFjayByZWdhcmRsZXNzLCB0aG91Z2gsIHRvIGF2b2lkXG4gICAgICAvLyBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cbiAgICAgIF9zdWJ0cmVlUmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICB9XG5cbiAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIF9zdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICB9XG5cbiAge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG5cbiAgICB7XG4gICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1JlZiQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZlN0YXRpYztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgdmFyIGhhc0lkO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIGVycm9yLlxuICAgIHN3aXRjaCAoc2hvdWxkRXJyb3Iod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7IC8vIFRPRE8gVGhpcyB3YXkgb2YgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBzdGF0ZSBpcyBhIGhhY2suXG4gICAgICAgICAgLy8gSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/XG5cbiAgICAgICAgICB2YXIgdGVtcEluc3RhbmNlID0gbmV3IGN0b3Iod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcywgX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRlbXBJbnN0YW5jZS5zdGF0ZTtcblxuICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblxuICAgICAgICAgIHZhciBlcnJvciQxID0gbmV3IEVycm9yKCdTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHMnKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yJDEsIHdvcmtJblByb2dyZXNzKSwgbGFuZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLWNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVhdCBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gICAgfSAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cblxuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ2EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0VW5pdE9mV29yaztcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcykge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmJDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZS5lbGVtZW50O1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uICYmIHByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAvLyBUaGlzIGlzIGEgaHlkcmF0aW9uIHJvb3Qgd2hvc2Ugc2hlbGwgaGFzIG5vdCB5ZXQgaHlkcmF0ZWQuIFdlIHNob3VsZFxuICAgIC8vIGF0dGVtcHQgdG8gaHlkcmF0ZS5cbiAgICAvLyBGbGlwIGlzRGVoeWRyYXRlZCB0byBmYWxzZSB0byBpbmRpY2F0ZSB0aGF0IHdoZW4gdGhpcyByZW5kZXJcbiAgICAvLyBmaW5pc2hlcywgdGhlIHJvb3Qgd2lsbCBubyBsb25nZXIgYmUgZGVoeWRyYXRlZC5cbiAgICB2YXIgb3ZlcnJpZGVTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IG5leHRDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogZmFsc2UsXG4gICAgICBjYWNoZTogbmV4dFN0YXRlLmNhY2hlLFxuICAgICAgdHJhbnNpdGlvbnM6IG5leHRTdGF0ZS50cmFuc2l0aW9uc1xuICAgIH07XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIGBiYXNlU3RhdGVgIGNhbiBhbHdheXMgYmUgdGhlIGxhc3Qgc3RhdGUgYmVjYXVzZSB0aGUgcm9vdCBkb2Vzbid0XG4gICAgLy8gaGF2ZSByZWR1Y2VyIGZ1bmN0aW9ucyBzbyBpdCBkb2Vzbid0IG5lZWQgcmViYXNpbmcuXG5cbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBhIHByZXZpb3VzIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgc2hlbGwsIHNvIHdlXG4gICAgICAvLyBmb3JjZWQgYSBjbGllbnQgcmVuZGVyLlxuICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcuIEJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbmVkIG91dHNpZGUgJyArICdvZiBhIFN1c3BlbnNlIGJvdW5kYXJ5LCB0aGUgZW50aXJlIHJvb3Qgd2lsbCBzd2l0Y2ggdG8gJyArICdjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgICAgcmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzLCByZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPT0gcHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIgX3JlY292ZXJhYmxlRXJyb3IgPSBuZXcgRXJyb3IoJ1RoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSAnICsgJ2h5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuXG4gICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIF9yZWNvdmVyYWJsZUVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG91dGVybW9zdCBzaGVsbCBoYXMgbm90IGh5ZHJhdGVkIHlldC4gU3RhcnQgaHlkcmF0aW5nLlxuICAgICAgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICAgIHZhciBub2RlID0gY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIC8vIE1hcmsgZWFjaCBjaGlsZCBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuICAgICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuICAgICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgJiB+UGxhY2VtZW50IHwgSHlkcmF0aW5nO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSb290IGlzIG5vdCBkZWh5ZHJhdGVkLiBFaXRoZXIgdGhpcyBpcyBhIGNsaWVudC1vbmx5IHJvb3QsIG9yIGl0XG4gICAgLy8gYWxyZWFkeSBoeWRyYXRlZC5cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcywgcmVjb3ZlcmFibGVFcnJvcikge1xuICAvLyBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cbiAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhcyBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQSBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTsgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG5cbiAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudDtcbiAgdmFyIHJlc29sdmVkVGFnID0gd29ya0luUHJvZ3Jlc3MudGFnID0gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcoQ29tcG9uZW50KTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICB2YXIgY2hpbGQ7XG5cbiAgc3dpdGNoIChyZXNvbHZlZFRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgcmVzb2x2ZWRQcm9wcywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVNZW1vQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LnR5cGUsIHJlc29sdmVkUHJvcHMpLCAvLyBUaGUgaW5uZXIgdHlwZSBjYW4gaGF2ZSBkZWZhdWx0cyB0b29cbiAgICAgICAgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIiArIENvbXBvbmVudCArIFwiLiBcIiArIChcIkxhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLlwiICsgaGludCkpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmNvbXBsZXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH0gLy8gUHJvbW90ZSB0aGUgZmliZXIgdG8gYSBjbGFzcyBhbmQgdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cblxuXG4gIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgZm9yayBvZiBgdXBkYXRlQ2xhc3NDb21wb25lbnRgXG4gIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgY29udGV4dDtcblxuICB7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBmYWxzZSk7XG4gICAgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciBoYXNJZDtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgIGVycm9yKCdUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50IHRoYXQgcmV0dXJucyBhIGNsYXNzIGluc3RhbmNlLiAnICsgJ0NoYW5nZSAlcyB0byBhIGNsYXNzIHRoYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4gJyArIFwiSWYgeW91IGNhbid0IHVzZSBhIGNsYXNzIHRyeSBhc3NpZ25pbmcgdGhlIHByb3RvdHlwZSBvbiB0aGUgZnVuY3Rpb24gYXMgYSB3b3JrYXJvdW5kLiBcIiArIFwiYCVzLnByb3RvdHlwZSA9IFJlYWN0LkNvbXBvbmVudC5wcm90b3R5cGVgLiBEb24ndCB1c2UgYW4gYXJyb3cgZnVuY3Rpb24gc2luY2UgaXQgXCIgKyAnY2Fubm90IGJlIGNhbGxlZCB3aXRoIGBuZXdgIGJ5IFJlYWN0LicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG5cblxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50OyAvLyBUaHJvdyBvdXQgYW55IGhvb2tzIHRoYXQgd2VyZSB1c2VkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsOyAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cbiAgICB2YXIgaGFzQ29udGV4dCA9IGZhbHNlO1xuXG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gdmFsdWUuc3RhdGUgIT09IG51bGwgJiYgdmFsdWUuc3RhdGUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnN0YXRlIDogbnVsbDtcbiAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbkNvbXBvbmVudDtcblxuICAgIHtcblxuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihudWxsLCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUsIHJlbmRlckxhbmVzKTtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuXG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cblxuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgJyc7XG4gICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG5cbiAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHVzZSBSZWFjdC5mb3J3YXJkUmVmKCk/JXMnLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgdHJlZUNvbnRleHQ6IG51bGwsXG4gIHJldHJ5TGFuZTogTm9MYW5lXG59O1xuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IHJlbmRlckxhbmVzLFxuICAgIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNhY2hlUG9vbCA9IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpLFxuICAgIGNhY2hlUG9vbDogY2FjaGVQb29sXG4gIH07XG59IC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbiAgLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbiAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEF2b2lkZWQgYm91bmRhcmllcyBhcmUgbm90IGNvbnNpZGVyZWQgc2luY2UgdGhleSBjYW5ub3QgaGFuZGxlIHByZWZlcnJlZCBmYWxsYmFjayBzdGF0ZXMuXG4gICAgICB7XG4gICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7IC8vIE9LLCB0aGUgbmV4dCBwYXJ0IGlzIGNvbmZ1c2luZy4gV2UncmUgYWJvdXQgdG8gcmVjb25jaWxlIHRoZSBTdXNwZW5zZVxuICAvLyBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGlzIGludm9sdmVzIHNvbWUgY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljLiBUd29cbiAgLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4gIC8vXG4gIC8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuICAvLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4gIC8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbiAgLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4gIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbiAgLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuICAvLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4gIC8vXG4gIC8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbiAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuICAvL1xuICAvLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbiAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4gIC8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuICAvLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4gIC8vIGEgc3RhY2suXG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuXG4gICAge1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVoeWRyYXRlZCA9IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgZGVoeWRyYXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgZmliZXIgaGFzIGEgU3VzcGVuc2VTdGF0ZSwgdGhhdCBtZWFucyBpdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgIC8vIGEgZmFsbGJhY2suXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2tcbiAgICAgIC8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG4gICAgICB7XG4gICAgICAgIHZhciBfZGVoeWRyYXRlZCA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChfZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghZGlkU3VzcGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX2RlaHlkcmF0ZWQsIHByZXZTdGF0ZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVHJ5IGFnYWluIHdpdGhvdXQgaHlkcmF0aW5nLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkZvcmNlQ2xpZW50UmVuZGVyO1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkuICcgKyAnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGFuZCB3ZSBzaG91bGQgc3RpbGwgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgICAgICAgLy8gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkIGluIHBsYWNlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGUgZGVoeWRyYXRlZCBjb21wbGV0aW9uIHBhc3MgZXhwZWN0cyB0aGlzIGZsYWcgdG8gYmUgdGhlcmVcbiAgICAgICAgICAgIC8vIGJ1dCB0aGUgbm9ybWFsIHN1c3BlbnNlIHBhc3MgZG9lc24ndC5cblxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdXNwZW5kZWQgYnV0IHdlIHNob3VsZCBubyBsb25nZXIgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5vdyBoYXZlIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbiwgX25leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTsgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICByZXR1cm4gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBoYXZlbid0IHRpbWVkIG91dC4gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZVxuICAgICAgICAvLyBub3JtYWxseSBkby5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NiA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDY7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBjb21taXQgdGhlIHByaW1hcnkgdHJlZSBhcyBpZiBpdCBzdWNjZXNzZnVsbHlcbiAgICAvLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlKTtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH1cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlXG4gIC8vIHRoaXMgd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKSB7XG4gIC8vIFRoZSBwcm9wcyBhcmd1bWVudCB0byBgY3JlYXRlV29ya0luUHJvZ3Jlc3NgIGlzIGBhbnlgIHR5cGVkLCBzbyB3ZSB1c2UgdGhpc1xuICAvLyB3cmFwcGVyIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiBpdC5cbiAgcmV0dXJuIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIG9mZnNjcmVlblByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfSk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIHZhciBkZWxldGlvbnMgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnM7XG5cbiAgICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBbY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudF07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDaGlsZERlbGV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGlvbnMucHVzaChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50KTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gIChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUgJiYgLy8gTWFrZSBzdXJlIHdlJ3JlIG9uIHRoZSBzZWNvbmQgcGFzcywgaS5lLiB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCB3YXNcbiAgLy8gYWxyZWFkeSBjbG9uZWQuIEluIGxlZ2FjeSBtb2RlLCB0aGUgb25seSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZSBpc1xuICAvLyB3aGVuIERldlRvb2xzIGZvcmNlcyB1cyB0byBkaXNwbGF5IGEgZmFsbGJhY2s7IHdlIHNraXAgdGhlIGZpcnN0IHJlbmRlclxuICAvLyBwYXNzIGVudGlyZWx5IGFuZCBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgdGhlIGZhbGxiYWNrLiAoSW4gQ29uY3VycmVudFxuICAvLyBNb2RlLCBTdXNwZW5zZUxpc3QgY2FuIGFsc28gdHJpZ2dlciB0aGlzIHNjZW5hcmlvLCBidXQgdGhpcyBpcyBhIGxlZ2FjeS1cbiAgLy8gb25seSBjb2RlcGF0aC4pXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQpIHtcbiAgICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG4gICAgLy8gSG93ZXZlciwgc2luY2Ugd2UncmUgZ29pbmcgdG8gcmVtYWluIG9uIHRoZSBmYWxsYmFjaywgd2Ugbm8gbG9uZ2VyIHdhbnRcbiAgICAvLyB0byBkZWxldGUgaXQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwgcHJpbWFyeUNoaWxkUHJvcHMpO1xuICAgIC8vIChXZSBkb24ndCBkbyB0aGlzIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGluIGxlZ2FjeSBtb2RlIHdlIGRvbid0IHJlLXVzZVxuICAgIC8vIHRoZSBjdXJyZW50IHRyZWU7IHNlZSBwcmV2aW91cyBicmFuY2guKVxuXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCByZWNvdmVyYWJsZUVycm9yKSB7XG4gIC8vIEZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLiBCZWNhdXNlIHRoaXMgaGFzIHBlcmZvcm1hbmNlXG4gIC8vIGltcGxpY2F0aW9ucywgaXQncyBjb25zaWRlcmVkIGEgcmVjb3ZlcmFibGUgZXJyb3IsIGV2ZW4gdGhvdWdoIHRoZSB1c2VyXG4gIC8vIGxpa2VseSB3b24ndCBvYnNlcnZlIGFueXRoaW5nIHdyb25nIHdpdGggdGhlIFVJLlxuICAvL1xuICAvLyBUaGUgZXJyb3IgaXMgcGFzc2VkIGluIGFzIGFuIGFyZ3VtZW50IHRvIGVuZm9yY2UgdGhhdCBldmVyeSBjYWxsZXIgcHJvdmlkZVxuICAvLyBhIGN1c3RvbSBtZXNzYWdlLCBvciBleHBsaWNpdGx5IG9wdCBvdXQgKGN1cnJlbnRseSB0aGUgb25seSBwYXRoIHRoYXQgb3B0c1xuICAvLyBvdXQgaXMgbGVnYWN5IG1vZGU7IGV2ZXJ5IGNvbmN1cnJlbnQgcGF0aCBwcm92aWRlcyBhbiBlcnJvcikuXG4gIGlmIChyZWNvdmVyYWJsZUVycm9yICE9PSBudWxsKSB7XG4gICAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcbiAgfSAvLyBUaGlzIHdpbGwgYWRkIHRoZSBvbGQgZmliZXIgdG8gdGhlIGRlbGV0aW9uIGxpc3RcblxuXG4gIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7IC8vIFdlJ3JlIG5vdyBub3Qgc3VzcGVuZGVkIG5vciBkZWh5ZHJhdGVkLlxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbik7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyTW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsIGZpYmVyTW9kZSk7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBmaWJlck1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5KSBhbHJlYWR5IG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSkge1xuICAgIC8vIFdlIHdpbGwgaGF2ZSBkcm9wcGVkIHRoZSBlZmZlY3QgbGlzdCB3aGljaCBjb250YWlucyB0aGVcbiAgICAvLyBkZWxldGlvbi4gV2UgbmVlZCB0byByZWNvbmNpbGUgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VJbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gRHVyaW5nIHRoZSBmaXJzdCBwYXNzLCB3ZSdsbCBiYWlsIG91dCBhbmQgbm90IGRyaWxsIGludG8gdGhlIGNoaWxkcmVuLlxuICAvLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB0aGUgY29udGVudCBpbiBwbGFjZSBhbmQgdHJ5IHRvIGh5ZHJhdGUgaXQgbGF0ZXIuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ0Nhbm5vdCBoeWRyYXRlIFN1c3BlbnNlIGluIGxlZ2FjeSBtb2RlLiBTd2l0Y2ggZnJvbSAnICsgJ1JlYWN0RE9NLmh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyKSB0byAnICsgJ1JlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGNvbnRhaW5lciwgPEFwcCAvPiknICsgJy5yZW5kZXIoZWxlbWVudCkgb3IgcmVtb3ZlIHRoZSBTdXNwZW5zZSBjb21wb25lbnRzIGZyb20gJyArICd0aGUgc2VydmVyIHJlbmRlcmVkIGNvbXBvbmVudHMuJyk7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhTeW5jTGFuZSk7XG4gIH0gZWxzZSBpZiAoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgY2xpZW50LW9ubHkgYm91bmRhcnkuIFNpbmNlIHdlIHdvbid0IGdldCBhbnkgY29udGVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAvLyBmb3IgdGhpcywgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGF0IGF0IGEgaGlnaGVyIHByaW9yaXR5IGJhc2VkIG9uIHdoZW4gaXQgd291bGRcbiAgICAvLyBoYXZlIHRpbWVkIG91dC4gSW4gdGhlb3J5IHdlIGNvdWxkIHJlbmRlciBpdCBpbiB0aGlzIHBhc3MgYnV0IGl0IHdvdWxkIGhhdmUgdGhlXG4gICAgLy8gd3JvbmcgcHJpb3JpdHkgYXNzb2NpYXRlZCB3aXRoIGl0IGFuZCB3aWxsIHByZXZlbnQgaHlkcmF0aW9uIG9mIHBhcmVudCBwYXRoLlxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHdvcmsgbGVmdCBvbiBpdCB0byByZW5kZXIgaXQgaW4gYSBzZXBhcmF0ZSBjb21taXQuXG4gICAgLy8gVE9ETyBUaGlzIHRpbWUgc2hvdWxkIGJlIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgcmVzcG9uc2UgdGhhdCBpc1xuICAgIC8vIGEgcGFyZW50IHRvIHRoaXMgYm91bmRhcnkgd2FzIGRpc3BsYXllZC4gSG93ZXZlciwgc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IGhhdmVcbiAgICAvLyBhIHByb3RvY29sIHRvIHRyYW5zZmVyIHRoYXQgdGltZSwgd2UnbGwganVzdCBlc3RpbWF0ZSBpdCBieSB1c2luZyB0aGUgY3VycmVudFxuICAgIC8vIHRpbWUuIFRoaXMgd2lsbCBtZWFuIHRoYXQgU3VzcGVuc2UgdGltZW91dHMgYXJlIHNsaWdodGx5IHNoaWZ0ZWQgdG8gbGF0ZXIgdGhhblxuICAgIC8vIHRoZXkgc2hvdWxkIGJlLlxuICAgIC8vIFNjaGVkdWxlIGEgbm9ybWFsIHByaSB1cGRhdGUgdG8gcmVuZGVyIHRoaXMgY29udGVudC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKERlZmF1bHRIeWRyYXRpb25MYW5lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSdsbCBjb250aW51ZSBoeWRyYXRpbmcgdGhlIHJlc3QgYXQgb2Zmc2NyZWVuIHByaW9yaXR5IHNpbmNlIHdlJ2xsIGFscmVhZHlcbiAgICAvLyBiZSBzaG93aW5nIHRoZSByaWdodCBjb250ZW50IGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGlzIG5vIHJ1c2guXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFdlIHNob3VsZCBuZXZlciBiZSBoeWRyYXRpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IGlzIHRoZSBmaXJzdCBwYXNzLFxuICAvLyBidXQgYWZ0ZXIgd2UndmUgYWxyZWFkeSBjb21taXR0ZWQgb25jZS5cbiAgd2FybklmSHlkcmF0aW5nKCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAvLyBUT0RPOiBXaGVuIHdlIGRlbGV0ZSBsZWdhY3kgbW9kZSwgd2Ugc2hvdWxkIG1ha2UgdGhpcyBlcnJvciBhcmd1bWVudFxuICAgIC8vIHJlcXVpcmVkIOKAlCBldmVyeSBjb25jdXJyZW50IG1vZGUgcGF0aCB0aGF0IGNhdXNlcyBoeWRyYXRpb24gdG9cbiAgICAvLyBkZS1vcHQgdG8gY2xpZW50IHJlbmRlcmluZyBzaG91bGQgaGF2ZSBhbiBlcnJvciBtZXNzYWdlLlxuICAgIG51bGwpO1xuICB9XG5cbiAgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBpcyBpbiBhIHBlcm1hbmVudCBmYWxsYmFjayBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSdsbCBuZXZlclxuICAgIC8vIGdldCBhbiB1cGRhdGUgYW5kIHdlJ2xsIG5ldmVyIGJlIGFibGUgdG8gaHlkcmF0ZSB0aGUgZmluYWwgY29udGVudC4gTGV0J3MganVzdCB0cnkgdGhlXG4gICAgLy8gY2xpZW50IHNpZGUgcmVuZGVyIGluc3RlYWQuXG4gICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgLy8gVE9ETzogVGhlIHNlcnZlciBzaG91bGQgc2VyaWFsaXplIHRoZSBlcnJvciBtZXNzYWdlIHNvIHdlIGNhbiBsb2cgaXRcbiAgICAvLyBoZXJlIG9uIHRoZSBjbGllbnQuIE9yLCBpbiBwcm9kdWN0aW9uLCBhIGhhc2gvaWQgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAgIC8vIHRoZSBlcnJvci5cbiAgICBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgJyArICdkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuIFN3aXRjaGVkIHRvICcgKyAnY2xpZW50IHJlbmRlcmluZy4nKSk7XG4gIH1cbiAgLy8gYW55IGNvbnRleHQgaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gdHJlYXQgaXMgYXMgaWYgdGhlIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cblxuXG4gIHZhciBoYXNDb250ZXh0Q2hhbmdlZCA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIGN1cnJlbnQuY2hpbGRMYW5lcyk7XG5cbiAgaWYgKGRpZFJlY2VpdmVVcGRhdGUgfHwgaGFzQ29udGV4dENoYW5nZWQpIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBmaXJzdCByZW5kZXIuIFRoaXMgbWVhbnMgdGhhdCB3ZSBhcmUgbm93IHVuYWJsZSB0b1xuICAgIC8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKGF0dGVtcHRIeWRyYXRpb25BdExhbmUgIT09IE5vTGFuZSAmJiBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lICE9PSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IG11dGF0aW5nIHNpbmNlIHRoaXMgcmVuZGVyIHdpbGwgZ2V0IGludGVycnVwdGVkLiBUaGlzXG4gICAgICAgIC8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGF0dGVtcHRIeWRyYXRpb25BdExhbmU7IC8vIFRPRE86IElkZWFsbHkgdGhpcyB3b3VsZCBpbmhlcml0IHRoZSBldmVudCB0aW1lIG9mIHRoZSBjdXJyZW50IHJlbmRlclxuXG4gICAgICAgIHZhciBldmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGN1cnJlbnQsIGF0dGVtcHRIeWRyYXRpb25BdExhbmUsIGV2ZW50VGltZSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiB3ZSBoYXZlIHNjaGVkdWxlZCBoaWdoZXIgcHJpIHdvcmsgYWJvdmUsIHRoaXMgd2lsbCBwcm9iYWJseSBqdXN0IGFib3J0IHRoZSByZW5kZXJcbiAgICAvLyBzaW5jZSB3ZSBub3cgaGF2ZSBoaWdoZXIgcHJpb3JpdHkgd29yaywgYnV0IGluIGNhc2UgaXQgZG9lc24ndCwgd2UgbmVlZCB0byBwcmVwYXJlIHRvXG4gICAgLy8gcmVuZGVyIHNvbWV0aGluZywgaWYgd2UgdGltZSBvdXQuIEV2ZW4gaWYgdGhhdCByZXF1aXJlcyB1cyB0byBkZWxldGUgZXZlcnl0aGluZyBhbmRcbiAgICAvLyBza2lwIGh5ZHJhdGlvbi5cbiAgICAvLyBEZWxheSBoYXZpbmcgdG8gZG8gdGhpcyBhcyBsb25nIGFzIHRoZSBzdXNwZW5zZSB0aW1lb3V0IGFsbG93cyB1cy5cblxuXG4gICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIG5ldyBFcnJvcignVGhpcyBTdXNwZW5zZSBib3VuZGFyeSByZWNlaXZlZCBhbiB1cGRhdGUgYmVmb3JlIGl0IGZpbmlzaGVkICcgKyAnaHlkcmF0aW5nLiBUaGlzIGNhdXNlZCB0aGUgYm91bmRhcnkgdG8gc3dpdGNoIHRvIGNsaWVudCByZW5kZXJpbmcuICcgKyAnVGhlIHVzdWFsIHdheSB0byBmaXggdGhpcyBpcyB0byB3cmFwIHRoZSBvcmlnaW5hbCB1cGRhdGUgJyArICdpbiBzdGFydFRyYW5zaXRpb24uJykpO1xuICB9IGVsc2UgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBzdGlsbCBwZW5kaW5nIG1vcmUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIHNvIHdlIGNhbid0IGh5ZHJhdGUgaXRzXG4gICAgLy8gY29udGVudC4gV2UgdHJlYXQgaXQgYXMgaWYgdGhpcyBjb21wb25lbnQgc3VzcGVuZGVkIGl0c2VsZi4gSXQgbWlnaHQgc2VlbSBhcyBpZlxuICAgIC8vIHdlIGNvdWxkIGp1c3QgdHJ5IHRvIHJlbmRlciBpdCBjbGllbnQtc2lkZSBpbnN0ZWFkLiBIb3dldmVyLCB0aGlzIHdpbGwgcGVyZm9ybSBhXG4gICAgLy8gbG90IG9mIHVubmVjZXNzYXJ5IHdvcmsgYW5kIGlzIHVubGlrZWx5IHRvIGNvbXBsZXRlIHNpbmNlIGl0IG9mdGVuIHdpbGwgc3VzcGVuZFxuICAgIC8vIG9uIG1pc3NpbmcgZGF0YSBhbnl3YXkuIEFkZGl0aW9uYWxseSwgdGhlIHNlcnZlciBtaWdodCBiZSBhYmxlIHRvIHJlbmRlciBtb3JlXG4gICAgLy8gdGhhbiB3ZSBjYW4gb24gdGhlIGNsaWVudCB5ZXQuIEluIHRoYXQgY2FzZSB3ZSdkIGVuZCB1cCB3aXRoIG1vcmUgZmFsbGJhY2sgc3RhdGVzXG4gICAgLy8gb24gdGhlIGNsaWVudCB0aGFuIGlmIHdlIGp1c3QgbGVhdmUgaXQgYWxvbmUuIElmIHRoZSBzZXJ2ZXIgdGltZXMgb3V0IG9yIGVycm9yc1xuICAgIC8vIHRoZXNlIHNob3VsZCB1cGRhdGUgdGhpcyBib3VuZGFyeSB0byB0aGUgcGVybWFuZW50IEZhbGxiYWNrIHN0YXRlIGluc3RlYWQuXG4gICAgLy8gTWFyayBpdCBhcyBoYXZpbmcgY2FwdHVyZWQgKGkuZS4gc3VzcGVuZGVkKS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlOyAvLyBMZWF2ZSB0aGUgY2hpbGQgaW4gcGxhY2UuIEkuZS4gdGhlIGRlaHlkcmF0ZWQgZnJhZ21lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gcmV0cnkgdGhpcyBib3VuZGFyeSBvbmNlIHRoZSBzZXJ2ZXIgaGFzIHNlbnQgdGhlIHJlc3VsdC5cblxuICAgIHZhciByZXRyeSA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChudWxsLCBjdXJyZW50KTtcbiAgICByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShzdXNwZW5zZUluc3RhbmNlLCByZXRyeSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgYXR0ZW1wdC5cbiAgICByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUudHJlZUNvbnRleHQpO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBNYXJrIHRoZSBjaGlsZHJlbiBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFncyB8PSBIeWRyYXRpbmc7XG4gICAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KTtcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBmaXJzdENoaWxkLCByZW5kZXJMYW5lcykge1xuICAvLyBNYXJrIGFueSBTdXNwZW5zZSBib3VuZGFyaWVzIHdpdGggZmFsbGJhY2tzIGFzIGhhdmluZyB3b3JrIHRvIGRvLlxuICAvLyBJZiB0aGV5IHdlcmUgcHJldmlvdXNseSBmb3JjZWQgaW50byBmYWxsYmFja3MsIHRoZXkgbWF5IG5vdyBiZSBhYmxlXG4gIC8vIHRvIHVuYmxvY2suXG4gIHZhciBub2RlID0gZmlyc3RDaGlsZDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCkge1xuICAgICAgLy8gSWYgdGhlIHRhaWwgaXMgaGlkZGVuIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBTdXNwZW5zZSBib3VuZGFyaWVzXG4gICAgICAvLyB0byBzY2hlZHVsZSB3b3JrIG9uLiBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBvbiB0aGVcbiAgICAgIC8vIGxpc3QgaXRzZWxmLlxuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmF2ZXJzZSB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIGxpc3Qgc2luY2VcbiAgICAgIC8vIHRoZSBsaXN0IHdpbGwgcHJvcGFnYXRlIHRoZSBjaGFuZ2Ugd2hlbiBpdCByZXJlbmRlcnMuXG4gICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTGFzdENvbnRlbnRSb3coZmlyc3RDaGlsZCkge1xuICAvLyBUaGlzIGlzIGdvaW5nIHRvIGZpbmQgdGhlIGxhc3Qgcm93IGFtb25nIHRoZXNlIGNoaWxkcmVuIHRoYXQgaXMgYWxyZWFkeVxuICAvLyBzaG93aW5nIGNvbnRlbnQgb24gdGhlIHNjcmVlbiwgYXMgb3Bwb3NlZCB0byBiZWluZyBpbiBmYWxsYmFjayBzdGF0ZSBvclxuICAvLyBuZXcuIElmIGEgcm93IGhhcyBtdWx0aXBsZSBTdXNwZW5zZSBib3VuZGFyaWVzLCBhbnkgb2YgdGhlbSBiZWluZyBpbiB0aGVcbiAgLy8gZmFsbGJhY2sgc3RhdGUsIGNvdW50cyBhcyB0aGUgd2hvbGUgcm93IGJlaW5nIGluIGEgZmFsbGJhY2sgc3RhdGUuXG4gIC8vIE5vdGUgdGhhdCB0aGUgXCJyb3dzXCIgd2lsbCBiZSB3b3JrSW5Qcm9ncmVzcywgYnV0IGFueSBuZXN0ZWQgY2hpbGRyZW5cbiAgLy8gd2lsbCBzdGlsbCBiZSBjdXJyZW50IHNpbmNlIHdlIGhhdmVuJ3QgcmVuZGVyZWQgdGhlbSB5ZXQuIFRoZSBtb3VudGVkXG4gIC8vIG9yZGVyIG1heSBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG5ldyBvcmRlci4gV2UgdXNlIHRoZSBuZXcgb3JkZXIuXG4gIHZhciByb3cgPSBmaXJzdENoaWxkO1xuICB2YXIgbGFzdENvbnRlbnRSb3cgPSBudWxsO1xuXG4gIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgbGFzdENvbnRlbnRSb3cgPSByb3c7XG4gICAgfVxuXG4gICAgcm93ID0gcm93LnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbGFzdENvbnRlbnRSb3c7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmIChyZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkICYmIHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ3RvZ2V0aGVyJyAmJiAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdKSB7XG4gICAgICBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHJldmVhbE9yZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICh0YWlsTW9kZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0pIHtcbiAgICAgIGlmICh0YWlsTW9kZSAhPT0gJ2NvbGxhcHNlZCcgJiYgdGFpbE1vZGUgIT09ICdoaWRkZW4nKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsIHRhaWxNb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAocmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyAnICsgJ1wiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICB7XG4gICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FuQXJyYXkgJiYgdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmIChpc0FuQXJyYXkgfHwgaXNJdGVyYWJsZSkge1xuICAgICAgdmFyIHR5cGUgPSBpc0FuQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSkge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgZXhpc3Rpbmcgb2JqZWN0IGZyb20gcHJldmlvdXMgcmVuZGVycy5cbiAgICByZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMDtcbiAgICByZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3c7XG4gICAgcmVuZGVyU3RhdGUudGFpbCA9IHRhaWw7XG4gICAgcmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZTtcbiAgfVxufSAvLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cbi8vIFRoZSBmaXJzdCBwYXNzIHNwbGl0cyB0aGUgY2hpbGRyZW4gZmliZXJzIGludG8gdHdvIHNldHMuIEEgaGVhZCBhbmQgdGFpbC5cbi8vIFdlIGZpcnN0IHJlbmRlciB0aGUgaGVhZC4gSWYgYW55dGhpbmcgaXMgaW4gZmFsbGJhY2sgc3RhdGUsIHdlIGRvIGFub3RoZXJcbi8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcbi8vIHRoZSBmb3JjZSBzdXNwZW5kIGNvbnRleHQuIElmIHRoZSBmaXJzdCByZW5kZXIgZGlkbid0IGhhdmUgYW55dGhpbmcgaW5cbi8vIGluIGZhbGxiYWNrIHN0YXRlLiBUaGVuIHdlIHJlbmRlciBlYWNoIHJvdyBpbiB0aGUgdGFpbCBvbmUtYnktb25lLlxuLy8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cblxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcjtcbiAgdmFyIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gIHZhciBuZXdDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihuZXdDaGlsZHJlbiwgcmV2ZWFsT3JkZXIpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3VsZEZvcmNlRmFsbGJhY2sgPSBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXG4gIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbiAgICAgIC8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbiAgICAgIC8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG4gICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgfVxuXG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAvLyBJbiBsZWdhY3kgbW9kZSwgU3VzcGVuc2VMaXN0IGRvZXNuJ3Qgd29yayBzbyB3ZSBqdXN0XG4gICAgLy8gdXNlIG1ha2UgaXQgYSBub29wIGJ5IHRyZWF0aW5nIGl0IGFzIHRoZSBkZWZhdWx0IHJldmVhbE9yZGVyLlxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIpIHtcbiAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudFJvdyA9IGZpbmRMYXN0Q29udGVudFJvdyh3b3JrSW5Qcm9ncmVzcy5jaGlsZCk7XG4gICAgICAgICAgdmFyIHRhaWw7XG5cbiAgICAgICAgICBpZiAobGFzdENvbnRlbnRSb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBsaXN0IGlzIHBhcnQgb2YgdGhlIHRhaWwuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBjb3VsZCBmYXN0IHBhdGggYnkganVzdCByZW5kZXJpbmcgdGhlIHRhaWwgbm93LlxuICAgICAgICAgICAgdGFpbCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSB0YWlsIHJvd3MgYWZ0ZXIgdGhlIGNvbnRlbnQgcm93LlxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZW0gc2VwYXJhdGVseSBsYXRlci5cbiAgICAgICAgICAgIHRhaWwgPSBsYXN0Q29udGVudFJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgbGFzdENvbnRlbnRSb3cuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBmaW5kIHRoZSBmaXJzdCByb3cgdGhhdCBoYXMgZXhpc3RpbmcgY29udGVudC5cbiAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIGdvaW5nIHRvIHJldmVyc2UgdGhlIGxpc3Qgb2YgZXZlcnl0aGluZ1xuICAgICAgICAgIC8vIHdlIHBhc3MgaW4gdGhlIG1lYW50aW1lLiBUaGF0J3MgZ29pbmcgdG8gYmUgb3VyIHRhaWwgaW4gcmV2ZXJzZVxuICAgICAgICAgIC8vIG9yZGVyLlxuICAgICAgICAgIHZhciBfdGFpbCA9IG51bGw7XG4gICAgICAgICAgdmFyIHJvdyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcblxuICAgICAgICAgIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYWluIGNvbnRlbnQuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcm93O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHRSb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgIHJvdy5zaWJsaW5nID0gX3RhaWw7XG4gICAgICAgICAgICBfdGFpbCA9IHJvdztcbiAgICAgICAgICAgIHJvdyA9IG5leHRSb3c7XG4gICAgICAgICAgfSAvLyBUT0RPOiBJZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBpcyBudWxsLCB3ZSBjYW4gY29udGludWUgb24gdGhlIHRhaWwgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBfdGFpbCwgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHRhaWxNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgIHtcbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIG51bGwsIC8vIHRhaWxcbiAgICAgICAgICBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgcmV2ZWFsIG9yZGVyIGlzIHRoZSBzYW1lIGFzIG5vdCBoYXZpbmdcbiAgICAgICAgICAvLyBhIGJvdW5kYXJ5LlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHByb3ZpZGVyVHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJUeXBlLl9jb250ZXh0O1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuXG4gIHtcbiAgICBpZiAoISgndmFsdWUnIGluIG5ld1Byb3BzKSkge1xuICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcikge1xuICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1RoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD8nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvdmlkZXJQcm9wVHlwZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3BUeXBlcztcblxuICAgIGlmIChwcm92aWRlclByb3BUeXBlcykge1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvdmlkZXJQcm9wVHlwZXMsIG5ld1Byb3BzLCAncHJvcCcsICdDb250ZXh0LlByb3ZpZGVyJyk7XG4gICAgfVxuICB9XG5cbiAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBuZXdWYWx1ZSk7XG5cbiAge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZFZhbHVlID0gb2xkUHJvcHMudmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgICAgLy8gdGhlbSB0byB1cGRhdGUuXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0KTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuXG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTtcbiAgICB9IC8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgb2xkIGN1cnJlbnQuXG4gICAgLy8gSXQgd2lsbCBnZXQgZGVsZXRlZC5cblxuXG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIG9sZFdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIENvbm5lY3QgdG8gdGhlIG5ldyB0cmVlLlxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuaW5kZXggPSBvbGRXb3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gb2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZXR1cm4gPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmVmID0gb2xkV29ya0luUHJvZ3Jlc3MucmVmOyAvLyBSZXBsYWNlIHRoZSBjaGlsZC9zaWJsaW5nIHBvaW50ZXJzIGFib3ZlIGl0LlxuXG4gICAgaWYgKG9sZFdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZCkge1xuICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwcmV2U2libGluZy5zaWJsaW5nICE9PSBvbGRXb3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudCk7XG4gICAgfVxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcbiAgLy8gdXBkYXRlcyBvciBjb250ZXh0LlxuICB2YXIgdXBkYXRlTGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBObyBwZW5kaW5nIHVwZGF0ZSwgYnV0IGJlY2F1c2UgY29udGV4dCBpcyBwcm9wYWdhdGVkIGxhemlseSwgd2UgbmVlZFxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG4gICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIC8vIFByb2ZpbGVyIHNob3VsZCBvbmx5IGNhbGwgb25SZW5kZXIgd2hlbiBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbiAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpOyAvLyBXZSBrbm93IHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBzdXNwZW5kIGFnYWluIGJlY2F1c2UgaWYgaXQgaGFzXG4gICAgICAgICAgICAgIC8vIGJlZW4gdW5zdXNwZW5kZWQgaXQgaGFzIGNvbW1pdHRlZCBhcyBhIHJlc29sdmVkIFN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgLy8gSWYgaXQgbmVlZHMgdG8gYmUgcmV0cmllZCwgaXQgc2hvdWxkIGhhdmUgd29yayBzY2hlZHVsZWQgb24gaXQuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gV2Ugc2hvdWxkIG5ldmVyIHJlbmRlciB0aGUgY2hpbGRyZW4gb2YgYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IHVudGlsIHdlXG4gICAgICAgICAgICAgIC8vIHVwZ3JhZGUgaXQuIFdlIHJldHVybiBudWxsIGluc3RlYWQgb2YgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yay5cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgaXMgY3VycmVudGx5IHRpbWVkIG91dCwgd2UgbmVlZCB0byBkZWNpZGVcbiAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgLy8gZ28gc3RyYWlnaHQgdG8gdGhlIGZhbGxiYWNrLiBDaGVjayB0aGUgcHJpb3JpdHkgb2YgdGhlIHByaW1hcnlcbiAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZExhbmVzID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcztcblxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4gICAgICAgICAgICAvLyB0byBhdHRlbXB0IHRvIHJlbmRlciB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhZ2Fpbi5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCBkb2VzIG5vdCBoYXZlIHBlbmRpbmcgd29yayBtYXJrZWRcbiAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuICAgICAgICAgICAgLy8gcHJpb3JpdHkuIEJhaWxvdXQuXG5cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSBmYWxsYmFjayBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gU2tpcCBvdmVyIHRoZVxuICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBjYW4gcmV0dXJuIGBudWxsYCBoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlcmUgd2VyZSBuZXN0ZWQgY29udGV4dCBjb25zdW1lcnMsIHZpYSB0aGUgY2FsbCB0b1xuICAgICAgICAgICAgICAvLyBgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29ya2AgYWJvdmUuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBtaWdodCBnZXQgdW5ibG9ja2VkIGJ5IHN0YXRlIHVwZGF0ZXMgb3IgcmV0cmllcyBpbiB0aGVcbiAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgIC8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5cblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4gICAgICAgIC8vIHRoZW4gdGhlIHRhaWwgZG9lc24ndCBtYXR0ZXIuIEFueXRoaW5nIG5ldyB0aGF0IHN1c3BlbmRzIHdpbGwgd29ya1xuICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAvLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG4gICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAvLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgLy8gYnV0IEkgd29uJ3QgOilcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgcHJvcHMgbm9yIGxlZ2FjeSBjb250ZXh0IGNoYW5nZXMuIENoZWNrIGlmIHRoZXJlJ3MgYSBwZW5kaW5nXG4gICAgICAvLyB1cGRhdGUgb3IgY29udGV4dCBjaGFuZ2UuXG4gICAgICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ID0gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCAmJiAvLyBJZiB0aGlzIGlzIHRoZSBzZWNvbmQgcGFzcyBvZiBhbiBlcnJvciBvciBzdXNwZW5zZSBib3VuZGFyeSwgdGhlcmVcbiAgICAgIC8vIG1heSBub3QgYmUgd29yayBzY2hlZHVsZWQgb24gYGN1cnJlbnRgLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBmbGFnLlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gTm8gcGVuZGluZyB1cGRhdGVzIG9yIGNvbnRleHQuIEJhaWwgb3V0IG5vdy5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGNoaWxkIGJlbG9uZ3MgdG8gYSBsaXN0IG9mIG11bGlwbGUgY2hpbGRyZW4gaW5cbiAgICAgIC8vIGl0cyBwYXJlbnQuXG4gICAgICAvL1xuICAgICAgLy8gSW4gYSB0cnVlIG11bHRpLXRocmVhZGVkIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCByZW5kZXIgY2hpbGRyZW4gb25cbiAgICAgIC8vIHBhcmFsbGVsIHRocmVhZHMuIFRoaXMgd291bGQgcmVwcmVzZW50IHRoZSBiZWdpbm5pbmcgb2YgYSBuZXcgcmVuZGVyXG4gICAgICAvLyB0aHJlYWQgZm9yIHRoaXMgc3VidHJlZS5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBvbmx5IHVzZSB0aGlzIGZvciBpZCBnZW5lcmF0aW9uIGR1cmluZyBoeWRyYXRpb24sIHdoaWNoIGlzIHdoeSB0aGVcbiAgICAgIC8vIGxvZ2ljIGlzIGxvY2F0ZWQgaW4gdGhpcyBzcGVjaWFsIGJyYW5jaC5cbiAgICAgIHZhciBzbG90SW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gZ2V0Rm9ya3NBdExldmVsKCk7XG4gICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzLCBzbG90SW5kZXgpO1xuICAgIH1cbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBDb21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyBfdW5yZXNvbHZlZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50LCBfdW5yZXNvbHZlZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IHR5cGUgPyBfdW5yZXNvbHZlZFByb3BzMiA6IHJlc29sdmVEZWZhdWx0UHJvcHModHlwZSwgX3VucmVzb2x2ZWRQcm9wczIpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBfcmVzb2x2ZWRQcm9wczIsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3R5cGUyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBSZXNvbHZlIG91dGVyIHByb3BzIGZpcnN0LCB0aGVuIHJlc29sdmUgaW5uZXIgcHJvcHMuXG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLCBfdW5yZXNvbHZlZFByb3BzMyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gX3R5cGUyLnByb3BUeXBlcztcblxuICAgICAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBfcmVzb2x2ZWRQcm9wczMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsIF9yZXNvbHZlZFByb3BzMyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIF9yZXNvbHZlZFByb3BzMywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudDIgPyBfdW5yZXNvbHZlZFByb3BzNCA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHM0KTtcblxuICAgICAgICByZXR1cm4gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQyLCBfcmVzb2x2ZWRQcm9wczQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIiArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE5vdGU6IFRoaXMgaW50ZW50aW9uYWxseSBkb2Vzbid0IGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZyBiZWNhdXNlIGNvbXBhcmluZ1xuICAvLyB0byB0aGUgY3VycmVudCB0cmVlIHByb3ZpZGVyIGZpYmVyIGlzIGp1c3QgYXMgZmFzdCBhbmQgbGVzcyBlcnJvci1wcm9uZS5cbiAgLy8gSWRlYWxseSB3ZSB3b3VsZCBoYXZlIGEgc3BlY2lhbCB2ZXJzaW9uIG9mIHRoZSB3b3JrIGxvb3Agb25seVxuICAvLyBmb3IgaHlkcmF0aW9uLlxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcblxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIHZhciBfZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoKF9mbGFncyAmIFNob3VsZENhcHR1cmUpICE9PSBOb0ZsYWdzICYmIChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyIHRoYXQgd2Fzbid0IGNhcHR1cmVkIGJ5IGEgc3VzcGVuc2VcbiAgICAgICAgICAvLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH0gLy8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4gIC8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4gIC8vIGZvciBoeWRyYXRpb24uXG4gIHBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7XG5cbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG5cbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0ID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuX2NvbnRleHQ7XG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFJlbmRlckxhbmVzKGludGVycnVwdGVkV29yayk7XG5cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2Q7XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW5pbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBmdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgZG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgJyArICdkZWZpbmVkIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiBpbiBhIHRlc3QgZW52aXJvbm1lbnQgaWYgYSBjb21wb25lbnQgJyArICdzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgJyArICdmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgJyArICd0aGUgZW5kIG9mIHlvdXIgdGVzdCAoYW5kIGVuc3VyZSB0aGF0IGFueSBhc3luY2hyb25vdXMgb3BlcmF0aW9ucyBnZXQgJyArICdjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmICcgKyAndG8gYmUgYXN5bmNocm9ub3VzLicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICB2YXIgZGlkQ2FsbCA9IGZhbHNlOyAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB2YWx1ZSBvZiB3aW5kb3cuZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVzZXQgaXRcbiAgICAgIC8vIGR1cmluZyB0aGUgY2FsbGJhY2sgdG8gbGV0IHVzZXIgY29kZSBhY2Nlc3Mgd2luZG93LmV2ZW50IGluIHRoZVxuICAgICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LlxuXG4gICAgICB2YXIgd2luZG93RXZlbnQgPSB3aW5kb3cuZXZlbnQ7IC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBkZXNjcmlwdG9yIG9mIHdpbmRvdy5ldmVudCB0byByZXN0b3JlIGl0IGFmdGVyIGV2ZW50XG4gICAgICAvLyBkaXNwYXRjaGluZzogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzY4OFxuXG4gICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3csICdldmVudCcpO1xuXG4gICAgICBmdW5jdGlvbiByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFdlIGNoZWNrIGZvciB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykgdG8gcHJldmVudCB0aGVcbiAgICAgICAgLy8gd2luZG93LmV2ZW50IGFzc2lnbm1lbnQgaW4gYm90aCBJRSA8PSAxMCBhcyB0aGV5IHRocm93IGFuIGVycm9yXG4gICAgICAgIC8vIFwiTWVtYmVyIG5vdCBmb3VuZFwiIGluIHN0cmljdCBtb2RlLCBhbmQgaW4gRmlyZWZveCB3aGljaCBkb2VzIG5vdFxuICAgICAgICAvLyBzdXBwb3J0IHdpbmRvdy5ldmVudC5cblxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cblxuXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIGRpZENhbGwgPSB0cnVlO1xuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH0gLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cblxuXG4gICAgICB2YXIgZXJyb3I7IC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlV2luZG93RXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHsvLyBJZ25vcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cblxuXG4gICAgICB2YXIgZXZ0VHlwZSA9IFwicmVhY3QtXCIgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7IC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cblxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdldmVudCcsIHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWRDYWxsICYmIGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcblxuICAgICAgaWYgKCFkaWRDYWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHJlYWxseSB3cm9uZywgYW5kIG91ciBldmVudCB3YXMgbm90IGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsOyAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBoYXNDYXVnaHRFcnJvcigpIHtcbiAgcmV0dXJuIGhhc0Vycm9yO1xufVxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufSAvLyBVc2VkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHRvIHRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCBzdGFjay5cbi8vIEFsbG93cyB1cyB0byBhdm9pZCB0cmF2ZXJzaW5nIHRoZSByZXR1cm4gcGF0aCB0byBmaW5kIHRoZSBuZWFyZXN0IE9mZnNjcmVlbiBhbmNlc3Rvci5cbi8vIE9ubHkgdXNlZCB3aGVuIGVuYWJsZVN1c3BlbnNlTGF5b3V0RWZmZWN0U2VtYW50aWNzIGlzIGVuYWJsZWQuXG5cblxudmFyIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGZhbHNlO1xudmFyIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBmYWxzZTtcbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG52YXIgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFVzZWQgZm9yIFByb2ZpbGluZyBidWlsZHMgdG8gdHJhY2sgdXBkYXRlcnMuXG5cbnZhciBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xudmFyIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcblxuZnVuY3Rpb24gcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKSB7XG4gIC8vIFdyYXBwaW5nIGVhY2ggc21hbGwgcGFydCBvZiB0aGUgY29tbWl0IHBoYXNlIGludG8gYSBndWFyZGVkXG4gIC8vIGNhbGxiYWNrIGlzIGEgYml0IHRvbyBzbG93IChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMTY2NikuXG4gIC8vIEJ1dCB3ZSByZWx5IG9uIGl0IHRvIHN1cmZhY2UgZXJyb3JzIHRvIERFViB0b29scyBsaWtlIG92ZXJsYXlzXG4gIC8vIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNzEyKS5cbiAgLy8gQXMgYSBjb21wcm9taXNlLCByZXRocm93IG9ubHkgY2F1Z2h0IGVycm9ycyBpbiBhIGd1YXJkLlxuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQsIGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGluc3RhbmNlKSB7XG4gIHRyeSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyKGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpIHtcbiAgdHJ5IHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0QXR0YWNoUmVmKGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciByZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZXRWYWw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIGVuYWJsZVByb2ZpbGVyQ29tbWl0SG9va3MgJiYgY3VycmVudC5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgcmV0VmFsID0gcmVmKG51bGwpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0VmFsID0gcmVmKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRWYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZXR1cm4gdmFsdWUgZnJvbSBhIGNhbGxiYWNrIHJlZiBpbiAlcy4gJyArICdBIGNhbGxiYWNrIHJlZiBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSkge1xuICB0cnkge1xuICAgIGRlc3Ryb3koKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuXG52YXIgZm9jdXNlZEluc3RhbmNlSGFuZGxlID0gbnVsbDtcbnZhciBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cbiAgdmFyIHNob3VsZEZpcmUgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuICBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuICByZXR1cm4gc2hvdWxkRmlyZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRoaXMgcGhhc2UgaXMgb25seSB1c2VkIGZvciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIuXG5cbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgQmVmb3JlTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyAmJiBjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoY2hpbGQsIGZpYmVyKTtcbiAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgZmliZXIucmV0dXJuKTtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgIHNldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChmbGFncywgZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW91bnRcblxuXG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG5cbiAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICgoZWZmZWN0LnRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGVmZmVjdC50YWcgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VFZmZlY3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiAnICsgJ3VwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdHJveS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlICcgKyBob29rTmFtZSArICcoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyBob29rTmFtZSArICcoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArIFwifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQ6ICcgKyBkZXN0cm95O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcignJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgJyArICd3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lcycsIGhvb2tOYW1lLCBhZGRlbmR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAge1xuICAgIC8vIE9ubHkgUHJvZmlsZXJzIHdpdGggd29yayBpbiB0aGVpciBzdWJ0cmVlIHdpbGwgaGF2ZSBhbiBVcGRhdGUgZWZmZWN0IHNjaGVkdWxlZC5cbiAgICBpZiAoKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcbiAgICAgICAgICAgICAgICBvblBvc3RDb21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25Qb3N0Q29tbWl0OyAvLyBUaGlzIHZhbHVlIHdpbGwgc3RpbGwgcmVmbGVjdCB0aGUgcHJldmlvdXMgY29tbWl0IHBoYXNlLlxuICAgICAgICAgICAgLy8gSXQgZG9lcyBub3QgZ2V0IHJlc2V0IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb21taXQgcGhhc2UuXG5cbiAgICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHBoYXNlID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJztcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBwaGFzZSA9ICduZXN0ZWQtdXBkYXRlJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uUG9zdENvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblBvc3RDb21taXQoaWQsIHBoYXNlLCBwYXNzaXZlRWZmZWN0RHVyYXRpb24sIGNvbW1pdFRpbWUpO1xuICAgICAgICAgICAgfSAvLyBCdWJibGUgdGltZXMgdG8gdGhlIG5leHQgbmVhcmVzdCBhbmNlc3RvciBQcm9maWxlci5cbiAgICAgICAgICAgIC8vIEFmdGVyIHdlIHByb2Nlc3MgdGhhdCBQcm9maWxlciwgd2UnbGwgYnViYmxlIGZ1cnRoZXIgdXAuXG5cblxuICAgICAgICAgICAgdmFyIHBhcmVudEZpYmVyID0gZmluaXNoZWRXb3JrLnJldHVybjtcblxuICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIHJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgaWYgKChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICggIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgbGF5b3V0IGVmZmVjdHMgaGF2ZSBhbHJlYWR5IGJlZW4gZGVzdHJveWVkIChkdXJpbmcgbXV0YXRpb24gcGhhc2UpLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbiAgICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuXG5cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG5cbiAgICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuICAgICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIF91cGRhdGVRdWV1ZSwgX2luc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxcbiAgICAgICAgICAgICAgICBvblJlbmRlciA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25SZW5kZXI7XG4gICAgICAgICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0gJ25lc3RlZC11cGRhdGUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25SZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25SZW5kZXIoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uQ29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Db21taXQoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBlZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG4gICAgICAgICAgICAgIH0gLy8gU2NoZWR1bGUgYSBwYXNzaXZlIGVmZmVjdCBmb3IgdGhpcyBQcm9maWxlciB0byBjYWxsIG9uUG9zdENvbW1pdCBob29rcy5cbiAgICAgICAgICAgICAgLy8gVGhpcyBlZmZlY3Qgc2hvdWxkIGJlIHNjaGVkdWxlZCBldmVuIGlmIHRoZXJlIGlzIG5vIG9uUG9zdENvbW1pdCBjYWxsYmFjayBmb3IgdGhpcyBQcm9maWxlcixcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWZmZWN0IGlzIGFsc28gd2hlcmUgdGltZXMgYnViYmxlIHRvIHBhcmVudCBQcm9maWxlcnMuXG5cblxuICAgICAgICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaW5pc2hlZFdvcmspOyAvLyBQcm9wYWdhdGUgbGF5b3V0IGVmZmVjdCBkdXJhdGlvbnMgdG8gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3Rvci5cbiAgICAgICAgICAgICAgLy8gRG8gbm90IHJlc2V0IHRoZXNlIHZhbHVlcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgc28gRGV2VG9vbHMgaGFzIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSBmaXJzdC5cblxuICAgICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG4gICAgICAgICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCAhb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgIHtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIobm9kZSkge1xuICAvLyBUdXJuIG9uIGxheW91dCBlZmZlY3RzIGluIGEgdHJlZSB0aGF0IHByZXZpb3VzbHkgZGlzYXBwZWFyZWQuXG4gIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG4gIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICggbm9kZS5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbW1pdEhvb2tMYXlvdXRFZmZlY3RMaXN0TW91bnQobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudERpZE1vdW50KG5vZGUsIG5vZGUucmV0dXJuLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzYWZlbHlBdHRhY2hSZWYobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKG5vZGUsIG5vZGUucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbikge1xuICAvLyBPbmx5IGhpZGUgb3IgdW5oaWRlIHRoZSB0b3AtbW9zdCBob3N0IG5vZGVzLlxuICB2YXIgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcblxuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBub2RlO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMywgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBub2RlKSB7XG4gICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgdmFyIGluc3RhbmNlVG9Vc2U7XG5cbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9IC8vIE1vdmVkIG91dHNpZGUgdG8gZW5zdXJlIERDRSB3b3JrcyB3aXRoIHRoaXMgZmxhZ1xuXG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZXRWYWw7XG5cbiAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICByZXRWYWwgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0VmFsID0gcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0VmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcgKyAnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50UmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59IC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbi8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG5cblxuZnVuY3Rpb24gY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuXG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIF9lZmZlY3QgPSBlZmZlY3QsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95ID0gX2VmZmVjdC5kZXN0cm95LFxuICAgICAgICAgICAgICAgICAgdGFnID0gX2VmZmVjdC50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgodGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgcm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAvLyB3ZSBkbyBhbiBpbm5lciBsb29wIHdoaWxlIHdlJ3JlIHN0aWxsIGluc2lkZSB0aGUgaG9zdCBub2RlLlxuICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgIXN1cHBvcnRzTXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXIgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGV0ZWN0IGFuZCB3YXJuIGFnYWluc3Qgc3RhdGUgdXBkYXRlcyBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlxuICAvLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuICAvL1xuICAvLyBJZGVhbGx5LCB3ZSBzaG91bGQgYWxzbyBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLlxuICAvLyBUaGlzIGNoaWxkIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjbGVhciBjaGlsZCBvciBzaWJsaW5nIHBvaW50ZXJzIHlldC5cbiAgLy8gVGhleSdyZSBuZWVkZWQgZm9yIHBhc3NpdmUgZWZmZWN0cyBhbmQgZm9yIGZpbmRET01Ob2RlLlxuICAvLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG4gIC8vXG4gIC8vIERvbid0IHJlc2V0IHRoZSBhbHRlcm5hdGUgeWV0LCBlaXRoZXIuIFdlIG5lZWQgdGhhdCBzbyB3ZSBjYW4gZGV0YWNoIHRoZVxuICAvLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuICAvLyBzdWZmaWNpZW50IGZvciBmaW5kRE9NTm9kZSBzZW1hbnRpY3MuXG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO1xuICB9IC8vIE5vdGU6IERlZmVuc2l2ZWx5IHVzaW5nIG5lZ2F0aW9uIGluc3RlYWQgb2YgPCBpbiBjYXNlXG4gIC8vIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgaXMgdW5kZWZpbmVkLlxuXG5cbiAge1xuICAgIC8vIENsZWFyIGN5Y2xpY2FsIEZpYmVyIGZpZWxkcy4gVGhpcyBsZXZlbCBhbG9uZSBpcyBkZXNpZ25lZCB0byByb3VnaGx5XG4gICAgLy8gYXBwcm94aW1hdGUgdGhlIHBsYW5uZWQgRmliZXIgcmVmYWN0b3IuIEluIHRoYXQgd29ybGQsIGBzZXRTdGF0ZWAgd2lsbCBiZVxuICAgIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4gICAgLy8gb2JqZWN0IHdpbGwgbm90IGhhdmUgYW55IG9mIHRoZXNlIGZpZWxkcy4gSXQgd2lsbCBvbmx5IGJlIGNvbm5lY3RlZCB0b1xuICAgIC8vIHRoZSBmaWJlciB0cmVlIHZpYSBhIHNpbmdsZSBsaW5rIGF0IHRoZSByb290LiBTbyBpZiB0aGlzIGxldmVsIGFsb25lIGlzXG4gICAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG4gICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgZmliZXIuc2libGluZyA9IG51bGw7IC8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG4gICAgLy8gdHJlZSwgd2hpY2ggaGFzIGl0cyBvd24gcG9pbnRlcnMgdG8gY2hpbGRyZW4sIHBhcmVudHMsIGFuZCBzaWJsaW5ncy5cbiAgICAvLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbiAgICAvLyBvbmUsIHRvby5cblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDsgLy8gSSdtIGludGVudGlvbmFsbHkgbm90IGNsZWFyaW5nIHRoZSBgcmV0dXJuYCBmaWVsZCBpbiB0aGlzIGxldmVsLiBXZVxuICAgIC8vIGFscmVhZHkgZGlzY29ubmVjdCB0aGUgYHJldHVybmAgcG9pbnRlciBhdCB0aGUgcm9vdCBvZiB0aGUgZGVsZXRlZFxuICAgIC8vIHN1YnRyZWUgKGluIGBkZXRhY2hGaWJlck11dGF0aW9uYCkuIEJlc2lkZXMsIGByZXR1cm5gIGJ5IGl0c2VsZiBpcyBub3RcbiAgICAvLyBjeWNsaWNhbCDigJQgaXQncyBvbmx5IGN5Y2xpY2FsIHdoZW4gY29tYmluZWQgd2l0aCBgY2hpbGRgLCBgc2libGluZ2AsIGFuZFxuICAgIC8vIGBhbHRlcm5hdGVgLiBCdXQgd2UnbGwgY2xlYXIgaXQgaW4gdGhlIG5leHQgbGV2ZWwgYW55d2F5LCBqdXN0IGluIGNhc2UuXG5cbiAgICB7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAgICAgLy8gZGlzY29ubmVjdGVkIHRoZSBmaWJlciBmcm9tIHRoZSB0cmVlLiBTbyBldmVuIGlmIHNvbWV0aGluZyBsZWFrcyB0aGlzXG4gICAgICAvLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2VcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIGJyYW5jaCBpcyB0byBiZSBzdXBlciBhZ2dyZXNzaXZlIHNvIHdlIGNhbiBtZWFzdXJlXG4gICAgICAvLyBpZiB0aGVyZSdzIGFueSBkaWZmZXJlbmNlIGluIG1lbW9yeSBpbXBhY3QuIElmIHRoZXJlIGlzLCB0aGF0IGNvdWxkXG4gICAgICAvLyBpbmRpY2F0ZSBhIFJlYWN0IGxlYWsgd2UgZG9uJ3Qga25vdyBhYm91dC5cbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cblxuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcbiAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgIHBlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBwZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgLy8gbm9kZS4gVW5mb3J0dW5hdGVseSwgaWYgbXVsdGlwbGUgaW5zZXJ0aW9ucyBhcmUgZG9uZSBpbiBhIHJvdyB3ZSBoYXZlIHRvXG4gIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAvLyBUT0RPOiBGaW5kIGEgbW9yZSBlZmZpY2llbnQgd2F5IHRvIGRvIHRoaXMuXG4gIHZhciBub2RlID0gZmliZXI7XG5cbiAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZS5yZXR1cm4pKSB7XG4gICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgLy8gbGFzdCBzaWJsaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCAmJiBub2RlLnRhZyAhPT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICBpZiAobm9kZS5mbGFncyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cblxuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuXG5cbiAgICBpZiAoIShub2RlLmZsYWdzICYgUGxhY2VtZW50KSkge1xuICAgICAgLy8gRm91bmQgaXQhXG4gICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IGN1cnJlbnQ7IC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7IC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuXG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuXG4gICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGU7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIG5vZGUsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpOyAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cblxuICAgIH0gZWxzZSBpZiAoIG5vZGUudGFnID09PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcblxuXG4gICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgICAgLy8gV2Ugd2lsbCByZWFzc2lnbiBpdCBiYWNrIHdoZW4gd2UgcG9wIHRoZSBwb3J0YWwgb24gdGhlIHdheSB1cC5cbiAgICAgICAgY3VycmVudFBhcmVudCA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgcG9ydGFscyBtaWdodCBjb250YWluIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIG5vZGUsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblxuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gIH1cblxuICBkZXRhY2hGaWJlck11dGF0aW9uKGN1cnJlbnQpO1xufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspOyAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbiAgICAgICAgICAvLyBkZXN0cm95IGZ1bmN0aW9ucyBmb3IgYWxsIGZpYmVycyBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgY3JlYXRlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cbiAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgYW4gT2Zmc2NyZWVuIHN1YnRyZWUgdGhhdCBkaXNhcHBlYXJlZFxuICAgICAgICAgIC8vIGR1cmluZyB0aGlzIGNvbW1pdC4gSWYgc28sIHdlIHdvdWxkIGhhdmUgYWxyZWFkeSB1bm1vdW50ZWQgaXRzXG4gICAgICAgICAgLy8gbGF5b3V0IGhvb2tzLiAoSG93ZXZlciwgc2luY2Ugd2UgbnVsbCBvdXQgdGhlIGBkZXN0cm95YCBmdW5jdGlvblxuICAgICAgICAgIC8vIHJpZ2h0IGJlZm9yZSBjYWxsaW5nIGl0LCB0aGUgYmVoYXZpb3IgaXMgYWxyZWFkeSBjb3JyZWN0LCBzbyB0aGlzXG4gICAgICAgICAgLy8gd291bGQgbW9zdGx5IGJlIGZvciBtb2RlbGluZyBwdXJwb3Nlcy4pXG5cbiAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcHJldlJvb3RTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTsgLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuXG4gICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTsgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZSb290U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChfcHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9yb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIoX3Jvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspO1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzICcgKyAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBwYXNzaXZlIHBoYXNlXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHdha2VhYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKGluUHJvZ3Jlc3NMYW5lcyAhPT0gbnVsbCAmJiBpblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgYXNzb2NpYXRlIHRoZSBvcmlnaW5hbCB1cGRhdGVycyB3aXRoIGl0LlxuICAgICAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKGluUHJvZ3Jlc3NSb290LCBpblByb2dyZXNzTGFuZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0V4cGVjdGVkIGZpbmlzaGVkIHJvb3QgYW5kIGxhbmVzIHRvIGJlIHNldC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG5cbmZ1bmN0aW9uIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQoY3VycmVudCkge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQsIGNvbW1pdHRlZExhbmVzKSB7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICBjb21taXRNdXRhdGlvbkVmZmVjdHNfYmVnaW4ocm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xuICBpblByb2dyZXNzUm9vdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c19iZWdpbihyb290LCBsYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRPRE86IFNob3VsZCB3cmFwIHRoaXMgaW4gZmxhZ3MgY2hlY2ssIHRvbywgYXMgb3B0aW1pemF0aW9uXG5cbiAgICB2YXIgZGVsZXRpb25zID0gZmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb21taXREZWxldGlvbihyb290LCBjaGlsZFRvRGVsZXRlLCBmaWJlcik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLCBmaWJlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGNoaWxkLCBmaWJlcik7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZShyb290LCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZShyb290LCBsYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgIHRyeSB7XG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpYmVyLCByb290LCBsYW5lcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvcik7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgZmliZXIucmV0dXJuKTtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKSB7XG4gIC8vIFRPRE86IFRoZSBmYWN0b3Jpbmcgb2YgdGhpcyBwaGFzZSBjb3VsZCBwcm9iYWJseSBiZSBpbXByb3ZlZC4gQ29uc2lkZXJcbiAgLy8gc3dpdGNoaW5nIG9uIHRoZSB0eXBlIG9mIHdvcmsgYmVmb3JlIGNoZWNraW5nIHRoZSBmbGFncy4gVGhhdCdzIHdoYXRcbiAgLy8gd2UgZG8gaW4gYWxsIHRoZSBvdGhlciBwaGFzZXMuIEkgdGhpbmsgdGhpcyBvbmUgaXMgb25seSBkaWZmZXJlbnRcbiAgLy8gYmVjYXVzZSBvZiB0aGUgc2hhcmVkIHJlY29uY2lsaWF0aW9uIGxvZ2ljIGJlbG93LlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKGZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChmaW5pc2hlZFdvcmspO1xuICB9XG5cbiAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gX2N1cnJlbnQgIT09IG51bGwgJiYgX2N1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCF3YXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9uZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgdmFyIF9pc0hpZGRlbiA9IF9uZXdTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgdmFyIF93YXNIaWRkZW4gPSBfY3VycmVudDIgIT09IG51bGwgJiYgX2N1cnJlbnQyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICB2YXIgb2Zmc2NyZWVuQm91bmRhcnkgPSBmaW5pc2hlZFdvcms7XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBuZWVkcyB0byBydW4gd2hlbmV2ZXIgdGhlcmUncyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlXG4gICAgICAgICAgICAvLyBpbnNpZGUgYSBoaWRkZW4gT2Zmc2NyZWVuIHRyZWUuXG4gICAgICAgICAgICBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihvZmZzY3JlZW5Cb3VuZGFyeSwgX2lzSGlkZGVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoX2lzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIGlmICghX3dhc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIGlmICgob2Zmc2NyZWVuQm91bmRhcnkubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gb2Zmc2NyZWVuQm91bmRhcnk7XG4gICAgICAgICAgICAgICAgICB2YXIgb2Zmc2NyZWVuQ2hpbGQgPSBvZmZzY3JlZW5Cb3VuZGFyeS5jaGlsZDtcblxuICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNjcmVlbkNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRFZmZlY3QgPSBvZmZzY3JlZW5DaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihvZmZzY3JlZW5DaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNjcmVlbkNoaWxkID0gb2Zmc2NyZWVuQ2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnkgcG9zc2libGVcbiAgLy8gYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlIGVmZmVjdCB0YWcgYW5kXG4gIC8vIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuXG5cbiAgdmFyIHByaW1hcnlGbGFncyA9IGZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IEh5ZHJhdGluZyk7XG5cbiAgIHN3aXRjaCAocHJpbWFyeUZsYWdzKSB7XG4gICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspOyAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAgICAgLy8gYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBraWxsIHRoaXMuXG5cbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cblxuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gflBsYWNlbWVudDsgLy8gVXBkYXRlXG5cbiAgICAgICAgdmFyIF9jdXJyZW50MyA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSHlkcmF0aW5nOlxuICAgICAge1xuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gfkh5ZHJhdGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEh5ZHJhdGluZ0FuZFVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5IeWRyYXRpbmc7IC8vIFVwZGF0ZVxuXG4gICAgICAgIHZhciBfY3VycmVudDQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50NCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9jdXJyZW50NSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQ1LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgbmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICAvLyBTdXNwZW5zZSBsYXlvdXQgZWZmZWN0cyBzZW1hbnRpY3MgZG9uJ3QgY2hhbmdlIGZvciBsZWdhY3kgcm9vdHMuXG4gIHZhciBpc01vZGVyblJvb3QgPSAoc3VidHJlZVJvb3QubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKCBmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBpc01vZGVyblJvb3QpIHtcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIHN0YWNrJ3Mgc3RhdGUuXG4gICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcblxuICAgICAgaWYgKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikge1xuICAgICAgICAvLyBUaGUgT2Zmc2NyZWVuIHRyZWUgaXMgaGlkZGVuLiBTa2lwIG92ZXIgaXRzIGxheW91dCBlZmZlY3RzLlxuICAgICAgICBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIEFsc28gY2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dE1hc2tcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB3YXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47IC8vIFRyYXZlcnNlIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3aXRoIHRoZSBjdXJyZW50IE9mZnNjcmVlbiBhcyB0aGUgcm9vdC5cblxuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuICYmICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSByZWFwcGVhcmluZyBib3VuZGFyeS4gVHVybiBpdHMgbGF5b3V0IGVmZmVjdHNcbiAgICAgICAgICAvLyBiYWNrIG9uLlxuICAgICAgICAgIG5leHRFZmZlY3QgPSBmaWJlcjtcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oZmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihjaGlsZCwgLy8gTmV3IHJvb3Q7IGJ1YmJsZSBiYWNrIHVwIHRvIGhlcmUgYW5kIHN0b3AuXG4gICAgICAgICAgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfSAvLyBSZXN0b3JlIE9mZnNjcmVlbiBzdGF0ZSBhbmQgcmVzdW1lIGluIG91ci1wcm9ncmVzcyB0cmF2ZXJzYWwuXG5cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MgJiYgZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoZmlyc3RDaGlsZCwgZmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGN1cnJlbnQsIGZpYmVyLCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKHNpYmxpbmcsIGZpYmVyLnJldHVybik7XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oc3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBmaXJzdENoaWxkID0gZmliZXIuY2hpbGQ7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgKFJlZlN0YXRpYyB8IExheW91dFN0YXRpYylcblxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCBmaWJlci5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmliZXIsIGZpYmVyLnJldHVybik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYVxuICAgICAgICAgIHZhciBpc0hpZGRlbiA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBhbHJlYWR5IGhpZGRlbi4gRG9uJ3QgZGlzYXBwZWFyXG4gICAgICAgICAgICAvLyBpdHMgZWZmZWN0cy5cbiAgICAgICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuXG5cbiAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoZmliZXIgPT09IHN1YnRyZWVSb290KSB7XG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmIChmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgICAgdmFyIGlzSGlkZGVuID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgIC8vIE5lc3RlZCBPZmZzY3JlZW4gdHJlZSBpcyBzdGlsbCBoaWRkZW4uIERvbid0IHJlLWFwcGVhciBpdHMgZWZmZWN0cy5cbiAgICAgICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBzdWJ0cmVlRmxhZ3MgJiBMYXlvdXRTdGF0aWNcblxuXG4gICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuICAgICAgLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIExheW91dFN0YXRpY1xuXG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgIHRyeSB7XG4gICAgICByZWFwcGVhckxheW91dEVmZmVjdHNPbkZpYmVyKGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbm9kZSBtYXkgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLCBzbyB3ZSBjYW4ndFxuICAgICAgLy8gYXNzdW1lIGl0cyByZXR1cm4gcG9pbnRlciBpcyBjb3JyZWN0LlxuICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIG5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4oZmluaXNoZWRXb3JrLCByb290KTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCwgcm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzICYmIGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGZpcnN0Q2hpbGQsIGZpYmVyKTtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCwgcm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgZmliZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihzaWJsaW5nLCBmaWJlci5yZXR1cm4pO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KFBhc3NpdmUkMSB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpcnN0Q2hpbGQpIHtcbiAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpO1xufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfYmVnaW4oKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgobmV4dEVmZmVjdC5mbGFncyAmIENoaWxkRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICB2YXIgZGVsZXRpb25zID0gZmliZXIuZGVsZXRpb25zO1xuXG4gICAgICBpZiAoZGVsZXRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpYmVyVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IGZpYmVyVG9EZWxldGU7XG4gICAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihmaWJlclRvRGVsZXRlLCBmaWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gQSBmaWJlciB3YXMgZGVsZXRlZCBmcm9tIHRoaXMgcGFyZW50IGZpYmVyLCBidXQgaXQncyBzdGlsbCBwYXJ0IG9mXG4gICAgICAgICAgLy8gdGhlIHByZXZpb3VzIChhbHRlcm5hdGUpIHBhcmVudCBmaWJlcidzIGxpc3Qgb2YgY2hpbGRyZW4uIEJlY2F1c2VcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhcmUgYSBsaW5rZWQgbGlzdCwgYW4gZWFybGllciBzaWJsaW5nIHRoYXQncyBzdGlsbCBhbGl2ZVxuICAgICAgICAgIC8vIHdpbGwgYmUgY29ubmVjdGVkIHRvIHRoZSBkZWxldGVkIGZpYmVyIHZpYSBpdHMgYGFsdGVybmF0ZWA6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgIGxpdmUgZmliZXJcbiAgICAgICAgICAvLyAgIC0tYWx0ZXJuYXRlLS0+IHByZXZpb3VzIGxpdmUgZmliZXJcbiAgICAgICAgICAvLyAgIC0tc2libGluZy0tPiBkZWxldGVkIGZpYmVyXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBXZSBjYW4ndCBkaXNjb25uZWN0IGBhbHRlcm5hdGVgIG9uIG5vZGVzIHRoYXQgaGF2ZW4ndCBiZWVuIGRlbGV0ZWRcbiAgICAgICAgICAvLyB5ZXQsIGJ1dCB3ZSBjYW4gZGlzY29ubmVjdCB0aGUgYHNpYmxpbmdgIGFuZCBgY2hpbGRgIHBvaW50ZXJzLlxuICAgICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkZXRhY2hlZENoaWxkID0gcHJldmlvdXNGaWJlci5jaGlsZDtcblxuICAgICAgICAgICAgaWYgKGRldGFjaGVkQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNGaWJlci5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBkZXRhY2hlZFNpYmxpbmcgPSBkZXRhY2hlZENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWRDaGlsZC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZXRhY2hlZENoaWxkID0gZGV0YWNoZWRTaWJsaW5nO1xuICAgICAgICAgICAgICB9IHdoaWxlIChkZXRhY2hlZENoaWxkICE9PSBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGVuc3VyZUNvcnJlY3RSZXR1cm5Qb2ludGVyKGNoaWxkLCBmaWJlcik7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaWJlcik7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihzaWJsaW5nLCBmaWJlci5yZXR1cm4pO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGRlbGV0ZWRTdWJ0cmVlUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIERlbGV0aW9uIGVmZmVjdHMgZmlyZSBpbiBwYXJlbnQgLT4gY2hpbGQgb3JkZXJcbiAgICAvLyBUT0RPOiBDaGVjayBpZiBmaWJlciBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWdcblxuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoZmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IC8vIFRPRE86IE9ubHkgdHJhdmVyc2Ugc3VidHJlZSBpZiBpdCBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWcuIChCdXQsIGlmIHdlXG4gICAgLy8gZG8gdGhpcywgc3RpbGwgbmVlZCB0byBoYW5kbGUgYGRlbGV0ZWRUcmVlQ2xlYW5VcExldmVsYCBjb3JyZWN0bHkuKVxuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlcihjaGlsZCwgZmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG4gICAgdmFyIHJldHVybkZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgdHJhdmVyc2UgdGhlIGVudGlyZSBkZWxldGVkIHRyZWUgYW5kIGNsZWFuIHVwIGZpYmVyIGZpZWxkcy5cbiAgICAgIC8vIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gaWRlYWwsIGFuZCB0aGUgbG9uZyB0ZXJtIGdvYWwgaXMgdG8gb25seVxuICAgICAgLy8gaGF2ZSB0byBkZXRhY2ggdGhlIGRlbGV0ZWQgdHJlZSBhdCB0aGUgcm9vdC5cbiAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKTtcblxuICAgICAgaWYgKGZpYmVyID09PSBkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoc2libGluZywgcmV0dXJuRmliZXIpO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW5zdXJlQ29ycmVjdFJldHVyblBvaW50ZXIoZmliZXIsIGV4cGVjdGVkUmV0dXJuRmliZXIpIHtcbiAge1xuICAgIGlmICghZGlkV2Fybldyb25nUmV0dXJuUG9pbnRlciAmJiBmaWJlci5yZXR1cm4gIT09IGV4cGVjdGVkUmV0dXJuRmliZXIpIHtcbiAgICAgIGRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIgPSB0cnVlO1xuXG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IFJldHVybiBwb2ludGVyIGlzIGluY29uc2lzdGVudCAnICsgJ3dpdGggcGFyZW50LicpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhc3NpZ25tZW50IG9uY2Ugd2UncmUgY29uZmlkZW50IHRoYXQgaXQgd29uJ3QgYnJlYWtcbiAgLy8gYW55dGhpbmcsIGJ5IGNoZWNraW5nIHRoZSB3YXJuaW5nIGxvZ3MgZm9yIHRoZSBhYm92ZSBpbnZhcmlhbnRcblxuXG4gIGZpYmVyLnJldHVybiA9IGV4cGVjdGVkUmV0dXJuRmliZXI7XG59IC8vIFRPRE86IFJldXNlIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyB0cmF2ZXJzYWwgaGVyZT9cblxuXG5mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmliZXIpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVihmaWJlcikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKTtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmliZXIsIGZpYmVyLnJldHVybiwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRVbmNhdWdodEVycm9ySW5ERVYoZXJyb3IpO1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgQ09NUE9ORU5UX1RZUEUgPSAwO1xudmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG52YXIgUk9MRV9UWVBFID0gMjtcbnZhciBURVNUX05BTUVfVFlQRSA9IDM7XG52YXIgVEVYVF9UWVBFID0gNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtcbiAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRTZWxlY3Rvcihjb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogQ09NUE9ORU5UX1RZUEUsXG4gICAgdmFsdWU6IGNvbXBvbmVudFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLFxuICAgIHZhbHVlOiBzZWxlY3RvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvbGVTZWxlY3Rvcihyb2xlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJPTEVfVFlQRSxcbiAgICB2YWx1ZTogcm9sZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFNlbGVjdG9yKHRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogVEVYVF9UWVBFLFxuICAgIHZhbHVlOiB0ZXh0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yKGlkKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFRFU1RfTkFNRV9UWVBFLFxuICAgIHZhbHVlOiBpZFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgdmFyIG1heWJlRmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGhvc3RSb290KTtcblxuICBpZiAobWF5YmVGaWJlciAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZUZpYmVyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaWJlclJvb3QgPSBmaW5kRmliZXJSb290KGhvc3RSb290KTtcblxuICAgIGlmIChmaWJlclJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgUmVhY3QgY29udGFpbmVyIHdpdGhpbiBzcGVjaWZpZWQgaG9zdCBzdWJ0cmVlLicpO1xuICAgIH0gLy8gVGhlIEZsb3cgdHlwZSBmb3IgRmliZXJSb290IGlzIGEgbGl0dGxlIGZ1bmt5LlxuICAgIC8vIGNyZWF0ZUZpYmVyUm9vdCgpIGNoZWF0cyB0aGlzIGJ5IHRyZWF0aW5nIHRoZSByb290IGFzIDphbnkgYW5kIGFkZGluZyBzdGF0ZU5vZGUgbGF6aWx5LlxuXG5cbiAgICByZXR1cm4gZmliZXJSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSB7XG4gIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnR5cGUgPT09IHNlbGVjdG9yLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgcmV0dXJuIGhhc01hdGNoaW5nUGF0aHMoZmliZXIsIHNlbGVjdG9yLnZhbHVlKTtcblxuICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZShub2RlLCBzZWxlY3Rvci52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGZpYmVyKTtcblxuICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgdGV4dENvbnRlbnQuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGRhdGFUZXN0SUQgPSBmaWJlci5tZW1vaXplZFByb3BzWydkYXRhLXRlc3RuYW1lJ107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhVGVzdElEID09PSAnc3RyaW5nJyAmJiBkYXRhVGVzdElELnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuJyk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcbiAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoc2VsZWN0b3IudmFsdWUpIHx8ICdVbmtub3duJztcbiAgICAgIHJldHVybiBcIjxcIiArIGRpc3BsYXlOYW1lICsgXCI+XCI7XG5cbiAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgJycpICsgXCIpXCI7XG5cbiAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgIHJldHVybiBcIltyb2xlPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBzZWxlY3Rvci52YWx1ZSArIFwiXFxcIlwiO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIHJldHVybiBcIltkYXRhLXRlc3RuYW1lPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgbWF0Y2hpbmdGaWJlcnMucHVzaChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hpbmdGaWJlcnM7XG59IC8vIFNhbWUgYXMgZmluZFBhdGhzIGJ1dCB3aXRoIGVhZ2VyIGJhaWxvdXQgb24gZmlyc3QgbWF0Y2hcblxuXG5mdW5jdGlvbiBoYXNNYXRjaGluZ1BhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9ySW5kZXggPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF07XG5cbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpO1xuICB2YXIgaW5zdGFuY2VSb290cyA9IFtdO1xuICB2YXIgc3RhY2sgPSBBcnJheS5mcm9tKG1hdGNoaW5nRmliZXJzKTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgbm9kZSA9IHN0YWNrW2luZGV4KytdO1xuXG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZVJvb3RzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2VSb290cztcbn1cbmZ1bmN0aW9uIGdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbihob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXhTZWxlY3RvckluZGV4ID0gMDtcbiAgdmFyIG1hdGNoZWROYW1lcyA9IFtdOyAvLyBUaGUgbG9naWMgb2YgdGhpcyBsb29wIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCBmaW5kUGF0aHMoKVxuXG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgc2VsZWN0b3JJbmRleCA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgIG1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpKTtcbiAgICAgIHNlbGVjdG9ySW5kZXgrKztcblxuICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4KSB7XG4gICAgICAgIG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgIHZhciB1bm1hdGNoZWROYW1lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heFNlbGVjdG9ySW5kZXg7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcnNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ2ZpbmRBbGxOb2RlcyB3YXMgYWJsZSB0byBtYXRjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvcjpcXG4nICsgKFwiICBcIiArIG1hdGNoZWROYW1lcy5qb2luKCcgPiAnKSArIFwiXFxuXFxuXCIpICsgJ05vIG1hdGNoaW5nIGNvbXBvbmVudCB3YXMgZm91bmQgZm9yOlxcbicgKyAoXCIgIFwiICsgdW5tYXRjaGVkTmFtZXMuam9pbignID4gJykpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQm91bmRpbmdSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIGJvdW5kaW5nUmVjdHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlUm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICBib3VuZGluZ1JlY3RzLnB1c2goZ2V0Qm91bmRpbmdSZWN0KGluc3RhbmNlUm9vdHNbaV0pKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gYm91bmRpbmdSZWN0cy5sZW5ndGggLSAxOyBfaSA+IDA7IF9pLS0pIHtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IGJvdW5kaW5nUmVjdHNbX2ldO1xuICAgIHZhciB0YXJnZXRMZWZ0ID0gdGFyZ2V0UmVjdC54O1xuICAgIHZhciB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0Lnk7XG4gICAgdmFyIHRhcmdldEJvdHRvbSA9IHRhcmdldFRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaiA9IF9pIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChfaSAhPT0gaikge1xuICAgICAgICB2YXIgb3RoZXJSZWN0ID0gYm91bmRpbmdSZWN0c1tqXTtcbiAgICAgICAgdmFyIG90aGVyTGVmdCA9IG90aGVyUmVjdC54O1xuICAgICAgICB2YXIgb3RoZXJSaWdodCA9IG90aGVyTGVmdCArIG90aGVyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIG90aGVyVG9wID0gb3RoZXJSZWN0Lnk7XG4gICAgICAgIHZhciBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDsgLy8gTWVyZ2luZyBhbGwgcmVjdHMgdG8gdGhlIG1pbmltdW1zIHNldCB3b3VsZCBiZSBjb21wbGljYXRlZCxcbiAgICAgICAgLy8gYnV0IHdlIGNhbiBoYW5kbGUgdGhlIG1vc3QgY29tbW9uIGNhc2VzOlxuICAgICAgICAvLyAxLiBjb21wbGV0ZWx5IG92ZXJsYXBwaW5nIHJlY3RzXG4gICAgICAgIC8vIDIuIGFkamFjZW50IHJlY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHdpZHRoIG9yIGhlaWdodCAoZS5nLiBpdGVtcyBpbiBhIGxpc3QpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV2ZW4gZ2l2ZW4gdGhlIGFib3ZlIGNvbnN0cmFpbnRzLFxuICAgICAgICAvLyB3ZSBzdGlsbCB3b24ndCBlbmQgdXAgd2l0aCB0aGUgZmV3ZXN0IHBvc3NpYmxlIHJlY3RzIHdpdGhvdXQgZG9pbmcgbXVsdGlwbGUgcGFzc2VzLFxuICAgICAgICAvLyBidXQgaXQncyBnb29kIGVub3VnaCBmb3IgdGhpcyBwdXJwb3NlLlxuXG4gICAgICAgIGlmICh0YXJnZXRMZWZ0ID49IG90aGVyTGVmdCAmJiB0YXJnZXRUb3AgPj0gb3RoZXJUb3AgJiYgdGFyZ2V0UmlnaHQgPD0gb3RoZXJSaWdodCAmJiB0YXJnZXRCb3R0b20gPD0gb3RoZXJCb3R0b20pIHtcbiAgICAgICAgICAvLyBDb21wbGV0ZSBvdmVybGFwcGluZyByZWN0czsgcmVtb3ZlIHRoZSBpbm5lciBvbmUuXG4gICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldExlZnQgPT09IG90aGVyTGVmdCAmJiB0YXJnZXRSZWN0LndpZHRoID09PSBvdGhlclJlY3Qud2lkdGggJiYgIShvdGhlckJvdHRvbSA8IHRhcmdldFRvcCkgJiYgIShvdGhlclRvcCA+IHRhcmdldEJvdHRvbSkpIHtcbiAgICAgICAgICAvLyBBZGphY2VudCB2ZXJ0aWNhbCByZWN0czsgbWVyZ2UgdGhlbS5cbiAgICAgICAgICBpZiAob3RoZXJUb3AgPiB0YXJnZXRUb3ApIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgKz0gb3RoZXJUb3AgLSB0YXJnZXRUb3A7XG4gICAgICAgICAgICBvdGhlclJlY3QueSA9IHRhcmdldFRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXJCb3R0b20gPCB0YXJnZXRCb3R0b20pIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZGluZ1JlY3RzLnNwbGljZShfaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VG9wID09PSBvdGhlclRvcCAmJiB0YXJnZXRSZWN0LmhlaWdodCA9PT0gb3RoZXJSZWN0LmhlaWdodCAmJiAhKG90aGVyUmlnaHQgPCB0YXJnZXRMZWZ0KSAmJiAhKG90aGVyTGVmdCA+IHRhcmdldFJpZ2h0KSkge1xuICAgICAgICAgIC8vIEFkamFjZW50IGhvcml6b250YWwgcmVjdHM7IG1lcmdlIHRoZW0uXG4gICAgICAgICAgaWYgKG90aGVyTGVmdCA+IHRhcmdldExlZnQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCArPSBvdGhlckxlZnQgLSB0YXJnZXRMZWZ0O1xuICAgICAgICAgICAgb3RoZXJSZWN0LnggPSB0YXJnZXRMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlclJpZ2h0IDwgdGFyZ2V0UmlnaHQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kaW5nUmVjdHMuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZGluZ1JlY3RzO1xufVxuZnVuY3Rpb24gZm9jdXNXaXRoaW4oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIHN0YWNrID0gQXJyYXkuZnJvbShtYXRjaGluZ0ZpYmVycyk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG5cbiAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgdmFyIG5vZGUgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChzZXRGb2N1c0lmRm9jdXNhYmxlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzdGFjay5wdXNoKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCkge1xuICBpZiAoc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gb2JzZXJ2ZVZpc2libGVSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG5cbiAgdmFyIF9zZXR1cEludGVyc2VjdGlvbk9icyA9IHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW5zdGFuY2VSb290cywgY2FsbGJhY2ssIG9wdGlvbnMpLFxuICAgICAgZGlzY29ubmVjdCA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5kaXNjb25uZWN0LFxuICAgICAgb2JzZXJ2ZSA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5vYnNlcnZlLFxuICAgICAgdW5vYnNlcnZlID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLnVub2JzZXJ2ZTsgLy8gV2hlbiBSZWFjdCBtdXRhdGVzIHRoZSBob3N0IGVudmlyb25tZW50LCB3ZSBtYXkgbmVlZCB0byBjaGFuZ2Ugd2hhdCB3ZSdyZSBsaXN0ZW5pbmcgdG8uXG5cblxuICB2YXIgY29tbWl0SG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgaW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgIHVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5leHRJbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKGluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuICAgICAgICBvYnNlcnZlKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcbiAgcmV0dXJuIHtcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgUmVhY3QgbXV0YXRpb25zOlxuICAgICAgdmFyIGluZGV4ID0gY29tbWl0SG9va3MuaW5kZXhPZihjb21taXRIb29rKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0gLy8gRGlzY29ubmVjdCB0aGUgaG9zdCBvYnNlcnZlcjpcblxuXG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRBY3RRdWV1ZTtcbmZ1bmN0aW9uIGlzTGVnYWN5QWN0RW52aXJvbm1lbnQoZmliZXIpIHtcbiAge1xuICAgIC8vIExlZ2FjeSBtb2RlLiBXZSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2YgUmVhY3QgMTcncyBhY3QuIEl0IGFzc3VtZXMgYW5cbiAgICAvLyBhY3QgZW52aXJvbm1lbnQgd2hlbmV2ZXIgYGplc3RgIGlzIGRlZmluZWQsIGJ1dCB5b3UgY2FuIHN0aWxsIHR1cm4gb2ZmXG4gICAgLy8gc3B1cmlvdXMgd2FybmluZ3MgYnkgc2V0dGluZyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZXhwbGljaXRseVxuICAgIC8vIHRvIGZhbHNlLlxuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDsgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgamVzdFxuXG4gICAgdmFyIGplc3RJc0RlZmluZWQgPSB0eXBlb2YgamVzdCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgcmV0dXJuIHdhcm5zSWZOb3RBY3RpbmcgJiYgamVzdElzRGVmaW5lZCAmJiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgIT09IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAge1xuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG4gICAgICBlcnJvcignVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0ICcgKyAnYWN0KC4uLiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICB9XG59XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBDb21taXRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgICovXG40O1xudmFyIFJvb3RJblByb2dyZXNzID0gMDtcbnZhciBSb290RmF0YWxFcnJvcmVkID0gMTtcbnZhciBSb290RXJyb3JlZCA9IDI7XG52YXIgUm9vdFN1c3BlbmRlZCA9IDM7XG52YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQ7XG52YXIgUm9vdENvbXBsZXRlZCA9IDU7XG52YXIgUm9vdERpZE5vdENvbXBsZXRlID0gNjsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7IC8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cbi8vIFdlIHdpbGwgbG9nIHRoZW0gb25jZSB0aGUgdHJlZSBjb21taXRzLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsOyAvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBjb21taXR0ZWQgYSBmYWxsYmFjay4gVGhpcyBsZXRzIHVzIGVuc3VyZSBhIHRyYWluXG4vLyBtb2RlbCB3aGVyZSB3ZSBkb24ndCBjb21taXQgbmV3IGxvYWRpbmcgc3RhdGVzIGluIHRvbyBxdWljayBzdWNjZXNzaW9uLlxuXG52YXIgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDA7XG52YXIgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSA1MDA7IC8vIFRoZSBhYnNvbHV0ZSB0aW1lIGZvciB3aGVuIHdlIHNob3VsZCBzdGFydCBnaXZpbmcgdXAgb24gcmVuZGVyaW5nXG4vLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eTsgLy8gSG93IGxvbmcgYSByZW5kZXIgaXMgc3VwcG9zZWQgdG8gdGFrZSBiZWZvcmUgd2Ugc3RhcnQgZm9sbG93aW5nIENQVVxuLy8gc3VzcGVuc2UgaGV1cmlzdGljcyBhbmQgb3B0IG91dCBvZiByZW5kZXJpbmcgbW9yZSBjb250ZW50LlxuXG52YXIgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDA7XG5cbmZ1bmN0aW9uIHJlc2V0UmVuZGVyVGltZXIoKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbnZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDsgLy8gT25seSB1c2VkIHdoZW4gZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVTY2hlZHVsZWRIb29rIGlzIHRydWU7XG52YXIgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG52YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xudmFyIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDsgLy8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxudmFyIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbnZhciBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZXM7XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG59XG5mdW5jdGlvbiByZXF1ZXN0RXZlbnRUaW1lKCkge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIFJlYWN0LCBzbyBpdCdzIGZpbmUgdG8gcmVhZCB0aGUgYWN0dWFsIHRpbWUuXG4gICAgcmV0dXJuIG5vdyQxKCk7XG4gIH0gLy8gV2UncmUgbm90IGluc2lkZSBSZWFjdCwgc28gd2UgbWF5IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBicm93c2VyIGV2ZW50LlxuXG5cbiAgaWYgKGN1cnJlbnRFdmVudFRpbWUgIT09IE5vVGltZXN0YW1wKSB7XG4gICAgLy8gVXNlIHRoZSBzYW1lIHN0YXJ0IHRpbWUgZm9yIGFsbCB1cGRhdGVzIHVudGlsIHdlIGVudGVyIFJlYWN0IGFnYWluLlxuICAgIHJldHVybiBjdXJyZW50RXZlbnRUaW1lO1xuICB9IC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZSBzaW5jZSBSZWFjdCB5aWVsZGVkLiBDb21wdXRlIGEgbmV3IHN0YXJ0IHRpbWUuXG5cblxuICBjdXJyZW50RXZlbnRUaW1lID0gbm93JDEoKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICggKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFRoZXNlIGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFRoZVxuICAgIC8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG4gICAgLy8gd2hhdGV2ZXIgaXMgY3VycmVudGx5IHJlbmRlcmluZy4gU28gaWYgeW91IGNhbGwgYHNldFN0YXRlYCBvbiBhIGNvbXBvbmVudFxuICAgIC8vIHRoYXQgaGFwcGVucyBsYXRlciBpbiB0aGUgc2FtZSByZW5kZXIsIGl0IHdpbGwgZmx1c2guIElkZWFsbHksIHdlIHdhbnQgdG9cbiAgICAvLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuICAgIC8vIGludGVybGVhdmVkIGV2ZW50LiBSZWdhcmRsZXNzLCB0aGlzIHBhdHRlcm4gaXMgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgb25seSBhIGZhbGxiYWNrLiBUaGUgZmxhZyBvbmx5IGV4aXN0cyB1bnRpbCB3ZSBjYW4gcm9sbFxuICAgIC8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuICAgIC8vIHRoZSBjdXJyZW50IGJlaGF2aW9yLlxuICAgIHJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaXNUcmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkgIT09IE5vVHJhbnNpdGlvbjtcblxuICBpZiAoaXNUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO1xuICAgIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gICAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZVxuICAgIC8vIGlucHV0cyB0byB0aGUgYWxnb3JpdGhtIG11c3QgYmUgdGhlIHNhbWUuXG4gICAgLy9cbiAgICAvLyBUaGUgdHJpY2sgd2UgdXNlIGlzIHRvIGNhY2hlIHRoZSBmaXJzdCBvZiBlYWNoIG9mIHRoZXNlIGlucHV0cyB3aXRoaW4gYW5cbiAgICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpc1xuICAgIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cblxuXG4gICAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIEFsbCB0cmFuc2l0aW9ucyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgYXJlIGFzc2lnbmVkIHRoZSBzYW1lIGxhbmUuXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xuICB9IC8vIFVwZGF0ZXMgb3JpZ2luYXRpbmcgaW5zaWRlIGNlcnRhaW4gUmVhY3QgbWV0aG9kcywgbGlrZSBmbHVzaFN5bmMsIGhhdmVcbiAgLy8gdGhlaXIgcHJpb3JpdHkgc2V0IGJ5IHRyYWNraW5nIGl0IHdpdGggYSBjb250ZXh0IHZhcmlhYmxlLlxuICAvL1xuICAvLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cbiAgLy8gdXNlIHRoYXQgZGlyZWN0bHkuXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cblxuXG4gIHZhciB1cGRhdGVMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IE5vTGFuZSkge1xuICAgIHJldHVybiB1cGRhdGVMYW5lO1xuICB9IC8vIFRoaXMgdXBkYXRlIG9yaWdpbmF0ZWQgb3V0c2lkZSBSZWFjdC4gQXNrIHRoZSBob3N0IGVudmlyb25tZW50IGZvciBhblxuICAvLyBhcHByb3ByaWF0ZSBwcmlvcml0eSwgYmFzZWQgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG4gIC8vXG4gIC8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuICAvLyB1c2UgdGhhdCBkaXJlY3RseS5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHR5cGUgY29udmVyc2lvbiB0byB0aGUgZXZlbnQgcHJpb3JpdHkgbW9kdWxlLlxuXG5cbiAgdmFyIGV2ZW50TGFuZSA9IGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCk7XG4gIHJldHVybiBldmVudExhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfVxuXG4gIHJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIGxhbmUpO1xuXG4gIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vTGFuZXMgJiYgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gVGhpcyB1cGRhdGUgd2FzIGRpc3BhdGNoZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXMgaXMgYSBtaXN0YWtlXG4gICAgLy8gaWYgdGhlIHVwZGF0ZSBvcmlnaW5hdGVzIGZyb20gdXNlciBzcGFjZSAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIGxvY2FsXG4gICAgLy8gaG9vayB1cGRhdGVzLCB3aGljaCBhcmUgaGFuZGxlZCBkaWZmZXJlbnRseSBhbmQgZG9uJ3QgcmVhY2ggdGhpc1xuICAgIC8vIGZ1bmN0aW9uKSwgYnV0IHRoZXJlIGFyZSBzb21lIGludGVybmFsIFJlYWN0IGZlYXR1cmVzIHRoYXQgdXNlIHRoaXMgYXNcbiAgICAvLyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGxpa2Ugc2VsZWN0aXZlIGh5ZHJhdGlvbi5cbiAgICB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcik7IC8vIFRyYWNrIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIG5vcm1hbCB1cGRhdGUsIHNjaGVkdWxlZCBmcm9tIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS4gRm9yXG4gICAgLy8gZXhhbXBsZSwgZHVyaW5nIGFuIGlucHV0IGV2ZW50LlxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcik7XG5cbiAgICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgICAvLyBUT0RPOiBDb25zb2xpZGF0ZSB3aXRoIGBpc0ludGVybGVhdmVkVXBkYXRlYCBjaGVja1xuICAgICAgLy8gUmVjZWl2ZWQgYW4gdXBkYXRlIHRvIGEgdHJlZSB0aGF0J3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuIE1hcmtcbiAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgICAgLy8gYGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaGAgZmxhZyBpcyBvZmYgYW5kIHRoaXMgaXMgYSByZW5kZXJcbiAgICAgIC8vIHBoYXNlIHVwZGF0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBkb24ndCB0cmVhdCByZW5kZXIgcGhhc2UgdXBkYXRlcyBhcyBpZlxuICAgICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgICAgaWYgKCAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgICAgLy8gc3VzcGVuZGVkIG5vdywgcmlnaHQgYmVmb3JlIG1hcmtpbmcgdGhlIGluY29taW5nIHVwZGF0ZS4gVGhpcyBoYXMgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgICAvLyBhbHJlYWR5IHN0YXJ0ZWQgcmVuZGVyaW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChsYW5lID09PSBTeW5jTGFuZSAmJiBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgIC8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2ZcbiAgICAgIC8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAvLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSkge1xuICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBmb3JrIG9mIHNjaGVkdWxlVXBkYXRlT25GaWJlciB0aGF0IGlzIG9ubHkgdXNlZCB0b1xuICAvLyBzY2hlZHVsZSB0aGUgaW5pdGlhbCBoeWRyYXRpb24gb2YgYSByb290IHRoYXQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLiBNb3N0XG4gIC8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG4gIC8vXG4gIC8vIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBzZXBhcmF0ZSBwYXRoLCB0aG91Z2gsIGlzIHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAvLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcbiAgLy8gKGNyZWF0ZVJvb3QgaW5zdGVhZCBvZiBoeWRyYXRlUm9vdCksIGFsbCB0b3AtbGV2ZWwgcmVuZGVycyBhcmUgbW9kZWxlZCBhc1xuICAvLyB1cGRhdGVzLCBidXQgaHlkcmF0aW9uIHJvb3RzIGFyZSBzcGVjaWFsIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3RcbiAgLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIGN1cnJlbnQubGFuZXMgPSBsYW5lO1xuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG59IC8vIFRoaXMgaXMgc3BsaXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIHdlIGNhbiBtYXJrIGEgZmliZXIgd2l0aCBwZW5kaW5nXG4vLyB3b3JrIHdpdGhvdXQgdHJlYXRpbmcgaXQgYXMgYSB0eXBpY2FsIHVwZGF0ZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBhbiBldmVudDtcbi8vIGUuZy4gcmV0cnlpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBpc24ndCBhbiB1cGRhdGUsIGJ1dCBpdCBkb2VzIHNjaGVkdWxlIHdvcmtcbi8vIG9uIGEgZmliZXIuXG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBsYW5lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgbGFuZXNcbiAgc291cmNlRmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9XG5cbiAge1xuICAgIGlmIChhbHRlcm5hdGUgPT09IG51bGwgJiYgKHNvdXJjZUZpYmVyLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICB9XG4gIH0gLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMuXG5cblxuICB2YXIgbm9kZSA9IHNvdXJjZUZpYmVyO1xuICB2YXIgcGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBwYXJlbnQuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMocGFyZW50LmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG5cbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIGxhbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICgocGFyZW50LmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gcGFyZW50O1xuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyLCBsYW5lKSB7XG4gIHJldHVybiAoLy8gVE9ETzogT3B0aW1pemUgc2xpZ2h0bHkgYnkgY29tcGFyaW5nIHRvIHJvb3QgdGhhdCBmaWJlciBiZWxvbmdzIHRvLlxuICAgIC8vIFJlcXVpcmVzIHNvbWUgcmVmYWN0b3JpbmcuIE5vdCBhIGJpZyBkZWFsIHRob3VnaCBzaW5jZSBpdCdzIHJhcmUgZm9yXG4gICAgLy8gY29uY3VycmVudCBhcHBzIHRvIGhhdmUgbW9yZSB0aGFuIGEgc2luZ2xlIHJvb3QuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsICYmIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKCAvLyBJZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZSAoaS5lLiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyksXG4gICAgLy8gdGhlbiBkb24ndCB0cmVhdCB0aGlzIGFzIGFuIGludGVybGVhdmVkIHVwZGF0ZS4gVGhpcyBwYXR0ZXJuIGlzXG4gICAgLy8gYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nIGJ1dCB3ZSBoYXZlbid0IGZ1bGx5IGRlcHJlY2F0ZWQgaXQgeWV0LiBXZSBjYW5cbiAgICAvLyByZW1vdmUgb25jZSB0aGUgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoIGZsYWcgaXMgZW5hYmxlZC5cbiAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KVxuICApO1xufSAvLyBVc2UgdGhpcyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHRhc2sgZm9yIGEgcm9vdC4gVGhlcmUncyBvbmx5IG9uZSB0YXNrIHBlclxuLy8gcm9vdDsgaWYgYSB0YXNrIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCwgd2UnbGwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBwcmlvcml0eVxuLy8gb2YgdGhlIGV4aXN0aW5nIHRhc2sgaXMgdGhlIHNhbWUgYXMgdGhlIHByaW9yaXR5IG9mIHRoZSBuZXh0IGxldmVsIHRoYXQgdGhlXG4vLyByb290IGhhcyB3b3JrIG9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUsIGFuZCByaWdodCBiZWZvcmVcbi8vIGV4aXRpbmcgYSB0YXNrLlxuXG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7IC8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4gIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgICByZXR1cm47XG4gIH0gLy8gV2UgdXNlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGxhbmUgdG8gcmVwcmVzZW50IHRoZSBwcmlvcml0eSBvZiB0aGUgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cblxuICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gIGlmIChleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPT09IG5ld0NhbGxiYWNrUHJpb3JpdHkgJiYgLy8gU3BlY2lhbCBjYXNlIHJlbGF0ZWQgdG8gYGFjdGAuIElmIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHRhc2sgaXMgYVxuICAvLyBTY2hlZHVsZXIgdGFzaywgcmF0aGVyIHRoYW4gYW4gYGFjdGAgdGFzaywgY2FuY2VsIGl0IGFuZCByZS1zY2hlZHVsZWRcbiAgLy8gb24gdGhlIGBhY3RgIHF1ZXVlLlxuICAhKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGwgJiYgZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUpKSB7XG4gICAge1xuICAgICAgLy8gSWYgd2UncmUgZ29pbmcgdG8gcmUtdXNlIGFuIGV4aXN0aW5nIHRhc2ssIGl0IG5lZWRzIHRvIGV4aXN0LlxuICAgICAgLy8gQXNzdW1lIHRoYXQgZGlzY3JldGUgdXBkYXRlIG1pY3JvdGFza3MgYXJlIG5vbi1jYW5jZWxsYWJsZSBhbmQgbnVsbC5cbiAgICAgIC8vIFRPRE86IFRlbXBvcmFyeSB1bnRpbCB3ZSBjb25maXJtIHRoaXMgd2FybmluZyBpcyBub3QgZmlyZWQuXG4gICAgICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgPT0gbnVsbCAmJiBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgIT09IFN5bmNMYW5lKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCBzY2hlZHVsZWQgY2FsbGJhY2sgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay4gRXhpdC5cblxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9IG51bGwpIHtcbiAgICAvLyBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ldyBvbmUgYmVsb3cuXG4gICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gIH0gLy8gU2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tOb2RlO1xuXG4gIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBTeW5jTGFuZSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU3luYyBSZWFjdCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZCBvbiBhIHNwZWNpYWxcbiAgICAvLyBpbnRlcm5hbCBxdWV1ZVxuICAgIGlmIChyb290LnRhZyA9PT0gTGVnYWN5Um9vdCkge1xuICAgICAgaWYgKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmlzQmF0Y2hpbmdMZWdhY3kgIT09IG51bGwpIHtcbiAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0c01pY3JvdGFza3MpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBxdWV1ZSBpbiBhIG1pY3JvdGFzay5cbiAgICAgIGlmICggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEluc2lkZSBgYWN0YCwgdXNlIG91ciBpbnRlcm5hbCBgYWN0YCBxdWV1ZSBzbyB0aGF0IHRoZXNlIGdldCBmbHVzaGVkXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NvcGUgZXZlbiB3aGVuIHVzaW5nIHRoZSBzeW5jIHZlcnNpb25cbiAgICAgICAgLy8gb2YgYGFjdGAuXG4gICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudC5wdXNoKGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gSW4gU2FmYXJpLCBhcHBlbmRpbmcgYW4gaWZyYW1lIGZvcmNlcyBtaWNyb3Rhc2tzIHRvIHJ1bi5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyNDU5XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBydW5uaW5nIGNhbGxiYWNrcyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlclxuICAgICAgICAgIC8vIG9yIGNvbW1pdCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdGhhdC5cbiAgICAgICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJdCdzIG9ubHkgc2FmZSB0byBkbyB0aGlzIGNvbmRpdGlvbmFsbHkgYmVjYXVzZSB3ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBwZW5kaW5nIHdvcmsgYmVmb3JlIHdlIGV4aXQgdGhlIHRhc2suXG4gICAgICAgICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCB0aGUgcXVldWUgaW4gYW4gSW1tZWRpYXRlIHRhc2suXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgfVxuXG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbDtcblxuICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkobmV4dExhbmVzKSkge1xuICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSWRsZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlQ2FsbGJhY2skMShzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH1cblxuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290LCBkaWRUaW1lb3V0KSB7XG4gIHtcbiAgICByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKTtcbiAgfSAvLyBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIGEgUmVhY3QgZXZlbnQsIHdlIGNhbiBjbGVhciB0aGUgY3VycmVudFxuICAvLyBldmVudCB0aW1lLiBUaGUgbmV4dCB1cGRhdGUgd2lsbCBjb21wdXRlIGEgbmV3IGV2ZW50IHRpbWUuXG5cblxuICBjdXJyZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG4gIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gTm9MYW5lcztcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfSAvLyBGbHVzaCBhbnkgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGRlY2lkaW5nIHdoaWNoIGxhbmVzIHRvIHdvcmsgb24sXG4gIC8vIGluIGNhc2UgdGhleSBzY2hlZHVsZSBhZGRpdGlvbmFsIHdvcmsuXG5cblxuICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgdmFyIGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cbiAgaWYgKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHBhc3NpdmUgZWZmZWN0IHBoYXNlIG1heSBoYXZlIGNhbmNlbGVkIHRoZSBjdXJyZW50IHRhc2suXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhc2sgbm9kZSBmb3IgdGhpcyByb290IHdhcyBjaGFuZ2VkLlxuICAgIGlmIChyb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRhc2sgd2FzIGNhbmNlbGVkLiBFeGl0LiBXZSBkb24ndCBuZWVkIHRvIGNhbGxcbiAgICAgIC8vIGBlbnN1cmVSb290SXNTY2hlZHVsZWRgIGJlY2F1c2UgdGhlIGNoZWNrIGFib3ZlIGltcGxpZXMgZWl0aGVyIHRoYXRcbiAgICAgIC8vIHRoZXJlJ3MgYSBuZXcgdGFzaywgb3IgdGhhdCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBXZSBkaXNhYmxlIHRpbWUtc2xpY2luZyBpbiBzb21lIGNhc2VzOiBpZiB0aGUgd29yayBoYXMgYmVlbiBDUFUtYm91bmRcbiAgLy8gZm9yIHRvbyBsb25nIChcImV4cGlyZWRcIiB3b3JrLCB0byBwcmV2ZW50IHN0YXJ2YXRpb24pLCBvciB3ZSdyZSBpblxuICAvLyBzeW5jLXVwZGF0ZXMtYnktZGVmYXVsdCBtb2RlLlxuICAvLyBUT0RPOiBXZSBvbmx5IGNoZWNrIGBkaWRUaW1lb3V0YCBkZWZlbnNpdmVseSwgdG8gYWNjb3VudCBmb3IgYSBTY2hlZHVsZXJcbiAgLy8gYnVnIHdlJ3JlIHN0aWxsIGludmVzdGlnYXRpbmcuIE9uY2UgdGhlIGJ1ZyBpbiBTY2hlZHVsZXIgaXMgZml4ZWQsXG4gIC8vIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2UgdHJhY2sgZXhwaXJhdGlvbiBvdXJzZWx2ZXMuXG5cblxuICB2YXIgc2hvdWxkVGltZVNsaWNlID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSAmJiAhaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykgJiYgKCAhZGlkVGltZW91dCk7XG4gIHZhciBleGl0U3RhdHVzID0gc2hvdWxkVGltZVNsaWNlID8gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5Qcm9ncmVzcykge1xuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsXG4gICAgICAvLyByZW5kZXIgc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGxcbiAgICAgIC8vIGluY2x1ZGVzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlclxuICAgICAgLy8gdGhlIHNlY29uZCBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICBleGl0U3RhdHVzID0gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgICAgdmFyIGZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3REaWROb3RDb21wbGV0ZSkge1xuICAgICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbiAgICAgIC8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuICAgICAgLy8gY29uc2lzdGVudCB0cmVlIG9yIGNvbW1pdHRpbmcuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gZHVyaW5nIGEgY29uY3VycmVudCByZW5kZXIsIG5vdCBhIGRpc2NyZXRlIG9yXG4gICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGUuIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgY2hlY2tlZCBmb3IgdGhpcyB3aGVuIHdlXG4gICAgICAvLyB1bndvdW5kIHRoZSBzdGFjay5cbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmVuZGVyIGNvbXBsZXRlZC5cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIG1heSBoYXZlIHlpZWxkZWQgdG8gYSBjb25jdXJyZW50IGV2ZW50LCBhbmQgaWYgc28sXG4gICAgICAvLyBjb25maXJtIHRoYXQgYW55IG5ld2x5IHJlbmRlcmVkIHN0b3JlcyBhcmUgY29uc2lzdGVudC5cbiAgICAgIC8vIFRPRE86IEl0J3MgcG9zc2libGUgdGhhdCBldmVuIGEgY29uY3VycmVudCByZW5kZXIgbWF5IG5ldmVyIGhhdmUgeWllbGRlZFxuICAgICAgLy8gdG8gdGhlIG1haW4gdGhyZWFkLCBpZiBpdCB3YXMgZmFzdCBlbm91Z2gsIG9yIGlmIGl0IGV4cGlyZWQuIFdlIGNvdWxkXG4gICAgICAvLyBza2lwIHRoZSBjb25zaXN0ZW5jeSBjaGVjayBpbiB0aGF0IGNhc2UsIHRvby5cbiAgICAgIHZhciByZW5kZXJXYXNDb25jdXJyZW50ID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKTtcbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAocmVuZGVyV2FzQ29uY3VycmVudCAmJiAhaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgLy8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5LCB0byBibG9jayBmdXJ0aGVyIG11dGF0aW9ucy5cbiAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTsgLy8gV2UgbmVlZCB0byBjaGVjayBhZ2FpbiBpZiBzb21ldGhpbmcgdGhyZXdcblxuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2Vycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpO1xuXG4gICAgICAgICAgaWYgKF9lcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgIGxhbmVzID0gX2Vycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBfZXJyb3JSZXRyeUxhbmVzKTsgLy8gV2UgYXNzdW1lIHRoZSB0cmVlIGlzIG5vdyBjb25zaXN0ZW50IGJlY2F1c2Ugd2UgZGlkbid0IHlpZWxkIHRvIGFueVxuICAgICAgICAgICAgLy8gY29uY3VycmVudCBldmVudHMuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgX2ZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgICAgICAgICB0aHJvdyBfZmF0YWxFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuXG4gIGlmIChyb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGUgdGFzayBub2RlIHNjaGVkdWxlZCBmb3IgdGhpcyByb290IGlzIHRoZSBzYW1lIG9uZSB0aGF0J3NcbiAgICAvLyBjdXJyZW50bHkgZXhlY3V0ZWQuIE5lZWQgdG8gcmV0dXJuIGEgY29udGludWF0aW9uLlxuICAgIHJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBlcnJvclJldHJ5TGFuZXMpIHtcbiAgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbiwgZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGxcbiAgLy8gYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG4gIC8vIEJlZm9yZSByZW5kZXJpbmcgYWdhaW4sIHNhdmUgdGhlIGVycm9ycyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LlxuICB2YXIgZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG5cbiAgaWYgKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpIHtcbiAgICAvLyBUaGUgc2hlbGwgZmFpbGVkIHRvIGh5ZHJhdGUuIFNldCBhIGZsYWcgdG8gZm9yY2UgYSBjbGllbnQgcmVuZGVyaW5nXG4gICAgLy8gZHVyaW5nIHRoZSBuZXh0IGF0dGVtcHQuIFRvIGRvIHRoaXMsIHdlIGNhbGwgcHJlcGFyZUZyZXNoU3RhY2sgbm93XG4gICAgLy8gdG8gY3JlYXRlIHRoZSByb290IHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoaXMgaXMgYSBiaXQgd2VpcmQgaW4gdGVybXNcbiAgICAvLyBvZiBmYWN0b3JpbmcsIGJlY2F1c2UgaXQgcmVsaWVzIG9uIHJlbmRlclJvb3RTeW5jIG5vdCBjYWxsaW5nXG4gICAgLy8gcHJlcGFyZUZyZXNoU3RhY2sgYWdhaW4gaW4gdGhlIGNhbGwgYmVsb3csIHdoaWNoIGhhcHBlbnMgYmVjYXVzZSB0aGVcbiAgICAvLyByb290IGFuZCBsYW5lcyBoYXZlbid0IGNoYW5nZWQuXG4gICAgLy9cbiAgICAvLyBUT0RPOiBJIHRoaW5rIHdoYXQgd2Ugc2hvdWxkIGRvIGlzIHNldCBGb3JjZUNsaWVudFJlbmRlciBpbnNpZGVcbiAgICAvLyB0aHJvd0V4Y2VwdGlvbiwgbGlrZSB3ZSBkbyBmb3IgbmVzdGVkIFN1c3BlbnNlIGJvdW5kYXJpZXMuIFRoZSByZWFzb25cbiAgICAvLyBpdCdzIGhlcmUgaW5zdGVhZCBpcyBzbyB3ZSBjYW4gc3dpdGNoIHRvIHRoZSBzeW5jaHJvbm91cyB3b3JrIGxvb3AsIHRvby5cbiAgICAvLyBTb21ldGhpbmcgdG8gY29uc2lkZXIgZm9yIGEgZnV0dXJlIHJlZmFjdG9yLlxuICAgIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuICAgIHJvb3RXb3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcblxuICAgIHtcbiAgICAgIGVycm9ySHlkcmF0aW5nQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBmaW5pc2hlZCByZW5kZXJpbmcgb24gcmV0cnlcbiAgICAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIGZhaWxlZCBmaXJzdCBhdHRlbXB0IGhhdmUgYmVlbiByZWNvdmVyZWQuIEFkZFxuICAgIC8vIHRoZW0gdG8gdGhlIGNvbGxlY3Rpb24gb2YgcmVjb3ZlcmFibGUgZXJyb3JzLiBXZSdsbCBsb2cgdGhlbSBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UuXG4gICAgdmFyIGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ID0gd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnM7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnNGcm9tRmlyc3RBdHRlbXB0OyAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIHNlY29uZCBhdHRlbXB0IHNob3VsZCBiZSBxdWV1ZWQgYWZ0ZXIgdGhlIGVycm9yc1xuICAgIC8vIGZyb20gdGhlIGZpcnN0IGF0dGVtcHQsIHRvIHByZXNlcnZlIHRoZSBjYXVzYWwgc2VxdWVuY2UuXG5cbiAgICBpZiAoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQgIT09IG51bGwpIHtcbiAgICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleGl0U3RhdHVzO1xufVxuXG5mdW5jdGlvbiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9ycykge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9ycztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpIHtcbiAgc3dpdGNoIChleGl0U3RhdHVzKSB7XG4gICAgY2FzZSBSb290SW5Qcm9ncmVzczpcbiAgICBjYXNlIFJvb3RGYXRhbEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIC8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbiAgICAvLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuICAgICAgICAvLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdFN1c3BlbmRlZDpcbiAgICAgIHtcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7IC8vIFdlIGhhdmUgYW4gYWNjZXB0YWJsZSBsb2FkaW5nIHN0YXRlLiBXZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgd2VcbiAgICAgICAgLy8gc2hvdWxkIGltbWVkaWF0ZWx5IGNvbW1pdCBpdCBvciB3YWl0IGEgYml0LlxuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSAmJiAvLyBkbyBub3QgZGVsYXkgaWYgd2UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlXG4gICAgICAgICFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgICAgICAgIC8vIFRoaXMgcmVuZGVyIG9ubHkgaW5jbHVkZWQgcmV0cmllcywgbm8gdXBkYXRlcy4gVGhyb3R0bGUgY29tbWl0dGluZ1xuICAgICAgICAgIC8vIHJldHJpZXMgc28gdGhhdCB3ZSBkb24ndCBzaG93IHRvbyBtYW55IGxvYWRpbmcgc3RhdGVzIHRvbyBxdWlja2x5LlxuICAgICAgICAgIHZhciBtc1VudGlsVGltZW91dCA9IGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgKyBGQUxMQkFDS19USFJPVFRMRV9NUyAtIG5vdyQxKCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyksIG1zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBUaGUgd29yayBleHBpcmVkLiBDb21taXQgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0cmFuc2l0aW9uLCBidXQgd2UgZGlkIHRyaWdnZXIgYW4gYXZvaWRlZCBzdGF0ZS5cbiAgICAgICAgICAvLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3RcbiAgICAgICAgICAvLyBOb3RpY2VhYmxlIERpZmZlcmVuY2UuXG4gICAgICAgICAgLy8gVE9ETzogSXMgdGhlIEpORCBvcHRpbWl6YXRpb24gd29ydGggdGhlIGFkZGVkIGNvbXBsZXhpdHk/IElmIHRoaXMgaXNcbiAgICAgICAgICAvLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuICAgICAgICAgIC8vIENvbnNpZGVyIHJlbW92aW5nLlxuICAgICAgICAgIHZhciBtb3N0UmVjZW50RXZlbnRUaW1lID0gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcyk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZU1zID0gbW9zdFJlY2VudEV2ZW50VGltZTtcbiAgICAgICAgICB2YXIgdGltZUVsYXBzZWRNcyA9IG5vdyQxKCkgLSBldmVudFRpbWVNcztcblxuICAgICAgICAgIHZhciBfbXNVbnRpbFRpbWVvdXQgPSBqbmQodGltZUVsYXBzZWRNcykgLSB0aW1lRWxhcHNlZE1zOyAvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cblxuXG4gICAgICAgICAgaWYgKF9tc1VudGlsVGltZW91dCA+IDEwKSB7XG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAgIC8vIHRvIGFycml2ZS5cbiAgICAgICAgICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChjb21taXRSb290LmJpbmQobnVsbCwgcm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMpLCBfbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcm9vdCBleGl0IHN0YXR1cy4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFNlYXJjaCB0aGUgcmVuZGVyZWQgdHJlZSBmb3IgZXh0ZXJuYWwgc3RvcmUgcmVhZHMsIGFuZCBjaGVjayB3aGV0aGVyIHRoZVxuICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkIGluIGEgY29uY3VycmVudCBldmVudC4gSW50ZW50aW9uYWxseSB1c2luZyBhbiBpdGVyYXRpdmVcbiAgLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cbiAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS5mbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5vZGUudXBkYXRlUXVldWU7XG5cbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gdXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgICAgIGlmIChjaGVja3MgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gY2hlY2tzW2ldO1xuICAgICAgICAgICAgdmFyIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRWYWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIHJlbmRlcmVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gaW5jb25zaXN0ZW50IHN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgICAgICAgLy8gYSByZS1yZW5kZXIsIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSByZXRocm93biBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgZG9lc24ndCBrbm93IHRoaXMgaXMgdW5yZWFjaGFibGUsIGJ1dCBlc2xpbnQgZG9lc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyk7XG4gIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QpIHtcbiAge1xuICAgIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH1cblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIE5vTGFuZXMpO1xuXG4gIGlmICghaW5jbHVkZXNTb21lTGFuZShsYW5lcywgU3luY0xhbmUpKSB7XG4gICAgLy8gVGhlcmUncyBubyByZW1haW5pbmcgc3luYyB3b3JrIGxlZnQuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cbiAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgIC8vIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsIGluY2x1ZGVzXG4gICAgLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgIGlmIChlcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdyQxKCkpO1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuICAvLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzKTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBsYW5lcykge1xuICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBtZXJnZUxhbmVzKGxhbmVzLCBTeW5jTGFuZSkpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3ckMSgpKTtcblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5KTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBJZiB0aGVyZSB3ZXJlIGxlZ2FjeSBzeW5jIHVwZGF0ZXMsIGZsdXNoIHRoZW0gYXQgdGhlIGVuZCBvZiB0aGUgb3V0ZXJcbiAgICAvLyBtb3N0IGJhdGNoZWRVcGRhdGVzLWxpa2UgbWV0aG9kLlxuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiAvLyBUcmVhdCBgYWN0YCBhcyBpZiBpdCdzIGluc2lkZSBgYmF0Y2hlZFVwZGF0ZXNgLCBldmVuIGluIGxlZ2FjeSBtb2RlLlxuICAgICEoIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuaXNCYXRjaGluZ0xlZ2FjeSkpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgfVxuICB9XG59IC8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgZmx1c2ggcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGVcbiAgLy8gbmV4dCBldmVudCwgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIG9uZS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsICYmIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLnRhZyA9PT0gTGVnYWN5Um9vdCAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb247XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuXG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgIC8vIHRoZSBzdGFjay5cblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNBbHJlYWR5UmVuZGVyaW5nKCkge1xuICAvLyBVc2VkIGJ5IHRoZSByZW5kZXJlciB0byBwcmludCBhIHdhcm5pbmcgaWYgY2VydGFpbiBBUElzIGFyZSBjYWxsZWQgZnJvbVxuICAvLyB0aGUgd3JvbmcgY29udGV4dC5cbiAgcmV0dXJuICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQ7XG59XG5mdW5jdGlvbiBmbHVzaENvbnRyb2xsZWQoZm4pIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hSZW5kZXJMYW5lcyhmaWJlciwgbGFuZXMpIHtcbiAgcHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIHN1YnRyZWVSZW5kZXJMYW5lcywgZmliZXIpO1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBtZXJnZUxhbmVzKHN1YnRyZWVSZW5kZXJMYW5lcywgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBwb3BSZW5kZXJMYW5lcyhmaWJlcikge1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgcG9wKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbiAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7IC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgd29ya0luUHJvZ3Jlc3MgPSByb290V29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpO1xuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cblxuICByZXR1cm4gcm9vdFdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSkge1xuICBkbyB7XG4gICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICB0cnkge1xuICAgICAgLy8gUmVzZXQgbW9kdWxlLWxldmVsIHN0YXRlIHRoYXQgd2FzIHNldCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTtcbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7IC8vIFRPRE86IEkgZm91bmQgYW5kIGFkZGVkIHRoaXMgbWlzc2luZyBsaW5lIHdoaWxlIGludmVzdGlnYXRpbmcgYVxuICAgICAgLy8gc2VwYXJhdGUgaXNzdWUuIFdyaXRlIGEgcmVncmVzc2lvbiB0ZXN0IHVzaW5nIHN0cmluZyByZWZzLlxuXG4gICAgICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICBpZiAoZXJyb3JlZFdvcmsgPT09IG51bGwgfHwgZXJyb3JlZFdvcmsucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIHRvIGJlIHdvcmtpbmcgb24gYSBub24tcm9vdCBmaWJlci4gVGhpcyBpcyBhIGZhdGFsIGVycm9yXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBhbmNlc3RvciB0aGF0IGNhbiBoYW5kbGUgaXQ7IHRoZSByb290IGlzXG4gICAgICAgIC8vIHN1cHBvc2VkIHRvIGNhcHR1cmUgYWxsIGVycm9ycyB0aGF0IHdlcmVuJ3QgY2F1Z2h0IGJ5IGFuIGVycm9yXG4gICAgICAgIC8vIGJvdW5kYXJ5LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciA9IHRocm93blZhbHVlOyAvLyBTZXQgYHdvcmtJblByb2dyZXNzYCB0byBudWxsLiBUaGlzIHJlcHJlc2VudHMgYWR2YW5jaW5nIHRvIHRoZSBuZXh0XG4gICAgICAgIC8vIHNpYmxpbmcsIG9yIHRoZSBwYXJlbnQgaWYgdGhlcmUgYXJlIG5vIHNpYmxpbmdzLiBCdXQgc2luY2UgdGhlIHJvb3RcbiAgICAgICAgLy8gaGFzIG5vIHNpYmxpbmdzIG5vciBhIHBhcmVudCwgd2Ugc2V0IGl0IHRvIG51bGwuIFVzdWFsbHkgdGhpcyBpc1xuICAgICAgICAvLyBoYW5kbGVkIGJ5IGBjb21wbGV0ZVVuaXRPZldvcmtgIG9yIGB1bndpbmRXb3JrYCwgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgbm90IGNhbGxpbmcgdGhvc2UsIHdlIG5lZWQgc2V0IGl0IGhlcmUuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGNhbGxpbmcgYHVud2luZFdvcmtgIHRvIHBvcCB0aGUgY29udGV4dHMuXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIGVycm9yZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGJlZm9yZSBhbiBlcnJvciB3YXMgdGhyb3duLiBUaGlzXG4gICAgICAgIC8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG4gICAgICAgIC8vIHN1c3BlbmRlZCByZW5kZXIuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZXJyb3JlZFdvcmssIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKSB7XG4gICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cbiAgICAgICAgaWYgKHRocm93blZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm93blZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgd2FrZWFibGUgPSB0aHJvd25WYWx1ZTtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGVycm9yZWRXb3JrLCB3YWtlYWJsZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtDb21wb25lbnRFcnJvcmVkKGVycm9yZWRXb3JrLCB0aHJvd25WYWx1ZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpIHtcbiAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdyQxKCk7XG59XG5mdW5jdGlvbiBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGxhbmUpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gbWVyZ2VMYW5lcyhsYW5lLCB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZCgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcyB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gIH0gLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHVwZGF0ZXMgdGhhdCB3ZSBza2lwcGVkIHRyZWUgdGhhdCBtaWdodCBoYXZlIHVuYmxvY2tlZFxuICAvLyB0aGlzIHJlbmRlci5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwgJiYgKGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKSB8fCBpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKSkpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcihlcnJvcikge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZDtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufSAvLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cbi8vIFJldHVybnMgZmFsc2UgaWYgd2UncmUgbm90IHN1cmUuXG5cbmZ1bmN0aW9uIHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcbiAgLy8gc28gdGhvc2UgYXJlIGZhbHNlLlxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bmMgcmVuZGVyLCBzbyB3ZSBzaG91bGQgaGF2ZSBmaW5pc2hlZCB0aGUgd2hvbGUgdHJlZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSAnICsgJ2J1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn0gLy8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuXG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAvLyBBbHJlYWR5IHRpbWVkIG91dCwgc28gcGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZC5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gU3RpbGwgd29yayByZW1haW5pbmcuXG4gICAge1xuICAgICAgbWFya1JlbmRlcllpZWxkZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUm9vdEluUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcGxldGVkIHRoZSB0cmVlLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICB9XG59XG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnRGaWJlcih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrJDEoY3VycmVudCwgdW5pdE9mV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBjb21wbGV0ZWRXb3JrLnJldHVybjsgLy8gQ2hlY2sgaWYgdGhlIHdvcmsgY29tcGxldGVkIG9yIGlmIHNvbWV0aGluZyB0aHJldy5cblxuICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpID09PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoY29tcGxldGVkV29yayk7XG4gICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7IC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKTsgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBsYW5lcy5cblxuXG4gICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgX25leHQuZmxhZ3MgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gX25leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gZm9yIHRoZSBmaWJlciB0aGF0IGVycm9yZWQuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpOyAvLyBJbmNsdWRlIHRoZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gZmFpbGVkIGNoaWxkcmVuIGJlZm9yZSBjb250aW51aW5nLlxuXG4gICAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgICByZXR1cm5GaWJlci5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgdW53b3VuZCBhbGwgdGhlIHdheSB0byB0aGUgcm9vdC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmdGaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcblxuXG4gICAgY29tcGxldGVkV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gIH0gd2hpbGUgKGNvbXBsZXRlZFdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycykge1xuICAvLyBUT0RPOiBUaGlzIG5vIGxvbmdlciBtYWtlcyBhbnkgc2Vuc2UuIFdlIGFscmVhZHkgd3JhcCB0aGUgbXV0YXRpb24gYW5kXG4gIC8vIGxheW91dCBwaGFzZXMuIFNob3VsZCBiZSBhYmxlIHRvIHJlbW92ZS5cbiAgdmFyIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgY29tbWl0Um9vdEltcGwocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIGRvIHtcbiAgICAvLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbiAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4gICAgLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuICBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgdmFyIGxhbmVzID0gcm9vdC5maW5pc2hlZExhbmVzO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBpZiAoZmluaXNoZWRXb3JrID09PSBudWxsKSB7XG5cbiAgICB7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgICBlcnJvcigncm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcgKyAnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9IC8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7IC8vIFVwZGF0ZSB0aGUgZmlyc3QgYW5kIGxhc3QgcGVuZGluZyB0aW1lcyBvbiB0aGlzIHJvb3QuIFRoZSBuZXcgZmlyc3RcbiAgLy8gcGVuZGluZyB0aW1lIGlzIHdoYXRldmVyIGlzIGxlZnQgb24gdGhlIHJvb3QgZmliZXIuXG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhmaW5pc2hlZFdvcmsubGFuZXMsIGZpbmlzaGVkV29yay5jaGlsZExhbmVzKTtcbiAgbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcyk7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFdlIGNhbiByZXNldCB0aGVzZSBub3cgdGhhdCB0aGV5IGFyZSBmaW5pc2hlZC5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvIHByb2Nlc3MgdGhlbS5cbiAgLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcbiAgLy8gbWlnaHQgZ2V0IHNjaGVkdWxlZCBpbiB0aGUgY29tbWl0IHBoYXNlLiAoU2VlICMxNjcxNC4pXG4gIC8vIFRPRE86IERlbGV0ZSBhbGwgb3RoZXIgcGxhY2VzIHRoYXQgc2NoZWR1bGUgdGhlIHBhc3NpdmUgZWZmZWN0IGNhbGxiYWNrXG4gIC8vIFRoZXkncmUgcmVkdW5kYW50LlxuXG5cbiAgaWYgKChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzIHx8IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpOyAvLyBUaGlzIHJlbmRlciB0cmlnZ2VyZWQgcGFzc2l2ZSBlZmZlY3RzOiByZWxlYXNlIHRoZSByb290IGNhY2hlIHBvb2xcbiAgICAgICAgLy8gKmFmdGVyKiBwYXNzaXZlIGVmZmVjdHMgZmlyZSB0byBhdm9pZCBmcmVlaW5nIGEgY2FjaGUgcG9vbCB0aGF0IG1heVxuICAgICAgICAvLyBiZSByZWZlcmVuY2VkIGJ5IGEgbm9kZSBpbiB0aGUgdHJlZSAoSG9zdFJvb3QsIENhY2hlIGJvdW5kYXJ5IGV0YylcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IGVmZmVjdHMgaW4gdGhlIHdob2xlIHRyZWUuXG4gIC8vIFRPRE86IFRoaXMgaXMgbGVmdCBvdmVyIGZyb20gdGhlIGVmZmVjdCBsaXN0IGltcGxlbWVudGF0aW9uLCB3aGVyZSB3ZSBoYWRcbiAgLy8gdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYGZpcnN0RWZmZWN0YCB0byBzYXRpc2Z5IEZsb3cuIEkgdGhpbmsgdGhlXG4gIC8vIG9ubHkgb3RoZXIgcmVhc29uIHRoaXMgb3B0aW1pemF0aW9uIGV4aXN0cyBpcyBiZWNhdXNlIGl0IGFmZmVjdHMgcHJvZmlsaW5nLlxuICAvLyBSZWNvbnNpZGVyIHdoZXRoZXIgdGhpcyBpcyBuZWNlc3NhcnkuXG5cblxuICB2YXIgc3VidHJlZUhhc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncztcbiAgdmFyIHJvb3RIYXNFZmZlY3QgPSAoZmluaXNoZWRXb3JrLmZsYWdzICYgKEJlZm9yZU11dGF0aW9uTWFzayB8IE11dGF0aW9uTWFzayB8IExheW91dE1hc2sgfCBQYXNzaXZlTWFzaykpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChzdWJ0cmVlSGFzRWZmZWN0cyB8fCByb290SGFzRWZmZWN0KSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDsgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICB2YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cblxuXG4gICAgY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgbGFuZXMpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4gICAgLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuXG4gICAgY29tbWl0TGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuXG4gICAgcmVxdWVzdFBhaW50KCk7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBSZXNldCB0aGUgcHJpb3JpdHkgdG8gdGhlIHByZXZpb3VzIG5vbi1zeW5jIHZhbHVlLlxuXG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGVmZmVjdHMuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuICAgIC8vIG5vIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG5cbiAgICB7XG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztcblxuICBpZiAocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3RcbiAgICAvLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuICAvLyBUT0RPOiBUaGlzIGlzIHBhcnQgb2YgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgaW1wbGVtZW50YXRpb24uIEl0cyBwdXJwb3NlXG4gIC8vIGlzIHRvIGRldGVjdCB3aGV0aGVyIHNvbWV0aGluZyBtaWdodCBoYXZlIGNhbGxlZCBzZXRTdGF0ZSBpbnNpZGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYC4gVGhlIG1lY2hhbmlzbSBpcyBrbm93biB0byBiZSBmbGF3ZWQgYmVjYXVzZSBgc2V0U3RhdGVgXG4gIC8vIGluc2lkZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGlzIGl0c2VsZiBmbGF3ZWQg4oCUIHRoYXQncyB3aHkgd2UgcmVjb21tZW5kXG4gIC8vIGBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3JgIGluc3RlYWQuIEhvd2V2ZXIsIGl0IGNvdWxkIGJlIGltcHJvdmVkIGJ5XG4gIC8vIGNoZWNraW5nIGlmIHJlbWFpbmluZ0xhbmVzIGluY2x1ZGVzIFN5bmMgd29yaywgaW5zdGVhZCBvZiB3aGV0aGVyIHRoZXJlJ3NcbiAgLy8gYW55IHdvcmsgcmVtYWluaW5nIGF0IGFsbCAod2hpY2ggd291bGQgYWxzbyBpbmNsdWRlIHN0dWZmIGxpa2UgU3VzcGVuc2VcbiAgLy8gcmV0cmllcyBvciB0cmFuc2l0aW9ucykuIEl0J3MgYmVlbiBsaWtlIHRoaXMgZm9yIGEgd2hpbGUsIHRob3VnaCwgc28gZml4aW5nXG4gIC8vIGl0IHByb2JhYmx5IGlzbid0IHRoYXQgdXJnZW50LlxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4gICAgLy8gZXJyb3IgYm91bmRhcmllcy5cbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKCFyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93JDEoKSk7XG5cbiAgaWYgKHJlY292ZXJhYmxlRXJyb3JzICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUgd2VyZSBlcnJvcnMgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgcmVjb3ZlcmVkIGZyb20gdGhlbSB3aXRob3V0XG4gICAgLy8gbmVlZGluZyB0byBzdXJmYWNlIGl0IHRvIHRoZSBVSS4gV2UgbG9nIHRoZW0gaGVyZS5cbiAgICB2YXIgb25SZWNvdmVyYWJsZUVycm9yID0gcm9vdC5vblJlY292ZXJhYmxlRXJyb3I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IHJlY292ZXJhYmxlRXJyb3JzW2ldO1xuICAgICAgb25SZWNvdmVyYWJsZUVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciQxID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3IkMTtcbiAgfSAvLyBJZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgcmVuZGVyLCBmbHVzaCB0aGVtXG4gIC8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuICAvLyBpbW1lZGlhdGVseSBvYnNlcnZhYmxlLiBPdGhlcndpc2UsIHdlIGFzc3VtZSB0aGF0IHRoZXkgYXJlIG5vdFxuICAvLyBvcmRlci1kZXBlbmRlbnQgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIG9ic2VydmVkIGJ5IGV4dGVybmFsIHN5c3RlbXMsIHNvIHdlXG4gIC8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuICAvLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBub3Qgc2NoZWR1bGluZyB0aGUgY2FsbGJhY2sgZWFybGllci4gU2luY2Ugd2VcbiAgLy8gY3VycmVudGx5IHNjaGVkdWxlIHRoZSBjYWxsYmFjayBpbiBtdWx0aXBsZSBwbGFjZXMsIHdpbGwgd2FpdCB1bnRpbCB0aG9zZVxuICAvLyBhcmUgY29uc29saWRhdGVkLlxuXG5cbiAgaWYgKGluY2x1ZGVzU29tZUxhbmUocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMsIFN5bmNMYW5lKSAmJiByb290LnRhZyAhPT0gTGVnYWN5Um9vdCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGEgcGFzc2l2ZSBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICB7XG4gICAgICBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCk7XG4gICAgfSAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cblxuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9IC8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gIC8vIFJldHVybnMgd2hldGhlciBwYXNzaXZlIGVmZmVjdHMgd2VyZSBmbHVzaGVkLlxuICAvLyBUT0RPOiBDb21iaW5lIHRoaXMgY2hlY2sgd2l0aCB0aGUgb25lIGluIGZsdXNoUGFzc2l2ZUVGZmVjdHNJbXBsLiBXZSBzaG91bGRcbiAgLy8gcHJvYmFibHkganVzdCBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zLiBJIGJlbGlldmUgdGhleSB3ZXJlIG9ubHkgc2VwYXJhdGVcbiAgLy8gaW4gdGhlIGZpcnN0IHBsYWNlIGJlY2F1c2Ugd2UgdXNlZCB0byB3cmFwIGl0IHdpdGhcbiAgLy8gYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLCB3aGljaCBhY2NlcHRzIGEgZnVuY3Rpb24uIEJ1dCBub3cgd2UgdHJhY2sgdGhlXG4gIC8vIHByaW9yaXR5IHdpdGhpbiBSZWFjdCBpdHNlbGYsIHNvIHdlIGNhbiBtdXRhdGUgdGhlIHZhcmlhYmxlIGRpcmVjdGx5LlxuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwpIHtcbiAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyk7XG4gICAgdmFyIHByaW9yaXR5ID0gbG93ZXJFdmVudFByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5LCByZW5kZXJQcmlvcml0eSk7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgICB0cnkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICByZXR1cm4gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247IC8vIE9uY2UgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuIGZvciB0aGUgdHJlZSAtIGdpdmluZyBjb21wb25lbnRzIGFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaWJlcikge1xuICB7XG4gICAgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMucHVzaChmaWJlcik7XG5cbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDsgLy8gVE9ETzogVGhpcyBpcyBzb21ldGltZXMgb3V0IG9mIHN5bmMgd2l0aCByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy5cbiAgLy8gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gSXQncyBub3QgY2F1c2luZyBhbnkga25vd24gaXNzdWVzIChwcm9iYWJseVxuICAvLyBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBwcm9maWxpbmcpLCBidXQgaXQncyBhIHJlZmFjdG9yIGhhemFyZC5cblxuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKHJvb3QuY3VycmVudCk7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgcm9vdC5jdXJyZW50KTsgLy8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5cbiAge1xuICAgIHZhciBwcm9maWxlckVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cztcbiAgICBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9maWxlckVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfZmliZXIgPSBwcm9maWxlckVmZmVjdHNbaV07XG4gICAgICBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKHJvb3QsIF9maWJlcik7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgfVxuXG4gIHtcbiAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCB0cnVlKTtcbiAgfVxuXG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7IC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblxuICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCA/IDAgOiBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgKyAxOyAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuICBvblBvc3RDb21taXRSb290KHJvb3QpO1xuXG4gIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gcm9vdC5jdXJyZW50LnN0YXRlTm9kZTtcbiAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkICE9PSBudWxsICYmIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKGluc3RhbmNlKSB7XG4gIGlmIChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9PT0gbnVsbCkge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbmV3IFNldChbaW5zdGFuY2VdKTtcbiAgfSBlbHNlIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcihlcnJvcikge1xuICBpZiAoIWhhc1VuY2F1Z2h0RXJyb3IpIHtcbiAgICBoYXNVbmNhdWdodEVycm9yID0gdHJ1ZTtcbiAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG52YXIgb25VbmNhdWdodEVycm9yID0gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yO1xuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciwgc291cmNlRmliZXIpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3RGaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gIGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCB1cGRhdGUpO1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHJvb3RGaWJlciwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciQxKSB7XG4gIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgIC8vIGl0c2VsZiBzaG91bGQgY2FwdHVyZSBpdC5cbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvcjtcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGN0b3IgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUoZXJyb3IkMSwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICAvLyBUT0RPOiBVbnRpbCB3ZSByZS1sYW5kIHNraXBVbm1vdW50ZWRCb3VuZGFyaWVzIChzZWUgIzIwMTQ3KSwgdGhpcyB3YXJuaW5nXG4gICAgLy8gd2lsbCBmaXJlIGZvciBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGRlc3Ryb3kgZnVuY3Rpb25zIGluc2lkZSBkZWxldGVkXG4gICAgLy8gdHJlZXMuIFdoYXQgaXQgc2hvdWxkIGluc3RlYWQgZG8gaXMgcHJvcGFnYXRlIHRoZSBlcnJvciB0byB0aGUgcGFyZW50IG9mXG4gICAgLy8gdGhlIGRlbGV0ZWQgdHJlZS4gSW4gdGhlIG1lYW50aW1lLCBkbyBub3QgYWRkIHRoaXMgd2FybmluZyB0byB0aGVcbiAgICAvLyBhbGxvd2xpc3Q7IHRoaXMgaXMgb25seSBmb3Igb3VyIGludGVybmFsIHVzZS5cbiAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yICcgKyAnaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIExpa2VseSAnICsgJ2NhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuICcgKyAnYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuJyArICdFcnJvciBtZXNzYWdlOlxcblxcbiVzJywgZXJyb3IkMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cbiAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuICB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93JDEoKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuICAgICAgLy8gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4gIC8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4gIC8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4gIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGxhbmVzLlxuICBpZiAocmV0cnlMYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBUT0RPOiBBc3NpZ24gdGhpcyB0byBgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmVgPyB0byBhdm9pZFxuICAgIC8vIHVubmVjZXNzYXJ5IGVudGFuZ2xlbWVudD9cbiAgICByZXRyeUxhbmUgPSByZXF1ZXN0UmV0cnlMYW5lKGJvdW5kYXJ5RmliZXIpO1xuICB9IC8vIFRPRE86IFNwZWNpYWwgY2FzZSBpZGxlIHByaW9yaXR5P1xuXG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHJldHJ5TGFuZSwgZXZlbnRUaW1lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICByZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlciwgd2FrZWFibGUpIHtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTsgLy8gRGVmYXVsdFxuXG4gIHZhciByZXRyeUNhY2hlO1xuXG4gIHtcbiAgICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGluZ2VkIHVua25vd24gc3VzcGVuc2UgYm91bmRhcnkgdHlwZS4gJyArICdUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgJ3JlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgJyArICdjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvICcgKyAncHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgICBlcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcgKyBcImNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgXCIgKyAnaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gJyArICdldmVyeSByZW5kZXIuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpIHtcbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcblxuICAgIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihmaWJlciwgaGFzUGFzc2l2ZUVmZmVjdHMpIHtcbiAge1xuICAgIC8vIFRPRE8gKFN0cmljdEVmZmVjdHMpIFNob3VsZCB3ZSBzZXQgYSBtYXJrZXIgb24gdGhlIHJvb3QgaWYgaXQgY29udGFpbnMgc3RyaWN0IGVmZmVjdHNcbiAgICAvLyBzbyB3ZSBkb24ndCB0cmF2ZXJzZSB1bm5lY2Vzc2FyaWx5PyBzaW1pbGFyIHRvIHN1YnRyZWVGbGFncyBidXQganVzdCBhdCB0aGUgcm9vdCBsZXZlbC5cbiAgICAvLyBNYXliZSBub3QgYSBiaWcgZGVhbCBzaW5jZSB0aGlzIGlzIERFViBvbmx5IGJlaGF2aW9yLlxuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudExheW91dERldiwgaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWKTtcblxuICAgIGlmIChoYXNQYXNzaXZlRWZmZWN0cykge1xuICAgICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudFBhc3NpdmVEZXYsIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIGludm9rZUVmZmVjdHNJbkRldihmaWJlciwgTW91bnRMYXlvdXREZXYsIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYpO1xuXG4gICAgaWYgKGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsIE1vdW50UGFzc2l2ZURldiwgaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlRWZmZWN0c0luRGV2KGZpcnN0Q2hpbGQsIGZpYmVyRmxhZ3MsIGludm9rZUVmZmVjdEZuKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICB2YXIgY3VycmVudCA9IGZpcnN0Q2hpbGQ7XG4gICAgdmFyIHN1YnRyZWVSb290ID0gbnVsbDtcblxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJpbWFyeVN1YnRyZWVGbGFnID0gY3VycmVudC5zdWJ0cmVlRmxhZ3MgJiBmaWJlckZsYWdzO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gc3VidHJlZVJvb3QgJiYgY3VycmVudC5jaGlsZCAhPT0gbnVsbCAmJiBwcmltYXJ5U3VidHJlZUZsYWcgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBmaWJlckZsYWdzKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIGludm9rZUVmZmVjdEZuKGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IHN1YnRyZWVSb290ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gICAgaWYgKHRhZyAhPT0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCAmJiB0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYXlFcnJvciA9PT0gJ29iamVjdCcgJiYgcmVwbGF5RXJyb3IgIT09IG51bGwgJiYgcmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZyAmJiB0eXBlb2Ygb3JpZ2luYWxFcnJvciA9PT0gJ29iamVjdCcgJiYgb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiAhb3JpZ2luYWxFcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgLy8gSWYgc3VwcHJlc3NlZCwgbGV0IHRoZSBmbGFnIGNhcnJ5IG92ZXIgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHdoaWNoIGlzIHRoZSBvbmUgd2UnbGwgcmV0aHJvdy5cbiAgICAgICAgICBvcmlnaW5hbEVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlIGFsd2F5cyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gY2FzZSB0aGUgc2Vjb25kIHJlbmRlciBwYXNzIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGEgbWVtb2l6ZWQgZnVuY3Rpb24gb3IgQ29tbW9uSlMgbW9kdWxlIGRvZXNuJ3QgdGhyb3cgYWZ0ZXIgZmlyc3QgaW52b2NhdGlvbi5cblxuXG4gICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAhZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJyArICdkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnICsgJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXInLCBzZXRTdGF0ZUNvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSAnICsgJ2Z1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4nKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcykge1xuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgIG1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBzY2hlZHVsaW5nRmliZXIsIGxhbmVzKTtcbiAgICAgIH0pOyAvLyBUaGlzIGZ1bmN0aW9uIGludGVudGlvbmFsbHkgZG9lcyBub3QgY2xlYXIgbWVtb2l6ZWQgdXBkYXRlcnMuXG4gICAgICAvLyBUaG9zZSBtYXkgc3RpbGwgYmUgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgY29tbWl0XG4gICAgICAvLyBhbmQgYSBmdXR1cmUgb25lIChlLmcuIFN1c3BlbnNlKS5cbiAgICB9XG4gIH1cbn1cbnZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlID0ge307XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2skMShwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnlwYXNzIFNjaGVkdWxlciBhbmQgcHVzaCB0b1xuICAgIC8vIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkLlxuICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudDtcblxuICAgIGlmIChhY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSkge1xuICBpZiAoIGNhbGxiYWNrTm9kZSA9PT0gZmFrZUFjdENhbGxiYWNrTm9kZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJbiBwcm9kdWN0aW9uLCBhbHdheXMgY2FsbCBTY2hlZHVsZXIuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBvdXQuXG5cblxuICByZXR1cm4gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkge1xuICAvLyBOZXZlciBmb3JjZSBmbHVzaCBpbiBwcm9kdWN0aW9uLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBnZXQgc3RyaXBwZWQgb3V0LlxuICByZXR1cm4gIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICBpZiAoIWlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkpIHtcbiAgICAgICAgLy8gTm90IGluIGFuIGFjdCBlbnZpcm9ubWVudC4gTm8gbmVlZCB0byB3YXJuLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlZ2FjeSBtb2RlIGhhcyBhZGRpdGlvbmFsIGNhc2VzIHdoZXJlIHdlIHN1cHByZXNzIGEgd2FybmluZy5cbiAgICAgIGlmICghaXNMZWdhY3lBY3RFbnZpcm9ubWVudCgpKSB7XG4gICAgICAgIC8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIExlZ2FjeSBtb2RlIGRvZXNuJ3Qgd2FybiBpZiB0aGUgdXBkYXRlIGlzIGJhdGNoZWQsIGkuZS5cbiAgICAgICAgLy8gYmF0Y2hlZFVwZGF0ZXMgb3IgZmx1c2hTeW5jLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWJlci50YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gRm9yd2FyZFJlZiAmJiBmaWJlci50YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcHJlLWhvb2tzIGNvZGUsIGxlZ2FjeSBtb2RlIG9ubHlcbiAgICAgICAgLy8gd2FybnMgZm9yIHVwZGF0ZXMgdGhhdCBvcmlnaW5hdGUgZnJvbSBhIGhvb2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnICsgJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCkge1xuICB7XG4gICAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50ICcgKyAnd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgJyArICdpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2RlcyAqL1xudmFyIHJlc29sdmVGYW1pbHkgPSBudWxsOyAvLyAkRmxvd0ZpeE1lIEZsb3cgZ2V0cyBjb25mdXNlZCBieSBhIFdlYWtTZXQgZmVhdHVyZSBjaGVjayBiZWxvdy5cblxudmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xudmFyIHNldFJlZnJlc2hIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAge1xuICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgLy8gTm8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMuXG4gIHJldHVybiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHR5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEZvcndhcmRSZWYgaXMgc3BlY2lhbCBiZWNhdXNlIGl0cyByZXNvbHZlZCAudHlwZSBpcyBhbiBvYmplY3QsXG4gICAgICAgIC8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cbiAgICAgICAgLy8gSWYgdGhhdCBpbm5lciByZW5kZXIgZnVuY3Rpb24gaXMgZGlmZmVyZW50LCB3ZSdsbCBidWlsZCBhIG5ldyBmb3J3YXJkUmVmIHR5cGUuXG4gICAgICAgIHZhciBjdXJyZW50UmVuZGVyID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKTtcblxuICAgICAgICBpZiAodHlwZS5yZW5kZXIgIT09IGN1cnJlbnRSZW5kZXIpIHtcbiAgICAgICAgICB2YXIgc3ludGhldGljVHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgICAgICAgICAgcmVuZGVyOiBjdXJyZW50UmVuZGVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzeW50aGV0aWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICB2YXIgbmV4dFR5cGUgPSBlbGVtZW50LnR5cGU7IC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBrbm93IHR5cGVzIGFyZW4ndCA9PT0gZXF1YWwuXG5cbiAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSBmYWxzZTtcbiAgICB2YXIgJCR0eXBlb2ZOZXh0VHlwZSA9IHR5cGVvZiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgbmV4dFR5cGUgIT09IG51bGwgPyBuZXh0VHlwZS4kJHR5cGVvZiA6IG51bGw7XG5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHRoZSBsYXp5IGlubmVyIHR5cGUgaXMgc3RhYmxlLFxuICAgICAgICAgICAgLy8gYW5kIHNvIGl0IGlzIHN1ZmZpY2llbnQgdG8gYXZvaWQgcmVjb25jaWxpbmcgaXQgYXdheS5cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IHNldCB0aGlzLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgaWYgYm90aCB0eXBlcyBoYXZlIGEgZmFtaWx5IGFuZCBpdCdzIHRoZSBzYW1lIG9uZS5cblxuXG4gICAgaWYgKG5lZWRzQ29tcGFyZUZhbWlsaWVzKSB7XG4gICAgICAvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG4gICAgICAvLyBUaGlzIG1lYW5zIGJvdGggb2YgdGhlbSBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdG8gcHJlc2VydmUgc3RhdGUuXG4gICAgICAvLyBJZiB3ZSB1bndyYXBwZWQgYW5kIGNvbXBhcmVkIHRoZSBpbm5lciB0eXBlcyBmb3Igd3JhcHBlcnMgaW5zdGVhZCxcbiAgICAgIC8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG4gICAgICAvLyBjYWxscyBhcmUgZXF1aXZhbGVudCBiZWNhdXNlIHRoZXkgd3JhcCB0aGUgc2FtZSBGb28gZnVuY3Rpb24uXG4gICAgICB2YXIgcHJldkZhbWlseSA9IHJlc29sdmVGYW1pbHkocHJldlR5cGUpO1xuXG4gICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7XG4gIH1cbn1cbnZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgdXBkYXRlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzLFxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290LmNvbnRleHQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4gICAgICAvLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4gICAgICAvLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZHNSZW5kZXIgPSBmYWxzZTtcbiAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7XG5cbiAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQpIHtcbiAgICAgIGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCB8fCBuZWVkc1JlbmRlcikge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiAhbmVlZHNSZW1vdW50KSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBob3N0SW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIHZhciB0eXBlcyA9IG5ldyBTZXQoZmFtaWxpZXMubWFwKGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgICB9KSk7XG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIHJldHVybiBob3N0SW5zdGFuY2VzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoZmliZXIsIHR5cGVzLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZGlkTWF0Y2ggPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKSB7XG4gICAgICAgIGRpZE1hdGNoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlkTWF0Y2gpIHtcbiAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaC4gVGhpcyBvbmx5IGRyaWxscyBkb3duIHRvIHRoZSBjbG9zZXN0IGhvc3QgY29tcG9uZW50cy5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuICAgICAgLy8gdmlzdWFsIGZlZWRiYWNrLCBcImZsYXNoaW5nXCIgb3V0ZXJtb3N0IHBhcmVudCByZWN0YW5nbGVzIGlzIHN1ZmZpY2llbnQuXG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBtYXRjaCwgbWF5YmUgdGhlcmUgd2lsbCBiZSBvbmUgZnVydGhlciBkb3duIGluIHRoZSBjaGlsZCB0cmVlLlxuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoc2libGluZywgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcblxuICAgIGlmIChmb3VuZEhvc3RJbnN0YW5jZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSBob3N0IGNoaWxkcmVuLCBmYWxsYmFjayB0byBjbG9zZXN0IGhvc3QgcGFyZW50LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICAvLyBXZSBnb3QgYSBtYXRjaC5cbiAgICAgICAgZm91bmRIb3N0SW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOyAvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuZWxlbWVudFR5cGUgPSBudWxsO1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7IC8vIEZpYmVyXG5cbiAgdGhpcy5yZXR1cm4gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMucmVmID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIHRoaXMubW9kZSA9IG1vZGU7IC8vIEVmZmVjdHNcblxuICB0aGlzLmZsYWdzID0gTm9GbGFncztcbiAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gIHRoaXMubGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIC8vIE5vdGU6IFRoZSBmb2xsb3dpbmcgaXMgZG9uZSB0byBhdm9pZCBhIHY4IHBlcmZvcm1hbmNlIGNsaWZmLlxuICAgIC8vXG4gICAgLy8gSW5pdGlhbGl6aW5nIHRoZSBmaWVsZHMgYmVsb3cgdG8gc21pcyBhbmQgbGF0ZXIgdXBkYXRpbmcgdGhlbSB3aXRoXG4gICAgLy8gZG91YmxlIHZhbHVlcyB3aWxsIGNhdXNlIEZpYmVycyB0byBlbmQgdXAgaGF2aW5nIHNlcGFyYXRlIHNoYXBlcy5cbiAgICAvLyBUaGlzIGJlaGF2aW9yL2J1ZyBoYXMgc29tZXRoaW5nIHRvIGRvIHdpdGggT2JqZWN0LnByZXZlbnRFeHRlbnNpb24oKS5cbiAgICAvLyBGb3J0dW5hdGVseSB0aGlzIG9ubHkgaW1wYWN0cyBERVYgYnVpbGRzLlxuICAgIC8vIFVuZm9ydHVuYXRlbHkgaXQgbWFrZXMgUmVhY3QgdW51c2FibHkgc2xvdyBmb3Igc29tZSBhcHBsaWNhdGlvbnMuXG4gICAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgaW5pdGlhbGl6ZSB0aGUgZmllbGRzIGJlbG93IHdpdGggZG91Ymxlcy5cbiAgICAvL1xuICAgIC8vIExlYXJuIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQzNjVcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD04NTM4XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjsgLy8gSXQncyBva2F5IHRvIHJlcGxhY2UgdGhlIGluaXRpYWwgZG91YmxlcyB3aXRoIHNtaXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgLy8gVGhpcyB3b24ndCB0cmlnZ2VyIHRoZSBwZXJmb3JtYW5jZSBjbGlmZiBtZW50aW9uZWQgYWJvdmUsXG4gICAgLy8gYW5kIGl0IHNpbXBsaWZpZXMgb3RoZXIgcHJvZmlsZXIgY29kZSAoaW5jbHVkaW5nIERldlRvb2xzKS5cblxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIC8vIFRoaXMgaXNuJ3QgZGlyZWN0bHkgdXNlZCBidXQgaXMgaGFuZHkgZm9yIGRlYnVnZ2luZyBpbnRlcm5hbHM6XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICB9XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzOyAvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH0gLy8gUmVzZXQgYWxsIGVmZmVjdHMgZXhjZXB0IHN0YXRpYyBvbmVzLlxuICAvLyBTdGF0aWMgZWZmZWN0cyBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBjdXJyZW50LmZsYWdzICYgU3RhdGljTWFzaztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gIHZhciBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgIGZpcnN0Q29udGV4dDogY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHRcbiAgfTsgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gIH1cblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufSAvLyBVc2VkIHRvIHJldXNlIGEgRmliZXIgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgcmVzZXRzIHRoZSBGaWJlciB0byB3aGF0IGNyZWF0ZUZpYmVyIG9yIGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkXG4gIC8vIGhhdmUgc2V0IHRoZSB2YWx1ZXMgdG8gYmVmb3JlIGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSWRlYWxseSB0aGlzIHdvdWxkbid0XG4gIC8vIGJlIG5lY2Vzc2FyeSBidXQgdW5mb3J0dW5hdGVseSBtYW55IGNvZGUgcGF0aHMgcmVhZHMgZnJvbSB0aGUgd29ya0luUHJvZ3Jlc3NcbiAgLy8gd2hlbiB0aGV5IHNob3VsZCBiZSByZWFkaW5nIGZyb20gY3VycmVudCBhbmQgd3JpdGluZyB0byB3b3JrSW5Qcm9ncmVzcy5cbiAgLy8gV2UgYXNzdW1lIHBlbmRpbmdQcm9wcywgaW5kZXgsIGtleSwgcmVmLCByZXR1cm4gYXJlIHN0aWxsIHVudG91Y2hlZCB0b1xuICAvLyBhdm9pZCBkb2luZyBhbm90aGVyIHJlY29uY2lsaWF0aW9uLlxuICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFN0YXRpY01hc2sgfCBQbGFjZW1lbnQ7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCB0byB0aGUgY2xvbmVkIHZhbHVlcyB0aGF0IGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkJ3ZlLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSkge1xuICB2YXIgbW9kZTtcblxuICBpZiAodGFnID09PSBDb25jdXJyZW50Um9vdCkge1xuICAgIG1vZGUgPSBDb25jdXJyZW50TW9kZTtcblxuICAgIGlmIChpc1N0cmljdE1vZGUgPT09IHRydWUpIHtcbiAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcblxuICAgICAge1xuICAgICAgICBtb2RlIHw9IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtb2RlID0gTm9Nb2RlO1xuICB9XG5cbiAgaWYgKCBpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIC8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuICAgIC8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbiAgICBtb2RlIHw9IFByb2ZpbGVNb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXJUYWcgPSBJbmRldGVybWluYXRlQ29tcG9uZW50OyAvLyBUaGUgcmVzb2x2ZWQgdHlwZSBpcyBzZXQgaWYgd2Uga25vdyB3aGF0IHRoZSBmaW5hbCB0eXBlIHdpbGwgYmUuIEkuZS4gaXQncyBub3QgbGF6eS5cblxuICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpIHtcbiAgICAgIGZpYmVyVGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBnZXRUYWc6IHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZTtcblxuICAgICAgICBpZiAoIChtb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAvLyBTdHJpY3QgZWZmZWN0cyBzaG91bGQgbmV2ZXIgcnVuIG9uIGxlZ2FjeSByb290c1xuICAgICAgICAgIG1vZGUgfD0gU3RyaWN0RWZmZWN0c01vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTpcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29uc3VtZXJcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiAnICsgJ2NvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgJyArIChcImJ1dCBnb3Q6IFwiICsgKHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcblxuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwga2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcyk7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsIHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgICBlZmZlY3REdXJhdGlvbjogMCxcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VMaXN0Q29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKE9mZnNjcmVlbkNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICB2YXIgcHJpbWFyeUNoaWxkSW5zdGFuY2UgPSB7fTtcbiAgZmliZXIuc3RhdGVOb2RlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2U7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChkZWh5ZHJhdGVkTm9kZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihEZWh5ZHJhdGVkRnJhZ21lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IGRlaHlkcmF0ZWROb2RlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5zdWJ0cmVlRmxhZ3MgPSBzb3VyY2Uuc3VidHJlZUZsYWdzO1xuICB0YXJnZXQuZGVsZXRpb25zID0gc291cmNlLmRlbGV0aW9ucztcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdTb3VyY2UgPSBzb3VyY2UuX2RlYnVnU291cmNlO1xuICB0YXJnZXQuX2RlYnVnT3duZXIgPSBzb3VyY2UuX2RlYnVnT3duZXI7XG4gIHRhcmdldC5fZGVidWdOZWVkc1JlbW91bnQgPSBzb3VyY2UuX2RlYnVnTmVlZHNSZW1vdW50O1xuICB0YXJnZXQuX2RlYnVnSG9va1R5cGVzID0gc291cmNlLl9kZWJ1Z0hvb2tUeXBlcztcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcikge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7XG4gIHRoaXMuZXZlbnRUaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG4gIHRoaXMuZXhwaXJhdGlvblRpbWVzID0gY3JlYXRlTGFuZU1hcChOb1RpbWVzdGFtcCk7XG4gIHRoaXMucGVuZGluZ0xhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmV4cGlyZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMubXV0YWJsZVJlYWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICBpZiAoc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aGlzLm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSBudWxsO1xuICB9XG5cbiAge1xuICAgIHRoaXMuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHRoaXMucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSB0aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBUb3RhbExhbmVzOyBfaSsrKSB7XG4gICAgICBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwLnB1c2gobmV3IFNldCgpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gJ2h5ZHJhdGVSb290KCknIDogJ2NyZWF0ZVJvb3QoKSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExlZ2FjeVJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gJ2h5ZHJhdGUoKScgOiAncmVuZGVyKCknO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgLy8gVE9ETzogV2UgaGF2ZSBzZXZlcmFsIG9mIHRoZXNlIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGVcbi8vIGhvc3QgY29uZmlnLCBidXQgYmVjYXVzZSB0aGV5IGFyZSBwYXNzZWQgaW4gYXQgcnVudGltZSwgd2UgaGF2ZSB0byB0aHJlYWRcbi8vIHRoZW0gdGhyb3VnaCB0aGUgcm9vdCBjb25zdHJ1Y3Rvci4gUGVyaGFwcyB3ZSBzaG91bGQgcHV0IHRoZW0gYWxsIGludG8gYVxuLy8gc2luZ2xlIHR5cGUsIGxpa2UgYSBEeW5hbWljSG9zdENvbmZpZyB0aGF0IGlzIGRlZmluZWQgYnkgdGhlIHJlbmRlcmVyLlxuaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IpO1xuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuXG5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUpO1xuICByb290LmN1cnJlbnQgPSB1bmluaXRpYWxpemVkRmliZXI7XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIHtcbiAgICB2YXIgX2luaXRpYWxTdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGlzRGVoeWRyYXRlZDogaHlkcmF0ZSxcbiAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgLy8gbm90IGVuYWJsZWQgeWV0XG4gICAgICB0cmFuc2l0aW9uczogbnVsbFxuICAgIH07XG4gICAgdW5pbml0aWFsaXplZEZpYmVyLm1lbW9pemVkU3RhdGUgPSBfaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE4LjAuMC1mYzQ2ZGJhNjctMjAyMjAzMjknO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHtcbiAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGtleSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsga2V5cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciBoeWRyYXRlID0gZmFsc2U7XG4gIHZhciBpbml0aWFsQ2hpbGRyZW4gPSBudWxsO1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sIC8vIFRPRE86IFJlbW92ZSBgY2FsbGJhY2tgIHdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLlxuY2FsbGJhY2ssIGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuICB2YXIgaHlkcmF0ZSA9IHRydWU7XG4gIHZhciByb290ID0gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTsgLy8gVE9ETzogTW92ZSB0aGlzIHRvIEZpYmVyUm9vdCBjb25zdHJ1Y3RvclxuXG4gIHJvb3QuY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpOyAvLyBTY2hlZHVsZSB0aGUgaW5pdGlhbCByZW5kZXIuIEluIGEgaHlkcmF0aW9uIHJvb3QsIHRoaXMgaXMgZGlmZmVyZW50IGZyb21cbiAgLy8gYSByZWd1bGFyIHVwZGF0ZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0IG1hdGNoIHdhcyB3YXMgcmVuZGVyZWRcbiAgLy8gb24gdGhlIHNlcnZlci5cbiAgLy8gTk9URTogVGhpcyB1cGRhdGUgaW50ZW50aW9uYWxseSBkb2Vzbid0IGhhdmUgYSBwYXlsb2FkLiBXZSdyZSBvbmx5IHVzaW5nXG4gIC8vIHRoZSB1cGRhdGUgdG8gc2NoZWR1bGUgd29yayBvbiB0aGUgcm9vdCBmaWJlciAoYW5kLCBmb3IgbGVnYWN5IHJvb3RzLCB0b1xuICAvLyBlbnF1ZXVlIHRoZSBjYWxsYmFjayBpZiBvbmUgaXMgcHJvdmlkZWQpLlxuXG4gIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwgPyBjYWxsYmFjayA6IG51bGw7XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCwgdXBkYXRlKTtcbiAgc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50JDEpO1xuXG4gIHtcbiAgICBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH07XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcblxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIGVucXVldWVVcGRhdGUoY3VycmVudCQxLCB1cGRhdGUpO1xuICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGN1cnJlbnQkMSwgbGFuZSk7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgdmFyIHJvb3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBmaXJzdCBzY2hlZHVsZWQgXCJ1cGRhdGVcIi5cbiAgICAgICAgdmFyIGxhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpO1xuICAgICAgICBmbHVzaFJvb3Qocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgICB9KTsgLy8gSWYgd2UncmUgc3RpbGwgYmxvY2tlZCBhZnRlciB0aGlzLCB3ZSBuZWVkIHRvIGluY3JlYXNlXG4gICAgICAvLyB0aGUgcHJpb3JpdHkgb2YgYW55IHByb21pc2VzIHJlc29sdmluZyB3aXRoaW4gdGhpc1xuICAgICAgLy8gYm91bmRhcnkgc28gdGhhdCB0aGV5IG5leHQgYXR0ZW1wdCBhbHNvIGhhcyBoaWdoZXIgcHJpLlxuXG4gICAgICB2YXIgcmV0cnlMYW5lID0gU3luY0xhbmU7XG4gICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgIHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lID0gaGlnaGVyUHJpb3JpdHlMYW5lKHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lLCByZXRyeUxhbmUpO1xuICB9XG59IC8vIEluY3JlYXNlcyB0aGUgcHJpb3JpdHkgb2YgdGhlbmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxudmFyIHNob3VsZEVycm9ySW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZEVycm9yKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0RXJyb3JIYW5kbGVyID0gbnVsbDtcbnZhciBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuXG57XG4gIHZhciBjb3B5V2l0aERlbGV0ZUltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCkge1xuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICAgIHVwZGF0ZWQuc3BsaWNlKGtleSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFtrZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9IC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aERlbGV0ZSA9IGZ1bmN0aW9uIChvYmosIHBhdGgpIHtcbiAgICByZXR1cm4gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lSW1wbCA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgdmFyIG9sZEtleSA9IG9sZFBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZmluZEhvb2sgPSBmdW5jdGlvbiAoZmliZXIsIGlkKSB7XG4gICAgLy8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuICAgIC8vIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHdpdGggZS5nLiBuZXN0ZWQgaG9va3MuXG4gICAgdmFyIGN1cnJlbnRIb29rID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBpZCA+IDApIHtcbiAgICAgIGN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIGlkLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRIb29rO1xuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIGVkaXRhYmxlIHZhbHVlcyBmb3IgdXNlU3RhdGUgYW5kIHVzZVJlZHVjZXIuXG5cblxuICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aERlbGV0ZShob29rLm1lbW9pemVkU3RhdGUsIHBhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgcHJvcHMgZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMsIGZvcndhcmRSZWYsIG1lbW8sIGhvc3QgY29tcG9uZW50cywgZXRjLlxuXG5cbiAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCB2YWx1ZSk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcbiAgICBzaG91bGRFcnJvckltcGwgPSBuZXdTaG91bGRFcnJvckltcGw7XG4gIH07XG5cbiAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG4gICAgc2hvdWxkU3VzcGVuZEltcGwgPSBuZXdTaG91bGRTdXNwZW5kSW1wbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKSB7XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWcpIHtcbiAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG4gIHZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbiAgcmV0dXJuIGluamVjdEludGVybmFscyh7XG4gICAgYnVuZGxlVHlwZTogZGV2VG9vbHNDb25maWcuYnVuZGxlVHlwZSxcbiAgICB2ZXJzaW9uOiBkZXZUb29sc0NvbmZpZy52ZXJzaW9uLFxuICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyUGFja2FnZU5hbWUsXG4gICAgcmVuZGVyZXJDb25maWc6IGRldlRvb2xzQ29uZmlnLnJlbmRlcmVyQ29uZmlnLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlOiBvdmVycmlkZUhvb2tTdGF0ZSxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg6IG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCxcbiAgICBvdmVycmlkZVByb3BzOiBvdmVycmlkZVByb3BzLFxuICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoOiBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCxcbiAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aDogb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgsXG4gICAgc2V0RXJyb3JIYW5kbGVyOiBzZXRFcnJvckhhbmRsZXIsXG4gICAgc2V0U3VzcGVuc2VIYW5kbGVyOiBzZXRTdXNwZW5zZUhhbmRsZXIsXG4gICAgc2NoZWR1bGVVcGRhdGU6IHNjaGVkdWxlVXBkYXRlLFxuICAgIGN1cnJlbnREaXNwYXRjaGVyUmVmOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcixcbiAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgfHwgZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSxcbiAgICAvLyBSZWFjdCBSZWZyZXNoXG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOiAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJlZnJlc2g6ICBzY2hlZHVsZVJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUm9vdDogIHNjaGVkdWxlUm9vdCAsXG4gICAgc2V0UmVmcmVzaEhhbmRsZXI6ICBzZXRSZWZyZXNoSGFuZGxlciAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBhcHBlbmQgb3duZXIgc3RhY2tzIHRvIGVycm9yIG1lc3NhZ2VzIGluIERFViBtb2RlLlxuICAgIGdldEN1cnJlbnRGaWJlcjogIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGRldGVjdCByZWNvbmNpbGVyIHZlcnNpb24gcmF0aGVyIHRoYW4gcmVuZGVyZXIgdmVyc2lvblxuICAgIC8vIHdoaWNoIG1heSBub3QgbWF0Y2ggZm9yIHRoaXJkIHBhcnR5IHJlbmRlcmVycy5cbiAgICByZWNvbmNpbGVyVmVyc2lvbjogUmVhY3RWZXJzaW9uXG4gIH0pO1xufVxuXG5leHBvcnRzLmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb247XG5leHBvcnRzLmF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eTtcbmV4cG9ydHMuYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uID0gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO1xuZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGJhdGNoZWRVcGRhdGVzO1xuZXhwb3J0cy5jcmVhdGVDb21wb25lbnRTZWxlY3RvciA9IGNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVDb250YWluZXIgPSBjcmVhdGVDb250YWluZXI7XG5leHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXIgPSBjcmVhdGVIeWRyYXRpb25Db250YWluZXI7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGNyZWF0ZVBvcnRhbDtcbmV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gY3JlYXRlUm9sZVNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVUZXN0TmFtZVNlbGVjdG9yID0gY3JlYXRlVGVzdE5hbWVTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlVGV4dFNlbGVjdG9yID0gY3JlYXRlVGV4dFNlbGVjdG9yO1xuZXhwb3J0cy5kZWZlcnJlZFVwZGF0ZXMgPSBkZWZlcnJlZFVwZGF0ZXM7XG5leHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGRpc2NyZXRlVXBkYXRlcztcbmV4cG9ydHMuZmluZEFsbE5vZGVzID0gZmluZEFsbE5vZGVzO1xuZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZpbmRCb3VuZGluZ1JlY3RzO1xuZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZTtcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscztcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nO1xuZXhwb3J0cy5mbHVzaENvbnRyb2xsZWQgPSBmbHVzaENvbnRyb2xsZWQ7XG5leHBvcnRzLmZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG5leHBvcnRzLmZvY3VzV2l0aGluID0gZm9jdXNXaXRoaW47XG5leHBvcnRzLmdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbmV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uID0gZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uO1xuZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2U7XG5leHBvcnRzLmluamVjdEludG9EZXZUb29scyA9IGluamVjdEludG9EZXZUb29scztcbmV4cG9ydHMuaXNBbHJlYWR5UmVuZGVyaW5nID0gaXNBbHJlYWR5UmVuZGVyaW5nO1xuZXhwb3J0cy5vYnNlcnZlVmlzaWJsZVJlY3RzID0gb2JzZXJ2ZVZpc2libGVSZWN0cztcbmV4cG9ydHMucmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uID0gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uO1xuZXhwb3J0cy5ydW5XaXRoUHJpb3JpdHkgPSBydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnNob3VsZEVycm9yID0gc2hvdWxkRXJyb3I7XG5leHBvcnRzLnNob3VsZFN1c3BlbmQgPSBzaG91bGRTdXNwZW5kO1xuZXhwb3J0cy51cGRhdGVDb250YWluZXIgPSB1cGRhdGVDb250YWluZXI7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH07XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCIkJCRyZWNvbmNpbGVyIiwiJCQkaG9zdENvbmZpZyIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJzdXBwcmVzc1dhcm5pbmciLCJzZXRTdXBwcmVzc1dhcm5pbmciLCJuZXdTdXBwcmVzc1dhcm5pbmciLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJzdGFjayIsImdldFN0YWNrQWRkZW5kdW0iLCJjb25jYXQiLCJhcmdzV2l0aEZvcm1hdCIsIm1hcCIsIml0ZW0iLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiYXNzaWduIiwiT2JqZWN0IiwiZ2V0Iiwia2V5IiwiX3JlYWN0SW50ZXJuYWxzIiwic2V0IiwidmFsdWUiLCJlbmFibGVQZXJzaXN0ZW50T2Zmc2NyZWVuSG9zdENvbnRhaW5lciIsImVuYWJsZU5ld1JlY29uY2lsZXIiLCJlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uIiwiZW5hYmxlTGVnYWN5SGlkZGVuIiwiZW5hYmxlU3VzcGVuc2VBdm9pZFRoaXNGYWxsYmFjayIsIndhcm5BYm91dFN0cmluZ1JlZnMiLCJlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyIsIkZ1bmN0aW9uQ29tcG9uZW50IiwiQ2xhc3NDb21wb25lbnQiLCJJbmRldGVybWluYXRlQ29tcG9uZW50IiwiSG9zdFJvb3QiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiRnJhZ21lbnQiLCJNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRm9yd2FyZFJlZiIsIlByb2ZpbGVyIiwiU3VzcGVuc2VDb21wb25lbnQiLCJNZW1vQ29tcG9uZW50IiwiU2ltcGxlTWVtb0NvbXBvbmVudCIsIkxhenlDb21wb25lbnQiLCJJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJEZWh5ZHJhdGVkRnJhZ21lbnQiLCJTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJTY29wZUNvbXBvbmVudCIsIk9mZnNjcmVlbkNvbXBvbmVudCIsIkxlZ2FjeUhpZGRlbkNvbXBvbmVudCIsIkNhY2hlQ29tcG9uZW50IiwiVHJhY2luZ01hcmtlckNvbXBvbmVudCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJSRUFDVF9DQUNIRV9UWVBFIiwiUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJnZXRXcmFwcGVkTmFtZSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJ0eXBlIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwidGFnIiwiJCR0eXBlb2YiLCJjb250ZXh0IiwicHJvdmlkZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiZ2V0V3JhcHBlZE5hbWUkMSIsImdldENvbnRleHROYW1lJDEiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiZmliZXIiLCJOb0ZsYWdzIiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIlBsYWNlbWVudEFuZFVwZGF0ZSIsIkNoaWxkRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkRpZENhcHR1cmUiLCJGb3JjZUNsaWVudFJlbmRlciIsIlJlZiIsIlNuYXBzaG90IiwiUGFzc2l2ZSIsIkh5ZHJhdGluZyIsIkh5ZHJhdGluZ0FuZFVwZGF0ZSIsIlZpc2liaWxpdHkiLCJTdG9yZUNvbnNpc3RlbmN5IiwiTGlmZWN5Y2xlRWZmZWN0TWFzayIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlIiwiRm9ya2VkIiwiUmVmU3RhdGljIiwiTGF5b3V0U3RhdGljIiwiUGFzc2l2ZVN0YXRpYyIsIk1vdW50TGF5b3V0RGV2IiwiTW91bnRQYXNzaXZlRGV2IiwiQmVmb3JlTXV0YXRpb25NYXNrIiwiTXV0YXRpb25NYXNrIiwiTGF5b3V0TWFzayIsIlBhc3NpdmVNYXNrIiwiU3RhdGljTWFzayIsIlJlYWN0Q3VycmVudE93bmVyIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5vZGUiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsIm5leHROb2RlIiwiZmxhZ3MiLCJyZXR1cm4iLCJpc0ZpYmVyTW91bnRlZCIsImlzTW91bnRlZCIsImNvbXBvbmVudCIsIm93bmVyIiwiY3VycmVudCIsIm93bmVyRmliZXIiLCJpbnN0YW5jZSIsInN0YXRlTm9kZSIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsIkVycm9yIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwibmV4dFBhcmVudCIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVySW1wbCIsIm1hdGNoIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbCIsImlzQXJyYXlJbXBsIiwiaXNBcnJheSIsImdldFB1YmxpY0luc3RhbmNlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0IiwiY3JlYXRlSW5zdGFuY2UiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInByZXBhcmVVcGRhdGUiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsImNyZWF0ZVRleHRJbnN0YW5jZSIsInNjaGVkdWxlVGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJub1RpbWVvdXQiLCJub3ciLCJpc1ByaW1hcnlSZW5kZXJlciIsIndhcm5zSWZOb3RBY3RpbmciLCJzdXBwb3J0c011dGF0aW9uIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJnZXRDdXJyZW50RXZlbnRQcmlvcml0eSIsImRldGFjaERlbGV0ZWRJbnN0YW5jZSIsInN1cHBvcnRzTWljcm90YXNrcyIsInNjaGVkdWxlTWljcm90YXNrIiwic3VwcG9ydHNUZXN0U2VsZWN0b3JzIiwiZmluZEZpYmVyUm9vdCIsImdldEJvdW5kaW5nUmVjdCIsImdldFRleHRDb250ZW50IiwiaXNIaWRkZW5TdWJ0cmVlIiwibWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSIsInNldEZvY3VzSWZGb2N1c2FibGUiLCJzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiY29tbWl0VGV4dFVwZGF0ZSIsImNvbW1pdE1vdW50IiwiY29tbWl0VXBkYXRlIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInJlc2V0VGV4dENvbnRlbnQiLCJoaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJjbGVhckNvbnRhaW5lciIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJnZXRPZmZzY3JlZW5Db250YWluZXJUeXBlIiwiZ2V0T2Zmc2NyZWVuQ29udGFpbmVyUHJvcHMiLCJjbG9uZUhpZGRlbkluc3RhbmNlIiwiY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlIiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UiLCJlcnJvckh5ZHJhdGluZ0NvbnRhaW5lciIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwicHJldkluZm8iLCJwcmV2V2FybiIsInByZXZFcnJvciIsInByZXZHcm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImRpc2FibGVkTG9nIiwiX19yZWFjdERpc2FibGVkTG9nIiwiZGlzYWJsZUxvZ3MiLCJsb2ciLCJpbmZvIiwiZ3JvdXAiLCJncm91cENvbGxhcHNlZCIsImdyb3VwRW5kIiwicHJvcHMiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicmVlbmFibGVMb2dzIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJGbiIsInVuZGVmaW5lZCIsInRyaW0iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJSZWZsZWN0Iiwic2FtcGxlIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiX2ZyYW1lIiwicmVwbGFjZSIsImluY2x1ZGVzIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUiLCJjdG9yIiwiZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lIiwic2hvdWxkQ29uc3RydWN0IiwiQ29tcG9uZW50IiwiaXNSZWFjdENvbXBvbmVudCIsImRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFViIsImhhc093blByb3BlcnR5IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJlbGVtZW50IiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImluZGV4IiwiY3JlYXRlQ3Vyc29yIiwiZGVmYXVsdFZhbHVlIiwicG9wIiwiY3Vyc29yIiwicHVzaCIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImVtcHR5Q29udGV4dE9iamVjdCIsImZyZWV6ZSIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJ3b3JrSW5Qcm9ncmVzcyIsImRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlciIsImlzQ29udGV4dFByb3ZpZGVyIiwiY2FjaGVDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwibWFza2VkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsImdldE1hc2tlZENvbnRleHQiLCJjb250ZXh0VHlwZXMiLCJoYXNDb250ZXh0Q2hhbmdlZCIsImNoaWxkQ29udGV4dFR5cGVzIiwicG9wQ29udGV4dCIsInBvcFRvcExldmVsQ29udGV4dE9iamVjdCIsInB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QiLCJkaWRDaGFuZ2UiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwicGFyZW50Q29udGV4dCIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dCIsImNvbnRleHRLZXkiLCJwdXNoQ29udGV4dFByb3ZpZGVyIiwibWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsImludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIiLCJtZXJnZWRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJMZWdhY3lSb290IiwiQ29uY3VycmVudFJvb3QiLCJOb01vZGUiLCJDb25jdXJyZW50TW9kZSIsIlByb2ZpbGVNb2RlIiwiU3RyaWN0TGVnYWN5TW9kZSIsIlN0cmljdEVmZmVjdHNNb2RlIiwiY2x6MzIiLCJNYXRoIiwiY2x6MzJGYWxsYmFjayIsIkxOMiIsImFzVWludCIsIlRvdGFsTGFuZXMiLCJOb0xhbmVzIiwiTm9MYW5lIiwiU3luY0xhbmUiLCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIiwiSW5wdXRDb250aW51b3VzTGFuZSIsIkRlZmF1bHRIeWRyYXRpb25MYW5lIiwiRGVmYXVsdExhbmUiLCJUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSIsIlRyYW5zaXRpb25MYW5lcyIsIlRyYW5zaXRpb25MYW5lMSIsIlRyYW5zaXRpb25MYW5lMiIsIlRyYW5zaXRpb25MYW5lMyIsIlRyYW5zaXRpb25MYW5lNCIsIlRyYW5zaXRpb25MYW5lNSIsIlRyYW5zaXRpb25MYW5lNiIsIlRyYW5zaXRpb25MYW5lNyIsIlRyYW5zaXRpb25MYW5lOCIsIlRyYW5zaXRpb25MYW5lOSIsIlRyYW5zaXRpb25MYW5lMTAiLCJUcmFuc2l0aW9uTGFuZTExIiwiVHJhbnNpdGlvbkxhbmUxMiIsIlRyYW5zaXRpb25MYW5lMTMiLCJUcmFuc2l0aW9uTGFuZTE0IiwiVHJhbnNpdGlvbkxhbmUxNSIsIlRyYW5zaXRpb25MYW5lMTYiLCJSZXRyeUxhbmVzIiwiUmV0cnlMYW5lMSIsIlJldHJ5TGFuZTIiLCJSZXRyeUxhbmUzIiwiUmV0cnlMYW5lNCIsIlJldHJ5TGFuZTUiLCJTb21lUmV0cnlMYW5lIiwiU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSIsIk5vbklkbGVMYW5lcyIsIklkbGVIeWRyYXRpb25MYW5lIiwiSWRsZUxhbmUiLCJPZmZzY3JlZW5MYW5lIiwiZ2V0TGFiZWxGb3JMYW5lIiwibGFuZSIsIk5vVGltZXN0YW1wIiwibmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFJldHJ5TGFuZSIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIiwibGFuZXMiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIiwiZ2V0TmV4dExhbmVzIiwicm9vdCIsIndpcExhbmVzIiwicGVuZGluZ0xhbmVzIiwibmV4dExhbmVzIiwic3VzcGVuZGVkTGFuZXMiLCJwaW5nZWRMYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJub25JZGxlVW5ibG9ja2VkTGFuZXMiLCJub25JZGxlUGluZ2VkTGFuZXMiLCJ1bmJsb2NrZWRMYW5lcyIsIm5leHRMYW5lIiwid2lwTGFuZSIsImVudGFuZ2xlZExhbmVzIiwiZW50YW5nbGVtZW50cyIsInBpY2tBcmJpdHJhcnlMYW5lSW5kZXgiLCJnZXRNb3N0UmVjZW50RXZlbnRUaW1lIiwiZXZlbnRUaW1lcyIsIm1vc3RSZWNlbnRFdmVudFRpbWUiLCJldmVudFRpbWUiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsIm1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQiLCJleHBpcmF0aW9uVGltZXMiLCJleHBpcmF0aW9uVGltZSIsImV4cGlyZWRMYW5lcyIsImdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyIsImdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yIiwiZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiIsImluY2x1ZGVzU3luY0xhbmUiLCJpbmNsdWRlc05vbklkbGVXb3JrIiwiaW5jbHVkZXNPbmx5UmV0cmllcyIsImluY2x1ZGVzT25seVRyYW5zaXRpb25zIiwiaW5jbHVkZXNCbG9ja2luZ0xhbmUiLCJTeW5jRGVmYXVsdExhbmVzIiwiaW5jbHVkZXNFeHBpcmVkTGFuZSIsImlzVHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsInBpY2tBcmJpdHJhcnlMYW5lIiwibGFuZVRvSW5kZXgiLCJpbmNsdWRlc1NvbWVMYW5lIiwiaXNTdWJzZXRPZkxhbmVzIiwic3Vic2V0IiwibWVyZ2VMYW5lcyIsInJlbW92ZUxhbmVzIiwiaW50ZXJzZWN0TGFuZXMiLCJsYW5lVG9MYW5lcyIsImhpZ2hlclByaW9yaXR5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsImkiLCJtYXJrUm9vdFVwZGF0ZWQiLCJ1cGRhdGVMYW5lIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJtYXJrUm9vdFBpbmdlZCIsIm1hcmtSb290RmluaXNoZWQiLCJyZW1haW5pbmdMYW5lcyIsIm5vTG9uZ2VyUGVuZGluZ0xhbmVzIiwibXV0YWJsZVJlYWRMYW5lcyIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwiZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbiIsInJlbmRlckxhbmVzIiwicmVuZGVyTGFuZSIsImFkZEZpYmVyVG9MYW5lc01hcCIsImlzRGV2VG9vbHNQcmVzZW50IiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsInVwZGF0ZXJzIiwiYWRkIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsInNpemUiLCJmb3JFYWNoIiwiY2xlYXIiLCJEaXNjcmV0ZUV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRlZmF1bHRFdmVudFByaW9yaXR5IiwiSWRsZUV2ZW50UHJpb3JpdHkiLCJjdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJuZXdQcmlvcml0eSIsInJ1bldpdGhQcmlvcml0eSIsInByaW9yaXR5IiwicHJldmlvdXNQcmlvcml0eSIsImhpZ2hlckV2ZW50UHJpb3JpdHkiLCJsb3dlckV2ZW50UHJpb3JpdHkiLCJpc0hpZ2hlckV2ZW50UHJpb3JpdHkiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsInNjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwiY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInNob3VsZFlpZWxkIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJyZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJub3ckMSIsInVuc3RhYmxlX25vdyIsIkltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX3lpZWxkVmFsdWUiLCJ1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSIsInJlbmRlcmVySUQiLCJpbmplY3RlZEhvb2siLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwiaGFzTG9nZ2VkRXJyb3IiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJnZXRMYW5lTGFiZWxNYXAiLCJpbmplY3RQcm9maWxpbmdIb29rcyIsImluamVjdCIsImNoZWNrRENFIiwib25TY2hlZHVsZVJvb3QiLCJjaGlsZHJlbiIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJvbkNvbW1pdFJvb3QiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJkaWRFcnJvciIsInNjaGVkdWxlclByaW9yaXR5Iiwib25Qb3N0Q29tbWl0Um9vdCIsIm9uUG9zdENvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0VW5tb3VudCIsIm9uQ29tbWl0RmliZXJVbm1vdW50Iiwic2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMiLCJuZXdJc1N0cmljdE1vZGUiLCJzZXRTdHJpY3RNb2RlIiwicHJvZmlsaW5nSG9va3MiLCJsYWJlbCIsIm1hcmtDb21taXRTdGFydGVkIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsInRocm93blZhbHVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsIndha2VhYmxlIiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJZaWVsZGVkIiwibWFya1JlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiaXMiLCJ5Iiwib2JqZWN0SXMiLCJzeW5jUXVldWUiLCJpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MiLCJpc0ZsdXNoaW5nU3luY1F1ZXVlIiwic2NoZWR1bGVTeW5jQ2FsbGJhY2siLCJjYWxsYmFjayIsInNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrIiwiZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSIsImZsdXNoU3luY0NhbGxiYWNrcyIsInByZXZpb3VzVXBkYXRlUHJpb3JpdHkiLCJpc1N5bmMiLCJxdWV1ZSIsInNsaWNlIiwiaXNSb290RGVoeWRyYXRlZCIsImN1cnJlbnRTdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJpc0RlaHlkcmF0ZWQiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyIsIk5vVHJhbnNpdGlvbiIsInJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5cyIsImtleXNCIiwiY3VycmVudEtleSIsImRlc2NyaWJlRmliZXIiLCJfZGVidWdPd25lciIsIl9kZWJ1Z1NvdXJjZSIsImdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsImlzUmVuZGVyaW5nIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicmVzZXRDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50U3RhY2siLCJzZXRDdXJyZW50RmliZXIiLCJzZXRJc1JlbmRlcmluZyIsInJlbmRlcmluZyIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJmaW5kU3RyaWN0Um9vdCIsIm1heWJlU3RyaWN0Um9vdCIsIm1vZGUiLCJzZXRUb1NvcnRlZFN0cmluZyIsImFycmF5Iiwic29ydCIsImpvaW4iLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsIlNldCIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzMiIsIl9zb3J0ZWROYW1lczMiLCJfc29ydGVkTmFtZXM0IiwiX3NvcnRlZE5hbWVzNSIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290Iiwid2FybmluZ3NGb3JSb290IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImNvbnN0cnVjdG9yIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJlIiwiY2hlY2tLZXlTdHJpbmdDb2VyY2lvbiIsImNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uIiwicHJvcE5hbWUiLCJyZXNvbHZlRGVmYXVsdFByb3BzIiwiYmFzZVByb3BzIiwiZGVmYXVsdFByb3BzIiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwiZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsImV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInB1c2hQcm92aWRlciIsInByb3ZpZGVyRmliZXIiLCJuZXh0VmFsdWUiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRSZW5kZXJlciIsIl9jdXJyZW50VmFsdWUyIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJwcm9wYWdhdGlvblJvb3QiLCJjaGlsZExhbmVzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIiLCJuZXh0RmliZXIiLCJsaXN0IiwiZGVwZW5kZW5jaWVzIiwiZGVwZW5kZW5jeSIsImZpcnN0Q29udGV4dCIsInVwZGF0ZSIsImNyZWF0ZVVwZGF0ZSIsIkZvcmNlVXBkYXRlIiwidXBkYXRlUXVldWUiLCJzaGFyZWRRdWV1ZSIsInNoYXJlZCIsInBlbmRpbmciLCJuZXh0IiwicGFyZW50U3VzcGVuc2UiLCJfYWx0ZXJuYXRlIiwicHJlcGFyZVRvUmVhZENvbnRleHQiLCJtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSIsInJlYWRDb250ZXh0IiwiY29udGV4dEl0ZW0iLCJtZW1vaXplZFZhbHVlIiwiaW50ZXJsZWF2ZWRRdWV1ZXMiLCJwdXNoSW50ZXJsZWF2ZWRRdWV1ZSIsImVucXVldWVJbnRlcmxlYXZlZFVwZGF0ZXMiLCJsYXN0SW50ZXJsZWF2ZWRVcGRhdGUiLCJpbnRlcmxlYXZlZCIsImZpcnN0SW50ZXJsZWF2ZWRVcGRhdGUiLCJsYXN0UGVuZGluZ1VwZGF0ZSIsImZpcnN0UGVuZGluZ1VwZGF0ZSIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiQ2FwdHVyZVVwZGF0ZSIsImhhc0ZvcmNlVXBkYXRlIiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwiZWZmZWN0cyIsImNsb25lVXBkYXRlUXVldWUiLCJjdXJyZW50UXVldWUiLCJjbG9uZSIsImVucXVldWVVcGRhdGUiLCJpc0ludGVybGVhdmVkVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9ucyIsInF1ZXVlTGFuZXMiLCJuZXdRdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJwZW5kaW5nUXVldWUiLCJjdXJyZW50TGFzdEJhc2VVcGRhdGUiLCJuZXdTdGF0ZSIsIm5ld0xhbmVzIiwibmV3QmFzZVN0YXRlIiwibmV3Rmlyc3RCYXNlVXBkYXRlIiwibmV3TGFzdEJhc2VVcGRhdGUiLCJ1cGRhdGVFdmVudFRpbWUiLCJfY2xvbmUiLCJfbGFzdFBlbmRpbmdVcGRhdGUiLCJfZmlyc3RQZW5kaW5nVXBkYXRlIiwibGFzdEludGVybGVhdmVkIiwibWFya1NraXBwZWRVcGRhdGVMYW5lcyIsImNhbGxDYWxsYmFjayIsInJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nIiwiY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZyIsImNvbW1pdFVwZGF0ZVF1ZXVlIiwiZmluaXNoZWRXb3JrIiwiZmluaXNoZWRRdWV1ZSIsImVmZmVjdCIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZW1wdHlSZWZzT2JqZWN0IiwicmVmcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiY2FsbGVyTmFtZSIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVNldFN0YXRlIiwiaW5zdCIsInJlcXVlc3RFdmVudFRpbWUiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJvbGRTdGF0ZSIsIm5leHRDb250ZXh0Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwic2hvdWxkVXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJzdGF0ZSIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiX3N0YXRlIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwidXBkYXRlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwiaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIiLCJpc1ZhbGlkIiwiYWRkZW5kdW0iLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImNvbXBvbmVudERpZE1vdW50IiwiZmliZXJGbGFncyIsInJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSIsIm1lbW9pemVkUHJvcHMiLCJvbGRDb250ZXh0IiwibmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCIsImhhc05ld0xpZmVjeWNsZXMiLCJfZmliZXJGbGFncyIsIl9maWJlckZsYWdzMiIsInVwZGF0ZUNsYXNzSW5zdGFuY2UiLCJ1bnJlc29sdmVkT2xkUHJvcHMiLCJlbGVtZW50VHlwZSIsInVucmVzb2x2ZWROZXdQcm9wcyIsInBlbmRpbmdQcm9wcyIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrUHJvdmlkZXIiLCJ0cmVlRm9ya0NvdW50IiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsImlzRm9ya2VkQ2hpbGQiLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJnZXRGb3Jrc0F0TGV2ZWwiLCJnZXRUcmVlSWQiLCJvdmVyZmxvdyIsImlkV2l0aExlYWRpbmdCaXQiLCJpZCIsImdldExlYWRpbmdCaXQiLCJ0b1N0cmluZyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJwdXNoVHJlZUlkIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlT3ZlcmZsb3ciLCJiYXNlTGVuZ3RoIiwiZ2V0Qml0TGVuZ3RoIiwiYmFzZUlkIiwic2xvdCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3ciLCJyZXN0T2ZCYXNlSWQiLCJyZXN0T2ZCYXNlTGVuZ3RoIiwicmVzdE9mTGVuZ3RoIiwicmVzdE9mTmV3Qml0cyIsIm5ld0JpdHMiLCJfaWQiLCJfb3ZlcmZsb3ciLCJwdXNoTWF0ZXJpYWxpemVkVHJlZUlkIiwicmV0dXJuRmliZXIiLCJudW1iZXJPZkZvcmtzIiwic2xvdEluZGV4IiwibnVtYmVyIiwicG9wVHJlZUNvbnRleHQiLCJnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCIsInJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCIsInN1c3BlbmRlZENvbnRleHQiLCJnZXRJc0h5ZHJhdGluZyIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwibmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImlzSHlkcmF0aW5nIiwiZGlkU3VzcGVuZCIsImh5ZHJhdGlvbkVycm9ycyIsIndhcm5JZkh5ZHJhdGluZyIsIm1hcmtEaWRTdXNwZW5kV2hpbGVIeWRyYXRpbmdERVYiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicGFyZW50SW5zdGFuY2UiLCJjb250YWluZXJJbmZvIiwicmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwic3VzcGVuc2VJbnN0YW5jZSIsInRyZWVDb250ZXh0Iiwid2FyblVuaHlkcmF0ZWRJbnN0YW5jZSIsInN1c3BlbnNlU3RhdGUiLCJkZWh5ZHJhdGVkIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiY2hpbGRUb0RlbGV0ZSIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiZGVsZXRpb25zIiwid2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJ0ZXh0IiwicGFyZW50VHlwZSIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsIl9wYXJlbnRJbnN0YW5jZSIsIl90eXBlMiIsIl9wcm9wczIiLCJfdGV4dDIiLCJpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlIiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInRleHRJbnN0YW5jZSIsInJldHJ5TGFuZSIsImRlaHlkcmF0ZWRGcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudCIsInNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2giLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UiLCJwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwicm9vdENvbnRhaW5lckluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJzaG91bGRXYXJuSWZNaXNtYXRjaERldiIsInVwZGF0ZVBheWxvYWQiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInRleHRDb250ZW50IiwiaXNDb25jdXJyZW50TW9kZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSIsInNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJ3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzIiwiaGFzVW5oeWRyYXRlZFRhaWxOb2RlcyIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJ1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSIsInF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiZGlkV2FybkFib3V0TWFwcyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsInJlZiIsIl9zZWxmIiwicmVzb2x2ZWRJbnN0Iiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiY2hpbGRTdHJpbmciLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJyZXNvbHZlTGF6eSIsImxhenlUeXBlIiwiQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlRnJhZ21lbnQiLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwidXBkYXRlUG9ydGFsIiwicG9ydGFsIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9udW1iZXJPZkZvcmtzIiwiX25ld0ZpYmVyMiIsImRlbGV0ZSIsIl9udW1iZXJPZkZvcmtzMiIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImVudHJpZXMiLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsImRvbmUiLCJzdGVwIiwiX25ld0ZpYmVyMyIsIl9udW1iZXJPZkZvcmtzMyIsIl9uZXdGaWJlcjQiLCJfbnVtYmVyT2ZGb3JrczQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfZXhpc3RpbmciLCJfY3JlYXRlZDQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQiLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsInJlc2V0Q2hpbGRGaWJlcnMiLCJyZXNldFdvcmtJblByb2dyZXNzIiwiTk9fQ09OVEVYVCIsImNvbnRleHRTdGFja0N1cnNvciQxIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicm9vdEluc3RhbmNlIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJEZWZhdWx0U3VzcGVuc2VDb250ZXh0IiwiU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2siLCJJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJzdXNwZW5zZVN0YWNrQ3Vyc29yIiwiaGFzU3VzcGVuc2VDb250ZXh0IiwiZmxhZyIsInNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0Iiwic2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dCIsInNoYWxsb3dDb250ZXh0IiwiYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dCIsInN1YnRyZWVDb250ZXh0IiwicHVzaFN1c3BlbnNlQ29udGV4dCIsIm5ld0NvbnRleHQiLCJwb3BTdXNwZW5zZUNvbnRleHQiLCJzaG91bGRDYXB0dXJlU3VzcGVuc2UiLCJoYXNJbnZpc2libGVQYXJlbnQiLCJmaW5kRmlyc3RTdXNwZW5kZWQiLCJyb3ciLCJyZXZlYWxPcmRlciIsIk5vRmxhZ3MkMSIsIkhhc0VmZmVjdCIsIkluc2VydGlvbiIsIkxheW91dCIsIlBhc3NpdmUkMSIsIndvcmtJblByb2dyZXNzU291cmNlcyIsInJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucyIsIm11dGFibGVTb3VyY2UiLCJfd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSIsIl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25TZWNvbmRhcnkiLCJyZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24iLCJnZXRWZXJzaW9uIiwiX2dldFZlcnNpb24iLCJ2ZXJzaW9uIiwibXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEiLCJkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQiLCJkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJsb2NhbElkQ291bnRlciIsImdsb2JhbENsaWVudElkQ291bnRlciIsIlJFX1JFTkRFUl9MSU1JVCIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwiaG9va1R5cGVzRGV2IiwiaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJ3YXJuT25Ib29rTWlzbWF0Y2hJbkRldiIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiZGVwcyIsImN1cnJlbnRIb29rTmFtZSIsInRhYmxlIiwic2Vjb25kQ29sdW1uU3RhcnQiLCJvbGRIb29rTmFtZSIsIm5ld0hvb2tOYW1lIiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsInJlbmRlcldpdGhIb29rcyIsInNlY29uZEFyZyIsIm5leHRSZW5kZXJMYW5lcyIsIl9kZWJ1Z0hvb2tUeXBlcyIsIkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJDb250ZXh0T25seURpc3BhdGNoZXIiLCJkaWRSZW5kZXJUb29GZXdIb29rcyIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwiYmFpbG91dEhvb2tzIiwicmVzZXRIb29rc0FmdGVyVGhyb3ciLCJpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlUXVldWUiLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0Q3VycmVudEhvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwibmV3SG9vayIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUiLCJsYXN0RWZmZWN0Iiwic3RvcmVzIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwibGFzdFJlbmRlcmVkUmVkdWNlciIsImxhc3RSZW5kZXJlZFN0YXRlIiwiZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsImJhc2VGaXJzdCIsInBlbmRpbmdGaXJzdCIsImZpcnN0IiwibmV3QmFzZVF1ZXVlRmlyc3QiLCJuZXdCYXNlUXVldWVMYXN0IiwiaGFzRWFnZXJTdGF0ZSIsImVhZ2VyU3RhdGUiLCJpbnRlcmxlYXZlZExhbmUiLCJyZXJlbmRlclJlZHVjZXIiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJmaXJzdFJlbmRlclBoYXNlVXBkYXRlIiwibW91bnRNdXRhYmxlU291cmNlIiwiZ2V0U25hcHNob3QiLCJzdWJzY3JpYmUiLCJ1cGRhdGVNdXRhYmxlU291cmNlIiwibW91bnRTeW5jRXh0ZXJuYWxTdG9yZSIsImdldFNlcnZlclNuYXBzaG90IiwibmV4dFNuYXBzaG90IiwiY2FjaGVkU25hcHNob3QiLCJnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsInVwZGF0ZVN0b3JlSW5zdGFuY2UiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsInByZXZTbmFwc2hvdCIsInNuYXBzaG90Q2hhbmdlZCIsInVwZGF0ZUVmZmVjdCIsInJlbmRlcmVkU25hcHNob3QiLCJjaGVjayIsImNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImZvcmNlU3RvcmVSZXJlbmRlciIsImhhbmRsZVN0b3JlQ2hhbmdlIiwibGF0ZXN0R2V0U25hcHNob3QiLCJwcmV2VmFsdWUiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsInVwZGF0ZVN0YXRlIiwicmVyZW5kZXJTdGF0ZSIsImNyZWF0ZSIsImRlc3Ryb3kiLCJmaXJzdEVmZmVjdCIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwiX3JlZjIiLCJ1cGRhdGVSZWYiLCJtb3VudEVmZmVjdEltcGwiLCJob29rRmxhZ3MiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicHJldkVmZmVjdCIsIm1vdW50SW5zZXJ0aW9uRWZmZWN0IiwidXBkYXRlSW5zZXJ0aW9uRWZmZWN0IiwibW91bnRMYXlvdXRFZmZlY3QiLCJ1cGRhdGVMYXlvdXRFZmZlY3QiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2FsbGJhY2siLCJfaW5zdCIsInJlZk9iamVjdCIsIl9pbnN0MiIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsImVmZmVjdERlcHMiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnREZWJ1Z1ZhbHVlIiwiZm9ybWF0dGVyRm4iLCJ1cGRhdGVEZWJ1Z1ZhbHVlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJfbW91bnRTdGF0ZSIsInNldFZhbHVlIiwicHJldlRyYW5zaXRpb24iLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwiX3VwZGF0ZVN0YXRlIiwicmVyZW5kZXJEZWZlcnJlZFZhbHVlIiwiX3JlcmVuZGVyU3RhdGUiLCJzdGFydFRyYW5zaXRpb24iLCJzZXRQZW5kaW5nIiwib3B0aW9ucyIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJ1cGRhdGVkRmliZXJzQ291bnQiLCJtb3VudFRyYW5zaXRpb24iLCJfbW91bnRTdGF0ZTIiLCJpc1BlbmRpbmciLCJzdGFydCIsInVwZGF0ZVRyYW5zaXRpb24iLCJfdXBkYXRlU3RhdGUyIiwicmVyZW5kZXJUcmFuc2l0aW9uIiwiX3JlcmVuZGVyU3RhdGUyIiwiZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZ2xvYmFsQ2xpZW50SWQiLCJ1cGRhdGVJZCIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJtYXJrVXBkYXRlSW5EZXZUb29scyIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlkIiwidW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJub3ckMiIsImNvbW1pdFRpbWUiLCJsYXlvdXRFZmZlY3RTdGFydFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsInBhc3NpdmVFZmZlY3RTdGFydFRpbWUiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJpc0N1cnJlbnRVcGRhdGVOZXN0ZWQiLCJtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwicmVzZXROZXN0ZWRVcGRhdGVGbGFnIiwic3luY05lc3RlZFVwZGF0ZUZsYWciLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJlbGFwc2VkVGltZSIsImFjdHVhbER1cmF0aW9uIiwic2VsZkJhc2VEdXJhdGlvbiIsInJlY29yZExheW91dEVmZmVjdER1cmF0aW9uIiwicGFyZW50RmliZXIiLCJlZmZlY3REdXJhdGlvbiIsInBhcmVudFN0YXRlTm9kZSIsInJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInBhc3NpdmVFZmZlY3REdXJhdGlvbiIsInN0YXJ0TGF5b3V0RWZmZWN0VGltZXIiLCJzdGFydFBhc3NpdmVFZmZlY3RUaW1lciIsInRyYW5zZmVyQWN0dWFsRHVyYXRpb24iLCJjcmVhdGVDYXB0dXJlZFZhbHVlIiwic2hvd0Vycm9yRGlhbG9nIiwiYm91bmRhcnkiLCJlcnJvckluZm8iLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJjb21wb25lbnRTdGFjayIsIl9zdXBwcmVzc0xvZ2dpbmciLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJjb21iaW5lZE1lc3NhZ2UiLCJzZXRUaW1lb3V0IiwiUG9zc2libHlXZWFrTWFwJDEiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJvblVuY2F1Z2h0RXJyb3IiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwibWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmciLCJjb21wb25lbnREaWRDYXRjaCIsIm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQiLCJhdHRhY2hQaW5nTGlzdGVuZXIiLCJwaW5nQ2FjaGUiLCJ0aHJlYWRJRHMiLCJwaW5nIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzIiwidGhlbiIsImF0dGFjaFJldHJ5TGlzdGVuZXIiLCJzdXNwZW5zZUJvdW5kYXJ5Iiwid2FrZWFibGVzIiwicmVzZXRTdXNwZW5kZWRDb21wb25lbnQiLCJzb3VyY2VGaWJlciIsInJvb3RSZW5kZXJMYW5lcyIsImN1cnJlbnRTb3VyY2UiLCJnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZSIsIm1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZSIsImN1cnJlbnRTdXNwZW5zZUJvdW5kYXJ5Iiwib2Zmc2NyZWVuRmliZXIiLCJvZmZzY3JlZW5Db250YWluZXIiLCJjb250YWluZXJQcm9wcyIsImN1cnJlbnRTb3VyY2VGaWJlciIsInRocm93RXhjZXB0aW9uIiwicmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSIsInVuY2F1Z2h0U3VzcGVuc2VFcnJvciIsIl9zdXNwZW5zZUJvdW5kYXJ5IiwicmVuZGVyRGlkRXJyb3IiLCJfZXJyb3JJbmZvIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsIl9sYW5lIiwiX3VwZGF0ZSIsImdldFN1c3BlbmRlZENhY2hlIiwibWFya1VwZGF0ZSIsIm1hcmtSZWYiLCJoYWROb011dGF0aW9uc0VmZmVjdHMiLCJjb21wbGV0ZWRXb3JrIiwiZGlkQmFpbG91dCIsInN1YnRyZWVGbGFncyIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJ1cGRhdGVIb3N0VGV4dCIsIm5lZWRzVmlzaWJpbGl0eVRvZ2dsZSIsImlzSGlkZGVuIiwiY3VycmVudEhvc3RDb250ZXh0Iiwib2xkVGV4dCIsIm5ld1RleHQiLCJfaW5zdGFuY2UiLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJfaW5zdGFuY2UyIiwicG9ydGFsT3JSb290IiwiY2hpbGRyZW5VbmNoYW5nZWQiLCJjb250YWluZXIiLCJuZXdDaGlsZFNldCIsInBlbmRpbmdDaGlsZHJlbiIsImN1cnJlbnRJbnN0YW5jZSIsInJlY3ljbGFibGVJbnN0YW5jZSIsIm5ld0luc3RhbmNlIiwiY3V0T2ZmVGFpbElmTmVlZGVkIiwicmVuZGVyU3RhdGUiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJ0YWlsTW9kZSIsInRhaWxOb2RlIiwidGFpbCIsImxhc3RUYWlsTm9kZSIsIl90YWlsTm9kZSIsIl9sYXN0VGFpbE5vZGUiLCJidWJibGVQcm9wZXJ0aWVzIiwibmV3Q2hpbGRMYW5lcyIsInRyZWVCYXNlRHVyYXRpb24iLCJfdHJlZUJhc2VEdXJhdGlvbiIsIl9jaGlsZDIiLCJfY2hpbGQzIiwiY29tcGxldGVXb3JrIiwiZmliZXJSb290IiwicGVuZGluZ0NvbnRleHQiLCJ3YXNIeWRyYXRlZCIsIl93YXNIeWRyYXRlZCIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0IiwiX3dhc0h5ZHJhdGVkMiIsIl93YXNIeWRyYXRlZDMiLCJpc1RpbWVkT3V0U3VzcGVuc2UiLCJwcmltYXJ5Q2hpbGRGcmFnbWVudCIsIl9pc1RpbWVkT3V0U3VzcGVuc2UiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJuZXh0RGlkVGltZW91dCIsInByZXZEaWRUaW1lb3V0IiwiX3ByZXZTdGF0ZSIsIl9vZmZzY3JlZW5GaWJlciIsImhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCIsInVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIiwicmVuZGVyRGlkU3VzcGVuZCIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDIiLCJfQ29tcG9uZW50IiwiZGlkU3VzcGVuZEFscmVhZHkiLCJyZW5kZXJlZFRhaWwiLCJjYW5ub3RCZVN1c3BlbmRlZCIsInJlbmRlckhhc05vdFN1c3BlbmRlZFlldCIsInN1c3BlbmRlZCIsIm5ld1RoZW5hYmxlcyIsImdldFJlbmRlclRhcmdldFRpbWUiLCJfc3VzcGVuZGVkIiwiX25ld1RoZW5hYmxlcyIsInJlbmRlcmluZ1N0YXJ0VGltZSIsImlzQmFja3dhcmRzIiwicHJldmlvdXNTaWJsaW5nIiwibGFzdCIsInN1c3BlbnNlQ29udGV4dCIsInBvcFJlbmRlckxhbmVzIiwiX25leHRTdGF0ZSIsIm5leHRJc0hpZGRlbiIsIl9wcmV2U3RhdGUyIiwicHJldklzSGlkZGVuIiwic3VidHJlZVJlbmRlckxhbmVzIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsImRpZFJlY2VpdmVVcGRhdGUiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsImRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsImRpZFdhcm5BYm91dFJldmVhbE9yZGVyIiwiZGlkV2FybkFib3V0VGFpbE9wdGlvbnMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUiLCJ1cGRhdGVGb3J3YXJkUmVmIiwiaW5uZXJQcm9wVHlwZXMiLCJoYXNJZCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50IiwiaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCIsImNvbXBhcmUiLCJyZXNvbHZlZFR5cGUiLCJyZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmciLCJ2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYiLCJ1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50IiwiY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzIiwiX2lubmVyUHJvcFR5cGVzIiwiaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwiY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJwcmV2UHJvcHMiLCJvdXRlck1lbW9UeXBlIiwib3V0ZXJQcm9wVHlwZXMiLCJ1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudCIsImJhc2VMYW5lcyIsImNhY2hlUG9vbCIsInB1c2hSZW5kZXJMYW5lcyIsInNwYXduZWRDYWNoZVBvb2wiLCJuZXh0QmFzZUxhbmVzIiwicHJldkJhc2VMYW5lcyIsIl9uZXh0U3RhdGUyIiwiX3N1YnRyZWVSZW5kZXJMYW5lcyIsInVwZGF0ZU1vZGUiLCJ1cGRhdGVQcm9maWxlciIsIm1hcmtSZWYkMSIsInVwZGF0ZUNsYXNzQ29tcG9uZW50Iiwic2hvdWxkRXJyb3IiLCJ0ZW1wSW5zdGFuY2UiLCJoYXNDb250ZXh0IiwibmV4dFVuaXRPZldvcmsiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInByZXZDaGlsZHJlbiIsIm92ZXJyaWRlU3RhdGUiLCJjYWNoZSIsInRyYW5zaXRpb25zIiwicmVjb3ZlcmFibGVFcnJvciIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwiX3JlY292ZXJhYmxlRXJyb3IiLCJ1cGRhdGVIb3N0Q29tcG9uZW50JDEiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0JDEiLCJtb3VudExhenlDb21wb25lbnQiLCJfY3VycmVudCIsInJlc29sdmVkVGFnIiwicmVzb2x2ZUxhenlDb21wb25lbnRUYWciLCJyZXNvbHZlZFByb3BzIiwicmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nIiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJoaW50IiwibW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJfY29tcG9uZW50TmFtZTIiLCJvd25lck5hbWUiLCJ3YXJuaW5nS2V5IiwiZGVidWdTb3VyY2UiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJfY29tcG9uZW50TmFtZTMiLCJfY29tcG9uZW50TmFtZTQiLCJTVVNQRU5ERURfTUFSS0VSIiwibW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwidXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsInByZXZPZmZzY3JlZW5TdGF0ZSIsInNob3VsZFJlbWFpbk9uRmFsbGJhY2siLCJnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZSIsInVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50Iiwic2hvdWxkU3VzcGVuZCIsInNob3dGYWxsYmFjayIsIm1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IiwibmV4dFByaW1hcnlDaGlsZHJlbiIsIm5leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2siLCJmYWxsYmFja0ZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwiX2RlaHlkcmF0ZWQiLCJ1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJyZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuIiwiX25leHRGYWxsYmFja0NoaWxkcmVuIiwiZmFsbGJhY2tDaGlsZEZyYWdtZW50IiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmciLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4yIiwiX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsInVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbiIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDMiLCJfbmV4dFByaW1hcnlDaGlsZHJlbjMiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0IiwidXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zIiwiX25leHRQcmltYXJ5Q2hpbGRyZW40IiwiX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDIiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQ1IiwiX3ByZXZPZmZzY3JlZW5TdGF0ZSIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuNSIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDYiLCJwcmltYXJ5Q2hpbGRyZW4iLCJwcmltYXJ5Q2hpbGRQcm9wcyIsIm1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsImZhbGxiYWNrQ2hpbGRyZW4iLCJwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50Iiwib2Zmc2NyZWVuUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50IiwiY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsImZpYmVyTW9kZSIsImF0dGVtcHRIeWRyYXRpb25BdExhbmUiLCJyZXRyeSIsInJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIiLCJwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2UiLCJmaXJzdENoaWxkIiwiZmluZExhc3RDb250ZW50Um93IiwibGFzdENvbnRlbnRSb3ciLCJjdXJyZW50Um93IiwidmFsaWRhdGVSZXZlYWxPcmRlciIsInRvTG93ZXJDYXNlIiwidmFsaWRhdGVUYWlsT3B0aW9ucyIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0FuQXJyYXkiLCJpc0l0ZXJhYmxlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbiIsImNoaWxkcmVuSXRlcmF0b3IiLCJfaSIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsInNob3VsZEZvcmNlRmFsbGJhY2siLCJkaWRTdXNwZW5kQmVmb3JlIiwiX3RhaWwiLCJuZXh0Um93IiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJuZXdWYWx1ZSIsInByb3ZpZGVyUHJvcFR5cGVzIiwib2xkVmFsdWUiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsInJlbW91bnRGaWJlciIsIm9sZFdvcmtJblByb2dyZXNzIiwibmV3V29ya0luUHJvZ3Jlc3MiLCJwcmV2U2libGluZyIsInVwZGF0ZUxhbmVzIiwiYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUiLCJoYXNDaGlsZFdvcmsiLCJwcmltYXJ5Q2hpbGRMYW5lcyIsIl9oYXNDaGlsZFdvcmsiLCJiZWdpbldvcmsiLCJfZGVidWdOZWVkc1JlbW91bnQiLCJ1bnJlc29sdmVkUHJvcHMiLCJfdW5yZXNvbHZlZFByb3BzIiwiX3Jlc29sdmVkUHJvcHMiLCJfdW5yZXNvbHZlZFByb3BzMiIsIl9yZXNvbHZlZFByb3BzMiIsIl91bnJlc29sdmVkUHJvcHMzIiwiX3Jlc29sdmVkUHJvcHMzIiwiX0NvbXBvbmVudDIiLCJfdW5yZXNvbHZlZFByb3BzNCIsIl9yZXNvbHZlZFByb3BzNCIsInVud2luZFdvcmsiLCJfZmxhZ3MiLCJfZmxhZ3MyIiwidW53aW5kSW50ZXJydXB0ZWRXb3JrIiwiaW50ZXJydXB0ZWRXb3JrIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZCIsImZ1bmMiLCJkIiwiZiIsImZ1bmNBcmdzIiwib25FcnJvciIsImludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiY3JlYXRlRWxlbWVudCIsImludm9rZUd1YXJkZWRDYWxsYmFja0RldiIsImV2dCIsImRpZENhbGwiLCJ3aW5kb3dFdmVudCIsImV2ZW50Iiwid2luZG93RXZlbnREZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicmVzdG9yZUFmdGVyRGlzcGF0Y2giLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZ0VHlwZSIsImRpZFNldEVycm9yIiwiaXNDcm9zc09yaWdpbkVycm9yIiwiaGFuZGxlV2luZG93RXJyb3IiLCJjb2xubyIsImxpbmVubyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpbm5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbml0RXZlbnQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEiLCJoYXNFcnJvciIsImNhdWdodEVycm9yIiwicmVwb3J0ZXIiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJoYXNDYXVnaHRFcnJvciIsImNsZWFyQ2F1Z2h0RXJyb3IiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJQb3NzaWJseVdlYWtTZXQiLCJXZWFrU2V0IiwibmV4dEVmZmVjdCIsImluUHJvZ3Jlc3NMYW5lcyIsImluUHJvZ3Jlc3NSb290IiwicmVwb3J0VW5jYXVnaHRFcnJvckluREVWIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudCIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjb21taXRIb29rRWZmZWN0TGlzdE1vdW50IiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQiLCJzYWZlbHlBdHRhY2hSZWYiLCJjb21taXRBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJyZXRWYWwiLCJzYWZlbHlDYWxsRGVzdHJveSIsImZvY3VzZWRJbnN0YW5jZUhhbmRsZSIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbiIsInNob3VsZEZpcmUiLCJlbnN1cmVDb3JyZWN0UmV0dXJuUG9pbnRlciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJzbmFwc2hvdCIsImRpZFdhcm5TZXQiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCIsImNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMiLCJmaW5pc2hlZFJvb3QiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvblBvc3RDb21taXQiLCJwaGFzZSIsIm91dGVyIiwiY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciIsImNvbW1pdHRlZExhbmVzIiwiX3VwZGF0ZVF1ZXVlIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdCIsImNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzT25GaWJlciIsImhpZGVPclVuaGlkZUFsbENoaWxkcmVuIiwiaG9zdFN1YnRyZWVSb290IiwiX2luc3RhbmNlMyIsImluc3RhbmNlVG9Vc2UiLCJjb21taXREZXRhY2hSZWYiLCJjdXJyZW50UmVmIiwiY29tbWl0VW5tb3VudCIsIl9lZmZlY3QiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImNvbW1pdE5lc3RlZFVubW91bnRzIiwiZGV0YWNoRmliZXJNdXRhdGlvbiIsImRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzIiwiaG9zdEluc3RhbmNlIiwiZW1wdHlDaGlsZFNldCIsImNvbW1pdENvbnRhaW5lciIsImdldEhvc3RQYXJlbnRGaWJlciIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwic2libGluZ3MiLCJjb21taXRQbGFjZW1lbnQiLCJiZWZvcmUiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUiLCJfcGFyZW50IiwiX2JlZm9yZSIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJpc0hvc3QiLCJjdXJyZW50UGFyZW50SXNWYWxpZCIsImN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciIsImZpbmRQYXJlbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRTdXNwZW5zZUNhbGxiYWNrIiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsInByZXZSb290U3RhdGUiLCJfcHJldlJvb3RTdGF0ZSIsIl9yb290IiwicmV0cnlDYWNoZSIsInJlc29sdmVSZXRyeVdha2VhYmxlIiwiY29tbWl0UmVzZXRUZXh0Q29udGVudCIsImNvbW1pdE11dGF0aW9uRWZmZWN0cyIsImNvbW1pdE11dGF0aW9uRWZmZWN0c19iZWdpbiIsImNvbW1pdE11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJ3YXNIaWRkZW4iLCJtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2siLCJfbmV3U3RhdGUiLCJfaXNIaWRkZW4iLCJfY3VycmVudDIiLCJfd2FzSGlkZGVuIiwib2Zmc2NyZWVuQm91bmRhcnkiLCJvZmZzY3JlZW5DaGlsZCIsImRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4iLCJwcmltYXJ5RmxhZ3MiLCJfY3VycmVudDMiLCJfY3VycmVudDQiLCJfY3VycmVudDUiLCJjb21taXRMYXlvdXRFZmZlY3RzIiwiY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbiIsInN1YnRyZWVSb290IiwiaXNNb2Rlcm5Sb290IiwibmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwiY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlIiwibmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsInJlYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbiIsImRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUiLCJyZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c19iZWdpbiIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luIiwiZmliZXJUb0RlbGV0ZSIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4iLCJwcmV2aW91c0ZpYmVyIiwiZGV0YWNoZWRDaGlsZCIsImRldGFjaGVkU2libGluZyIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsImNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZSIsImRpZFdhcm5Xcm9uZ1JldHVyblBvaW50ZXIiLCJleHBlY3RlZFJldHVybkZpYmVyIiwiaW52b2tlTGF5b3V0RWZmZWN0TW91bnRJbkRFViIsImludm9rZVBhc3NpdmVFZmZlY3RNb3VudEluREVWIiwiaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWIiwiaW52b2tlUGFzc2l2ZUVmZmVjdFVubW91bnRJbkRFViIsIkNPTVBPTkVOVF9UWVBFIiwiSEFTX1BTRVVET19DTEFTU19UWVBFIiwiUk9MRV9UWVBFIiwiVEVTVF9OQU1FX1RZUEUiLCJURVhUX1RZUEUiLCJzeW1ib2xGb3IiLCJjcmVhdGVDb21wb25lbnRTZWxlY3RvciIsImNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IiLCJzZWxlY3RvcnMiLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGV4dFNlbGVjdG9yIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdCIsImhvc3RSb290IiwibWF5YmVGaWJlciIsIm1hdGNoU2VsZWN0b3IiLCJzZWxlY3RvciIsImhhc01hdGNoaW5nUGF0aHMiLCJpbmRleE9mIiwiZGF0YVRlc3RJRCIsInNlbGVjdG9yVG9TdHJpbmciLCJmaW5kUGF0aHMiLCJtYXRjaGluZ0ZpYmVycyIsInNlbGVjdG9ySW5kZXgiLCJmaW5kQWxsTm9kZXMiLCJpbnN0YW5jZVJvb3RzIiwiZnJvbSIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJ1bm1hdGNoZWROYW1lcyIsImZpbmRCb3VuZGluZ1JlY3RzIiwiYm91bmRpbmdSZWN0cyIsInRhcmdldFJlY3QiLCJ0YXJnZXRMZWZ0IiwidGFyZ2V0UmlnaHQiLCJ3aWR0aCIsInRhcmdldFRvcCIsInRhcmdldEJvdHRvbSIsImhlaWdodCIsImoiLCJvdGhlclJlY3QiLCJvdGhlckxlZnQiLCJvdGhlclJpZ2h0Iiwib3RoZXJUb3AiLCJvdGhlckJvdHRvbSIsInNwbGljZSIsImZvY3VzV2l0aGluIiwiY29tbWl0SG9va3MiLCJvbkNvbW1pdFJvb3QkMSIsImNvbW1pdEhvb2siLCJvYnNlcnZlVmlzaWJsZVJlY3RzIiwiX3NldHVwSW50ZXJzZWN0aW9uT2JzIiwiZGlzY29ubmVjdCIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJuZXh0SW5zdGFuY2VSb290cyIsInRhcmdldCIsIlJlYWN0Q3VycmVudEFjdFF1ZXVlIiwiaXNMZWdhY3lBY3RFbnZpcm9ubWVudCIsImlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCIsIklTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCIsImplc3RJc0RlZmluZWQiLCJqZXN0IiwiaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQiLCJjZWlsIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyIiwiUmVhY3RDdXJyZW50T3duZXIkMiIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIiLCJSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxIiwiTm9Db250ZXh0IiwiQmF0Y2hlZENvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIlJvb3RJblByb2dyZXNzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RFcnJvcmVkIiwiUm9vdFN1c3BlbmRlZCIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290Q29tcGxldGVkIiwiUm9vdERpZE5vdENvbXBsZXRlIiwiZXhlY3V0aW9uQ29udGV4dCIsIndvcmtJblByb2dyZXNzUm9vdCIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwic3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIndvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyIsImdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUiLCJJbmZpbml0eSIsIlJFTkRFUl9USU1FT1VUX01TIiwicmVzZXRSZW5kZXJUaW1lciIsImhhc1VuY2F1Z2h0RXJyb3IiLCJmaXJzdFVuY2F1Z2h0RXJyb3IiLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsInJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIiwicm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyIsInBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50Iiwicm9vdFdpdGhOZXN0ZWRVcGRhdGVzIiwiTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUIiwibmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50IiwiY3VycmVudEV2ZW50VGltZSIsImN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lIiwiaXNUcmFuc2l0aW9uIiwiZXZlbnRMYW5lIiwicmVxdWVzdFJldHJ5TGFuZSIsImNoZWNrRm9yTmVzdGVkVXBkYXRlcyIsIm1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290Iiwid2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYiLCJ3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYiLCJtYXJrUm9vdFN1c3BlbmRlZCQxIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwiaXNCYXRjaGluZ0xlZ2FjeSIsInNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdCIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJleGlzdGluZ0NhbGxiYWNrTm9kZSIsImNhbGxiYWNrTm9kZSIsImNhbmNlbENhbGxiYWNrJDEiLCJjYWxsYmFja1ByaW9yaXR5IiwibmV3Q2FsbGJhY2tQcmlvcml0eSIsImV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSIsImZha2VBY3RDYWxsYmFja05vZGUiLCJuZXdDYWxsYmFja05vZGUiLCJkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsInNjaGVkdWxlQ2FsbGJhY2skMSIsInNjaGVkdWxlclByaW9yaXR5TGV2ZWwiLCJwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QiLCJkaWRUaW1lb3V0Iiwib3JpZ2luYWxDYWxsYmFja05vZGUiLCJkaWRGbHVzaFBhc3NpdmVFZmZlY3RzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNob3VsZFRpbWVTbGljZSIsImV4aXRTdGF0dXMiLCJyZW5kZXJSb290Q29uY3VycmVudCIsInJlbmRlclJvb3RTeW5jIiwiZXJyb3JSZXRyeUxhbmVzIiwicmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3IiLCJmYXRhbEVycm9yIiwicHJlcGFyZUZyZXNoU3RhY2siLCJyZW5kZXJXYXNDb25jdXJyZW50IiwiaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzIiwiX2Vycm9yUmV0cnlMYW5lcyIsIl9mYXRhbEVycm9yIiwiZmluaXNoZWRMYW5lcyIsImZpbmlzaENvbmN1cnJlbnRSZW5kZXIiLCJlcnJvcnNGcm9tRmlyc3RBdHRlbXB0Iiwicm9vdFdvcmtJblByb2dyZXNzIiwiZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQiLCJlcnJvcnMiLCJjb21taXRSb290Iiwic2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWIiwibXNVbnRpbFRpbWVvdXQiLCJ0aW1lb3V0SGFuZGxlIiwiZXZlbnRUaW1lTXMiLCJ0aW1lRWxhcHNlZE1zIiwiX21zVW50aWxUaW1lb3V0Iiwiam5kIiwiY2hlY2tzIiwicmVuZGVyZWRWYWx1ZSIsImZsdXNoUm9vdCIsImRlZmVycmVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJkaXNjcmV0ZVVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJpc0FscmVhZHlSZW5kZXJpbmciLCJmbHVzaENvbnRyb2xsZWQiLCJoYW5kbGVFcnJvciIsImVycm9yZWRXb3JrIiwiY29tcGxldGVVbml0T2ZXb3JrIiwieWV0QW5vdGhlclRocm93blZhbHVlIiwicHVzaERpc3BhdGNoZXIiLCJwb3BEaXNwYXRjaGVyIiwid29ya0xvb3BTeW5jIiwicGVyZm9ybVVuaXRPZldvcmsiLCJ3b3JrTG9vcENvbmN1cnJlbnQiLCJ1bml0T2ZXb3JrIiwiYmVnaW5Xb3JrJDEiLCJfbmV4dCIsInNpYmxpbmdGaWJlciIsInJlY292ZXJhYmxlRXJyb3JzIiwicHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkiLCJjb21taXRSb290SW1wbCIsInJlbmRlclByaW9yaXR5TGV2ZWwiLCJmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYiLCJzdWJ0cmVlSGFzRWZmZWN0cyIsInJvb3RIYXNFZmZlY3QiLCJyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25SZWNvdmVyYWJsZUVycm9yIiwicmVuZGVyUHJpb3JpdHkiLCJmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCIsInByb2ZpbGVyRWZmZWN0cyIsIl9maWJlciIsInByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvciIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwid2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwidGltZUVsYXBzZWQiLCJoYXNQYXNzaXZlRWZmZWN0cyIsImludm9rZUVmZmVjdHNJbkRldiIsImludm9rZUVmZmVjdEZuIiwicHJpbWFyeVN1YnRyZWVGbGFnIiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCIsImR1bW15RmliZXIiLCJvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSIsImFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWIiwib3JpZ2luYWxFcnJvciIsInJlcGxheUVycm9yIiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJyZW5kZXJpbmdDb21wb25lbnROYW1lIiwiZGVkdXBlS2V5Iiwic2V0U3RhdGVDb21wb25lbnROYW1lIiwic2NoZWR1bGluZ0ZpYmVyIiwicHJpb3JpdHlMZXZlbCIsImFjdFF1ZXVlIiwicmVzb2x2ZUZhbWlseSIsImZhaWxlZEJvdW5kYXJpZXMiLCJzZXRSZWZyZXNoSGFuZGxlciIsImhhbmRsZXIiLCJmYW1pbHkiLCJjdXJyZW50UmVuZGVyIiwic3ludGhldGljVHlwZSIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJuZWVkc0NvbXBhcmVGYW1pbGllcyIsIiQkdHlwZW9mTmV4dFR5cGUiLCJwcmV2RmFtaWx5Iiwic2NoZWR1bGVSZWZyZXNoIiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsInNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkiLCJzY2hlZHVsZVJvb3QiLCJ1cGRhdGVDb250YWluZXIiLCJjYW5kaWRhdGVUeXBlIiwibmVlZHNSZW5kZXIiLCJuZWVkc1JlbW91bnQiLCJmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2giLCJmYW1pbGllcyIsImhvc3RJbnN0YW5jZXMiLCJ0eXBlcyIsImZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseSIsImRpZE1hdGNoIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImZvdW5kSG9zdEluc3RhbmNlcyIsImZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiRmliZXJOb2RlIiwiTnVtYmVyIiwiTmFOIiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QkMSIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiaXNTdHJpY3RNb2RlIiwiY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSIsImZpYmVyVGFnIiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZSIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdCIsImVsZW1lbnRzIiwicHJpbWFyeUNoaWxkSW5zdGFuY2UiLCJjb250ZW50IiwiZGVoeWRyYXRlZE5vZGUiLCJGaWJlclJvb3ROb2RlIiwiaHlkcmF0ZSIsIl9kZWJ1Z1Jvb3RUeXBlIiwiY3JlYXRlRmliZXJSb290IiwiaW5pdGlhbENoaWxkcmVuIiwiaHlkcmF0aW9uQ2FsbGJhY2tzIiwidHJhbnNpdGlvbkNhbGxiYWNrcyIsInVuaW5pdGlhbGl6ZWRGaWJlciIsIl9pbml0aWFsU3RhdGUiLCJSZWFjdFZlcnNpb24iLCJjcmVhdGVQb3J0YWwiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsImZpbmRIb3N0SW5zdGFuY2UiLCJob3N0RmliZXIiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiY3JlYXRlQ29udGFpbmVyIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3VycmVudCQxIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiY29udGFpbmVyRmliZXIiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsIm1hcmtSZXRyeUxhbmVJbXBsIiwiYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsInNob3VsZEVycm9ySW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwiY29weVdpdGhEZWxldGVJbXBsIiwib2JqIiwicGF0aCIsInVwZGF0ZWQiLCJjb3B5V2l0aERlbGV0ZSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZFBhdGgiLCJuZXdQYXRoIiwib2xkS2V5IiwibmV3S2V5IiwiY29weVdpdGhSZW5hbWUiLCJjb3B5V2l0aFNldEltcGwiLCJjb3B5V2l0aFNldCIsImZpbmRIb29rIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInJlbmRlcmVyQ29uZmlnIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJnZXRDdXJyZW50RmliZXIiLCJyZWNvbmNpbGVyVmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/constants.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/constants.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjI3LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQywwT0FBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjI3LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2NvbnN0YW50cy5qcz8yZGE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/index.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjI3LjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLHNOQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby8uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWNvbmNpbGVyQDAuMjcuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanM/MDUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.27.0_react@18.2.0/node_modules/react-reconciler/index.js\n");

/***/ })

};
;